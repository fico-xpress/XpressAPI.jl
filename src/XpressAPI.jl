#                                  Apache License
#                            Version 2.0, January 2004
#                         http://www.apache.org/licenses/
#
#    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
#
#    1. Definitions.
#
#       "License" shall mean the terms and conditions for use, reproduction,
#       and distribution as defined by Sections 1 through 9 of this document.
#
#       "Licensor" shall mean the copyright owner or entity authorized by
#       the copyright owner that is granting the License.
#
#       "Legal Entity" shall mean the union of the acting entity and all
#       other entities that control, are controlled by, or are under common
#       control with that entity. For the purposes of this definition,
#       "control" means (i) the power, direct or indirect, to cause the
#       direction or management of such entity, whether by contract or
#       otherwise, or (ii) ownership of fifty percent (50%) or more of the
#       outstanding shares, or (iii) beneficial ownership of such entity.
#
#       "You" (or "Your") shall mean an individual or Legal Entity
#       exercising permissions granted by this License.
#
#       "Source" form shall mean the preferred form for making modifications,
#       including but not limited to software source code, documentation
#       source, and configuration files.
#
#       "Object" form shall mean any form resulting from mechanical
#       transformation or translation of a Source form, including but
#       not limited to compiled object code, generated documentation,
#       and conversions to other media types.
#
#       "Work" shall mean the work of authorship, whether in Source or
#       Object form, made available under the License, as indicated by a
#       copyright notice that is included in or attached to the work
#       (an example is provided in the Appendix below).
#
#       "Derivative Works" shall mean any work, whether in Source or Object
#       form, that is based on (or derived from) the Work and for which the
#       editorial revisions, annotations, elaborations, or other modifications
#       represent, as a whole, an original work of authorship. For the purposes
#       of this License, Derivative Works shall not include works that remain
#       separable from, or merely link (or bind by name) to the interfaces of,
#       the Work and Derivative Works thereof.
#
#       "Contribution" shall mean any work of authorship, including
#       the original version of the Work and any modifications or additions
#       to that Work or Derivative Works thereof, that is intentionally
#       submitted to Licensor for inclusion in the Work by the copyright owner
#       or by an individual or Legal Entity authorized to submit on behalf of
#       the copyright owner. For the purposes of this definition, "submitted"
#       means any form of electronic, verbal, or written communication sent
#       to the Licensor or its representatives, including but not limited to
#       communication on electronic mailing lists, source code control systems,
#       and issue tracking systems that are managed by, or on behalf of, the
#       Licensor for the purpose of discussing and improving the Work, but
#       excluding communication that is conspicuously marked or otherwise
#       designated in writing by the copyright owner as "Not a Contribution."
#
#       "Contributor" shall mean Licensor and any individual or Legal Entity
#       on behalf of whom a Contribution has been received by Licensor and
#       subsequently incorporated within the Work.
#
#    2. Grant of Copyright License. Subject to the terms and conditions of
#       this License, each Contributor hereby grants to You a perpetual,
#       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#       copyright license to reproduce, prepare Derivative Works of,
#       publicly display, publicly perform, sublicense, and distribute the
#       Work and such Derivative Works in Source or Object form.
#
#    3. Grant of Patent License. Subject to the terms and conditions of
#       this License, each Contributor hereby grants to You a perpetual,
#       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#       (except as stated in this section) patent license to make, have made,
#       use, offer to sell, sell, import, and otherwise transfer the Work,
#       where such license applies only to those patent claims licensable
#       by such Contributor that are necessarily infringed by their
#       Contribution(s) alone or by combination of their Contribution(s)
#       with the Work to which such Contribution(s) was submitted. If You
#       institute patent litigation against any entity (including a
#       cross-claim or counterclaim in a lawsuit) alleging that the Work
#       or a Contribution incorporated within the Work constitutes direct
#       or contributory patent infringement, then any patent licenses
#       granted to You under this License for that Work shall terminate
#       as of the date such litigation is filed.
#
#    4. Redistribution. You may reproduce and distribute copies of the
#       Work or Derivative Works thereof in any medium, with or without
#       modifications, and in Source or Object form, provided that You
#       meet the following conditions:
#
#       (a) You must give any other recipients of the Work or
#           Derivative Works a copy of this License; and
#
#       (b) You must cause any modified files to carry prominent notices
#           stating that You changed the files; and
#
#       (c) You must retain, in the Source form of any Derivative Works
#           that You distribute, all copyright, patent, trademark, and
#           attribution notices from the Source form of the Work,
#           excluding those notices that do not pertain to any part of
#           the Derivative Works; and
#
#       (d) If the Work includes a "NOTICE" text file as part of its
#           distribution, then any Derivative Works that You distribute must
#           include a readable copy of the attribution notices contained
#           within such NOTICE file, excluding those notices that do not
#           pertain to any part of the Derivative Works, in at least one
#           of the following places: within a NOTICE text file distributed
#           as part of the Derivative Works; within the Source form or
#           documentation, if provided along with the Derivative Works; or,
#           within a display generated by the Derivative Works, if and
#           wherever such third-party notices normally appear. The contents
#           of the NOTICE file are for informational purposes only and
#           do not modify the License. You may add Your own attribution
#           notices within Derivative Works that You distribute, alongside
#           or as an addendum to the NOTICE text from the Work, provided
#           that such additional attribution notices cannot be construed
#           as modifying the License.
#
#       You may add Your own copyright statement to Your modifications and
#       may provide additional or different license terms and conditions
#       for use, reproduction, or distribution of Your modifications, or
#       for any such Derivative Works as a whole, provided Your use,
#       reproduction, and distribution of the Work otherwise complies with
#       the conditions stated in this License.
#
#    5. Submission of Contributions. Unless You explicitly state otherwise,
#       any Contribution intentionally submitted for inclusion in the Work
#       by You to the Licensor shall be under the terms and conditions of
#       this License, without any additional terms or conditions.
#       Notwithstanding the above, nothing herein shall supersede or modify
#       the terms of any separate license agreement you may have executed
#       with Licensor regarding such Contributions.
#
#    6. Trademarks. This License does not grant permission to use the trade
#       names, trademarks, service marks, or product names of the Licensor,
#       except as required for reasonable and customary use in describing the
#       origin of the Work and reproducing the content of the NOTICE file.
#
#    7. Disclaimer of Warranty. Unless required by applicable law or
#       agreed to in writing, Licensor provides the Work (and each
#       Contributor provides its Contributions) on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#       implied, including, without limitation, any warranties or conditions
#       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
#       PARTICULAR PURPOSE. You are solely responsible for determining the
#       appropriateness of using or redistributing the Work and assume any
#       risks associated with Your exercise of permissions under this License.
#
#    8. Limitation of Liability. In no event and under no legal theory,
#       whether in tort (including negligence), contract, or otherwise,
#       unless required by applicable law (such as deliberate and grossly
#       negligent acts) or agreed to in writing, shall any Contributor be
#       liable to You for damages, including any direct, indirect, special,
#       incidental, or consequential damages of any character arising as a
#       result of this License or out of the use or inability to use the
#       Work (including but not limited to damages for loss of goodwill,
#       work stoppage, computer failure or malfunction, or any and all
#       other commercial damages or losses), even if such Contributor
#       has been advised of the possibility of such damages.
#
#    9. Accepting Warranty or Additional Liability. While redistributing
#       the Work or Derivative Works thereof, You may choose to offer,
#       and charge a fee for, acceptance of support, warranty, indemnity,
#       or other liability obligations and/or rights consistent with this
#       License. However, in accepting such obligations, You may act only
#       on Your own behalf and on Your sole responsibility, not on behalf
#       of any other Contributor, and only if You agree to indemnify,
#       defend, and hold each Contributor harmless for any liability
#       incurred by, or claims asserted against, such Contributor by reason
#       of your accepting any such warranty or additional liability.
#
#    END OF TERMS AND CONDITIONS
#
#    APPENDIX: How to apply the Apache License to your work.
#
#       To apply the Apache License to your work, attach the following
#       boilerplate notice, with the fields enclosed by brackets "[]"
#       replaced with your own identifying information. (Don't include
#       the brackets!)  The text should be enclosed in the appropriate
#       comment syntax for the file format. We also recommend that a
#       file or class name and description of purpose be included on the
#       same "printed page" as the copyright notice for easier
#       identification within third-party archives.
#
#    Copyright 2024 Fair Isaac Corporation
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
"""
# XpressAPI - A module for low-level access to the Xpress C API

This package/module provides access to the Xpress C functions from Julia.
While (in theory) any C function can be directly accessed from Julia, this is
sometimes cumbersome and errorprone since for every call you have to know and
specify the exact prototype of the C function, have to jump through some hoops
for handling output arguments, have to perform error checking, etc.

The goal of this module is to simplify this as much as possible. As a
consequence, the module provides a Julia function/method wrapper for every
C function.

The goal of this module is *not* to provide a full-fledged Julia API or even
a modeling API. These things can be built on top of this module.

A minimal code example for using this module is here:
```
using XpressAPI

XPRScreateprob("") do prob
  XPRSaddcbmessage(prob, (p, m, l, t) -> if t > 0 println(l > 0 ? "" : m); end, 0)
  XPRSreadprob(prob, "afiro.mps", "")
  XPRSlpoptimize(prob, "")
  println(XPRSgetdblattrib(prob, XPRS_LPOBJVAL))
end

```

## Installation

XpressAPI does not provide Xpress binaries, a proper Xpress installion is needed to use this package.
Please visit https://community.fico.com/s/optimization for further details.
Ensure that the `XPRESSDIR` license variable is set to the install location by
checking the output of:
```julia
julia> ENV["XPRESSDIR"]
```

Then, install this package using:
```julia
import Pkg
Pkg.add("https://github.com/fico-xpress/XpressAPI.jl.git")
```

## License handling

Before any Xpress function can be used, a license must be acquired. There
are several ways to acquire a license. The most common way probably is to
acquire a license along with the creation of a problem:
```
XPRScreateprob("") do prob
  ...
end
```
If `XPRScreateprob` is passed a string, then it calls `XPRSinit` with that
string in order to acquire a license. That license is automatically released
when the problem is destroyed.

You can call `XPRScreateprob` with an argument of `nothing` to prevent the
function from calling `XPRSinit`.

A license can also be explicitly initialized by calling `XPRSinit`:
```
XPRSinit("") do lic
  ...
end
```
This is useful in case you need to create many problems (otherwise calling
`XPRSinit` for every problem may incur some overhead) or if you want to
explicitly control the lifetime of the license.

## Function mapping

As stated above, this module provides a Julia wrapper for (almost) every
function in the Xpress solver's C API.

Most of the parameters are mapped 1:1 between Julia and C. However, there are
a few exceptions:
- The integer error code returned by every library function is checked in the
  module and translated into an `XPRSexception` in case it is non-zero.
- Output parameters are translated into (multiple) return values.
- In case a function that operates on an `XPRSprob` has no output parameters,
  it returns the `XPRSprob` that was passed to it. This allows these functions
  to be chained/piped.

Note that functions `XPRSfree()`, `XPRSdestroyprob()` `XPRS_bo_destroy()`
have no wrappers. Instead there is a `close()` function for the respective
objects. That function is also setup as the object's finalizer, so usually you
should not need to bother with that `close()` function.

A number of functions fill an array and return that filled array. These
functions allow passing either an array to be filled or the special value
`XPRS_ALLOC`. In case `XPRS_ALLOC` is passed, the function will allocate the
array for you. For example, you can call `XPRSgetrhs` in two ways:
- With an explicitly allocated array:
```
rhs = Vector{Float64}(undef, 5)
rhs = XPRSgetrhs(prob, rhs, 0, 4)
```
- Have the function allocate the appropriate array for you:
```
rhs = XPRSgetrhs(prob, XPRS_ALLOC, 0, 4)
```

## Array indices

Entities in the Xpress API are numbered starting from 0. For example, columns
in a model are numbered from 0 to number of columns - 1.
On the other hand, Julia arrays start with an index of 1, don't be confused
by that.

## Callbacks

Callback functions can be any callable objects (top-level functions, local
functions, closures, ...).

Callbacks undergo the same argument translation as regular functions, i.e.,
output parameters become return values. Note that some callbacks have inout
parameters, so these will appear as parameter and will also be excepted as
return values.

If a callback raises an exception then the following happens:
- The exception is captured.
- The solution process is interrupted via `XPRSinterrupt(XPRS_STOP_GENERICERROR)`.
- Once the optimizing C function returns to Julia, the exception that was
  captured before is thrown (wrapped into a new `XPRSexception` instance).

## Error handling

Errors from calling the low-level C functions are translated into exceptions.
The exception that is thrown by the functions in this module is `XPRSexception`.
Note that not only library errors may trigger this exception. Another typical
situation in which this exception may be raised is when buffers are detected to
be not long enough.
"""

module XpressAPI

using Base.Libc.Libdl
using SparseArrays

"""Exception that is raised to indicate errors in this module."""
mutable struct XPRSexception <: Exception
  """Exception message."""
  message::String
  """The wrapped exception (may be undefined)."""
  wrapped::Union{Nothing,Exception}
end
Base.showerror(io::IO, e::XPRSexception = nothing) = print(io, e.message)

# TODO: Figure out how to create a subtype XPRScallbackException
#       that inherits from XPRSexception and then use that for callbacks

Functions = Dict{String, Ptr{Cvoid}}()
FunctionsLock = ReentrantLock()
Library = Ptr{Cvoid}(C_NULL)
LibraryRefs = Int64(0)

init = Ptr{Cvoid}(C_NULL)
free = Ptr{Cvoid}(C_NULL)
getlicerrmsg = Ptr{Cvoid}(C_NULL)
createprob = Ptr{Cvoid}(C_NULL)
destroyprob = Ptr{Cvoid}(C_NULL)
getlasterror = Ptr{Cvoid}(C_NULL)

"""
   loadLibrary()

Load the Xpress library and preload some function addresses that are frequently
used. If the library is already loaded then the library reference counter is
incremented.
"""
function initLibrary()
  global FunctionsLock
  global LibraryRefs
  global Library
  lock(FunctionsLock) do
    if LibraryRefs == 0
      libname = string(Sys.iswindows() ? "" : "lib", "xprs", ".", Libdl.dlext)
      liblocs = vcat([], Base.DL_LOAD_PATH)
      found_xprs = false
      Library = C_NULL

      # Check for directories where libxprs (and libxprl, ...) could be found
      if haskey(ENV, "XPRESSDIR")
        libdir = Sys.iswindows() ? "bin" : "lib"
        push!(liblocs, Base.joinpath(ENV["XPRESSDIR"], libdir, libname))
      end

      for libpath in liblocs
        # Base.Libdl adds '@loader_path' to 'DL_LOAD_PATH' on mac
        # https://gitlab.iag.uni-stuttgart.de/libs/julia/-/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/libdl.jl
        # So we need to check that we attempt to load against actual paths
        if Library == C_NULL && Base.isfile(libpath)
          Library = dlopen(libpath)
        end
      end

      if Library == C_NULL
        throw(XPRSexception("Failed to load Xpress library", nothing))
      end
      global init = getFunctionAddress("XPRSinit")
      global free = getFunctionAddress("XPRSfree")
      global getlicerrmsg = getFunctionAddress("XPRSgetlicerrmsg")
      global createprob = getFunctionAddress("XPRScreateprob")
      global destroyprob = getFunctionAddress("XPRSdestroyprob")
      global getlasterror = getFunctionAddress("XPRSgetlasterror")
      # Check that the library is not younger than the API
      getversionnumbers = getFunctionAddress("XPRSgetversionnumbers")
      p_major = Ref{Int32}(0)
      p_minor = Ref{Int32}(0)
      p_build = Ref{Int32}(0)
      ccall(getversionnumbers, Cint, (Ref{Cint},Ref{Cint},Ref{Cint}), p_major, p_minor, p_build)
      if p_major[] < XPVERSION_MAJOR || (p_major[] == XPVERSION_MAJOR && p_minor[] < XPVERSION_MINOR)
        throw(XPRSexception(string("Cannot use API ", XPVERSION_MAJOR, ".", XPVERSION_MINOR, ".", XPVERSION_BUILD, " with library ", p_major[], ".", p_minor[], ".", p_build[]), nothing))
      end
      # TODO: Close library if any of the above cannot be found
    end
    LibraryRefs += 1
  end
end

"""
    closeLibrary()

Decrement the library reference counter and unload the Xpress library if the
counter became 0.
"""
function closeLibrary()
  global FunctionsLock
  global LibraryRefs
  global Library
  global Functions
  lock(FunctionsLock) do
    LibraryRefs -= 1
    if LibraryRefs == 0
      dlclose(Library)
      Library = C_NULL
      empty!(Functions)
    end
  end
end

"""
    withLibrary()

Run something with the library initialized and closed properly
"""
function withLibrary(f)
  initLibrary()
  try
    f()
  finally
    closeLibrary()
  end
end

"""
    getFunctionAddress(name)

Get the address of the specified function in the Xpress library.
"""
function getFunctionAddress(name::String)::Ptr{Cvoid}
  global Functions
  global FunctionsLock
  global Library
  addr = Ptr{Cvoid}(C_NULL)
  lock(FunctionsLock) do
    addr = get(Functions, name, C_NULL)
    if addr == C_NULL
      addr = dlsym(Library, name)
      if addr == C_NULL
        throw(XPRSexception("Symbol " * name * " not found", nothing))
      end
      Functions[name] = addr
    end
  end
  addr
end

mutable struct XPRSlic
  up::Bool
  function XPRSlic(path::AbstractString)
    initLibrary()
    dropLibrary = true
    try
      global init
      retcode = ccall(init, Cint, (Cstring,), path)
      if retcode != 0
        throw(XPRSexception(XPRSgetlicerrmsg(), nothing))
      end
      self = new(true)
      finalizer(close, self)
      dropLibrary = false
      self
    finally
      if dropLibrary
        closeLibrary()
      end
    end
  end
end
export XPRSlic

function close(l::XPRSlic)
  global free
  up = l.up
  l.up = false
  if up
    ccall(free, Cint, ())
    closeLibrary()
  end
end

"""
    XPRSinit(f, path)

Initialize Xpress, call function `f`, free Xpress.
Xpress is freed no matter whether `f` fails, raises an exception ...

`f`
: The function to execute.

`path`
: Path to license, can be the empty string to look in default places.
"""
function XPRSinit(f::Function, path::AbstractString)
  lic = XPRSlic(path)
  try
    f(lic)
  finally
    close(lic)
  end
end

function index1to0(x)
  x - 1
end

"""
    XPRSinit(path)

Initialize Xpress.

`path`
: Path to license, can be the empty string to look in default places.

Returns an `XPRSlic` object the lifetime of which controls how long the
license is held.
"""
function XPRSinit(path::AbstractString)::XPRSlic
  XPRSlic(path)
end
export XPRSinit

mutable struct CallbackNode
  prev::Union{CallbackNode,Nothing}
  next::Union{CallbackNode,Nothing}
  callback::Int32
  closure::Any
  prob::Any
  nin::Int32   # for user functions
  nout::Int32  # for user functions
  function CallbackNode()
    new(nothing, nothing, Int32(-1), nothing, nothing, Int32(0), Int32(0))
  end
end

mutable struct XPRSprob
  license::Union{Nothing,XPRSlic}
  """Low level problem handle."""
  handle::Ptr{Cvoid}
  callbacksHead::CallbackNode
  callbacksTail::CallbackNode
  callbacksLock::ReentrantLock
  multistartsHead::CallbackNode
  multistartsTail::CallbackNode
  """Whether this instances represents a callback-problem or a top-level problem."""
  isCallback::Bool
  cbException::Union{Nothing,Exception}
  function XPRSprob(lic::Union{Nothing,XPRSlic}, handle::Ptr{Cvoid}, isCallback::Bool)
    self = new(lic, handle, CallbackNode(),
               CallbackNode(),
               ReentrantLock(),
               CallbackNode(),
               CallbackNode(),
               isCallback, nothing)
    self.callbacksHead.next = self.callbacksTail
    self.callbacksTail.prev = self.callbacksHead
    self.multistartsHead.next = self.multistartsTail
    self.multistartsTail.prev = self.multistartsHead
    finalizer(close, self)
  end
end
export XPRSprob

# Set the callback exception in prob.
# If there already is a callback exception, that is not overwritten.
function setCallbackException(prob::XPRSprob, ex::Exception)
  lock(prob.callbacksLock) do
    if isnothing(prob.cbException)
      prob.cbException = ex
    end
  end
end

# Check whether prob has any callback exception stored.
# If so then clear that exception and throw it, otherwise do nothing.
function consumeCallbackException(prob::XPRSprob)
  lock(prob.callbacksLock) do
    ex = prob.cbException
    prob.cbException = nothing
    if ex != nothing
      throw(XPRSexception("exception in callback", ex))
    end
  end
end

function XPRSprob(path::Union{Nothing,AbstractString})
  global createprob
  global destroyprob
  lic = nothing
  handle = Ptr{Cvoid}(C_NULL)
  try
    if path != nothing
      lic = XPRSlic(path)
    else
      lic = nothing
    end
    handle_ref = Ref{Ptr{Cvoid}}(0)
    retcode = ccall(createprob, Cint, (Ref{Ptr{Cvoid}},), handle_ref)
    if retcode != 0
      # We could call XPRS_ge_getlasterror() but that would not be thread-safe.
      # So instead we provide a generic message that includes the error code.
      throw(XPRSexception("failed to create XPRSprob: " * retcode, nothing))
    end
    handle = handle_ref[]

    # Note: We cannot use the user_callback_removed callback to get notified
    #       when a callback is removed and release the per-callback data in
    #       that callback. This is because this callback may be invoked from
    #       an arbitrary thread Julia does not react well to that.

	# It is not safe to call back into Julia from a non-Julia thread,
	# see https://groups.google.com/g/julia-dev/c/yxvIZn5KIGY
	# This is because
	# <quote>
	#   The Julia library, and especially the memory allocation and garbage
	#   collection, is not currently thread-safe
	#   (see https://github.com/JuliaLang/julia/issues/1790 and
	#   https://github.com/JuliaLang/julia/pull/1002).
	#   That means it is not in general possible to call back to the Julia
	#   runtime from a different thread.
	# </quote>
	setint = getFunctionAddress("XPRSsetintcontrol")
	retcode = ccall(setint, Cint, (Ptr{Cvoid}, Cint, Cint), handle, XPRS_CALLBACKFROMMASTERTHREAD, 1)
	if retcode != 0
      throw(XPRSexception("failed to set XPRS_CALLBACKFROMMASTERTHREAD: " * retcode, nothing))
    end

    self = XPRSprob(lic, handle, false)
    self.callbacksHead.next = self.callbacksTail
    self.callbacksTail.prev = self.callbacksHead
    finalizer(close, self)
    lic = nothing
    handle = C_NULL
    self
  finally
    if handle != C_NULL
      ccall(destroyprob, Cint, (Ptr{Cvoid},), handle)
    end
    if lic != nothing
      close(lic)
    end
  end
end
export XPRSprob

# Allocate a problem for use in a callback.
# This creates a wrapper around the prob handle that is passed into the callback
function callbackProb(f::Function, handle::Ptr{Cvoid})
  prob = XPRSprob(nothing, handle, true)
  try
    f(prob)
  finally
    close(prob)
  end
end

function close(prob::XPRSprob)
  global destroyprob
  handle = prob.handle
  prob.handle = C_NULL
  if handle != C_NULL && !prob.isCallback
    ccall(destroyprob, Cint, (Ptr{Cvoid},), handle)
  end
  if prob.license != nothing
    close(prob.license)
  end
end

function linkCallback(prob::XPRSprob, jcbnode::CallbackNode)
  lock(prob.callbacksLock) do
    jcbnode.next = prob.callbacksTail
    jcbnode.prev = prob.callbacksTail.prev
    jcbnode.next.prev = jcbnode
    jcbnode.prev.next = jcbnode
    jcbnode.prob = prob
  end
end

function unlinkCallback(prob::XPRSprob, which::Int32)
  lock(prob.callbacksLock) do
    jcbnode = prob.callbacksHead.next
    while jcbnode != prob.callbacksTail
      next = jcbnode.next
      if jcbnode.callback == which
        unlinkCallback(jcbnode)
      end
      jcbnode = next
    end
  end
end

function linkMultistart(prob::XPRSprob, jcbnode::CallbackNode)
  lock(prob.callbacksLock) do
    jcbnode.next = prob.multistartsTail
    jcbnode.prev = prob.multistartsTail.prev
    jcbnode.next.prev = jcbnode
    jcbnode.prev.next = jcbnode
    jcbnode.prob = prob
  end
end

function unlinkCallback(jcbnode::CallbackNode)
  lock(jcbnode.prob.callbacksLock) do
    jcbnode.prev.next = jcbnode.next
    jcbnode.next.prev = jcbnode.prev
  end
  jcbnode.callback = Int32(-1)
  jcbnode.closure = nothing
  jcbnode.prev = nothing
  jcbnode.next = nothing
  jcbnode.prob = nothing
end

mutable struct XPRSbranchobject
  handle::Ptr{Cvoid}
  delOnClose::Bool
  function XPRSbranchobject(handle::Ptr{Cvoid}, delOnClose::Bool)
    self = new(handle, delOnClose)
    finalizer(close, self)
    self
  end
end
export XPRSbranchobject

function close(bo::XPRSbranchobject)
  handle = bo.handle
  bo.handle = C_NULL
  if bo.delOnClose && handle != C_NULL
    ccall(getFunctionAddress("XPRS_bo_destroy"), Cint, (Ptr{Cvoid},), handle)
  end
end

function XPRS_bo_create(prob::XPRSprob, isoriginal::Bool)::XPRSbranchobject
  handle_ref = Ref{Ptr{Cvoid}}(0)
  retcode = ccall(getFunctionAddress("XPRS_bo_create"), Cint, (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint), handle_ref, prob.handle, Int32(isoriginal ? 1 : 0))
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  bo = nothing
  try
    bo = XPRSbranchobject(handle_ref[], true)
  catch e
    ccall(getFunctionAddress("XPRS_bo_destroy"), Cint, (Ptr{Cvoid},), handle_ref[])
    rethrow(e)
  end
  bo
end
export XPRS_bo_create


function XPRSgetlicerrmsg()::String
  global getlicerrmsg
  message = Vector{Cchar}(undef, 1024)
  retcode = ccall(getlicerrmsg, Cint, (Ptr{Cchar}, Cint), message, Cint(1024))
  if retcode != 0
    return "unknown licensing error"
  else
    message[end] = 0
    return unsafe_string(pointer(message))
  end
end
export XPRSgetlicerrmsg

function XPRSgetlasterror(prob::XPRSprob)::String
  global getlasterror
  message = Vector{Cchar}(undef, 256)
  retcode = ccall(getlasterror, Cint, (Ptr{Cvoid}, Ptr{Cchar}), prob.handle, message)
  if retcode != 0
    return "unknown error"
  else
    message[end] = 0
    return unsafe_string(pointer(message))
  end
end
export XPRSgetlasterror

"""
    XPRScreateprob(f, path)

Create an `XPRSprob` instance, execute `f`, and release the `XPRSprob` instance.
The instance is released even if `f` exits with an error.

`f`
: The function to execute

`path`
: If this is not `nothing` then the function initializes Xpress (see `XPRSinit`)
  with that path before creating the `XPRSprob` instance. When the `XPRSprob`
  instance is destroyed, Xpress will be freed.
"""
function XPRScreateprob(f::Function, path::Union{Nothing,AbstractString})
  prob = XPRSprob(path)
  try
    f(prob)
  finally
    close(prob)
  end
end

"""
    XPRScreateprob(f, path)

Create an `XPRSprob` instance.

`path`
: If this is not `nothing` then the function initializes Xpress (see `XPRSinit`)
  with that path before creating the `XPRSprob` instance. When the `XPRSprob`
  instance is destroyed, Xpress will be freed.
"""
function XPRScreateprob(path::Union{Nothing,AbstractString})
  XPRSprob(path)
end
export XPRScreateprob

struct XPRSallocatable
end

global const XPRS_ALLOC = XPRSallocatable()
export XPRS_ALLOC

function cbufmap(x::Cdouble, data::Ptr{Cvoid})::Cdouble
  result = NaN
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    result = jcbnode.closure(x)
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  result
end

function cbufvecmap(x::Ptr{Cdouble}, data::Ptr{Cvoid})::Cdouble
  result = NaN
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    jx = unsafe_wrap(Array, x, jcbnode.nin; own = false)
    result = jcbnode.closure(jx)
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  result
end

function cbufmultimap(x::Ptr{Cdouble}, out::Ptr{Cdouble}, data::Ptr{Cvoid})::Cint
  ret = -1
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    jx = unsafe_wrap(Array, x, jcbnode.nin; own = false)
    jout = unsafe_wrap(Array, out, jcbnode.nout; own = false)
    ret = jcbnode.closure(jx, jout)
    if ret != 0
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

function cbufmapdelta(x::Cdouble, delta::Cdouble, evaluation::Ptr{Cdouble}, partial::Ptr{Cdouble}, data::Ptr{Cvoid})::Cint
  ret = -1
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    ret, evaluation_out, partial_out = jcbnode.closure(x, delta)
    if ret != 0
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    else
      unsafe_store!(evaluation, evaluation_out)
      if partial != C_NULL
        unsafe_store!(partial, partial_out)
      end
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

function cbufvecmapdelta(x::Ptr{Cdouble}, delta::Ptr{Cdouble}, evaluation::Ptr{Cdouble}, partial::Ptr{Cdouble}, data::Ptr{Cvoid})::Cint
  ret = -1
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    jx = unsafe_wrap(Array, x, jcbnode.nin; own = false)
    jdelta = delta != C_NULL ? unsafe_wrap(Array, delta, jcbnode.nin; own=false) : nothing
    jpartial = partial != C_NULL ? unsafe_wrap(Array, partial, jcbnode.nin; own=False) : nothing
    ret, evaluation_out = jcbnode.closure(jx, jdelta, jpartial)
    if ret != 0
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    else
      unsafe_store!(evaluation, evaluation_out)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

function cbufmultimapdelta(x::Ptr{Cdouble}, delta::Ptr{Cdouble}, out::Ptr{Cdouble}, data::Ptr{Cvoid})::Cint
  ret = -1
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    jx = unsafe_wrap(Array, x, jcbnode.nin; own = false)
    jdelta = delta != C_NULL ? unsafe_wrap(Array, delta, jcbnode.nin; own=false) : nothing
    jout = out != C_NULL ? unsafe_wrap(Array, out, jcbnode.nin * jcbnode.nout; own=False) : nothing
    ret = jcbnode.closure(jx, jdelta, jout)
    if ret != 0
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSnlpsetfunctionerror(jcbnode.prob)
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end


""" `XPVERSION_MAJOR` - Major version number of Xpress optimizer library."""
global const XPVERSION_MAJOR = Int32(44)
export XPVERSION_MAJOR
""" `XPVERSION_MINOR` - Minor version number of Xpress optimizer library."""
global const XPVERSION_MINOR = Int32(1)
export XPVERSION_MINOR
""" `XPVERSION_BUILD` - Build version number of Xpress optimizer library."""
global const XPVERSION_BUILD = Int32(99)
export XPVERSION_BUILD
""" `XPVERSION_FULL` - Full version number of Xpress optimizer library."""
global const XPVERSION_FULL = Int32(440199)
export XPVERSION_FULL
global const XPRS_DEL_COLON = Int32(2)
export XPRS_DEL_COLON

global const XPRS_DEL_COMMA = Int32(1)
export XPRS_DEL_COMMA

global const XPRS_IFUN_ABS = Int32(17)
export XPRS_IFUN_ABS

global const XPRS_IFUN_ARCCOS = Int32(31)
export XPRS_IFUN_ARCCOS

global const XPRS_IFUN_ARCSIN = Int32(30)
export XPRS_IFUN_ARCSIN

global const XPRS_IFUN_ARCTAN = Int32(32)
export XPRS_IFUN_ARCTAN

global const XPRS_IFUN_COS = Int32(28)
export XPRS_IFUN_COS

global const XPRS_IFUN_ERF = Int32(49)
export XPRS_IFUN_ERF

global const XPRS_IFUN_ERFC = Int32(50)
export XPRS_IFUN_ERFC

global const XPRS_IFUN_EXP = Int32(16)
export XPRS_IFUN_EXP

global const XPRS_IFUN_LN = Int32(15)
export XPRS_IFUN_LN

global const XPRS_IFUN_LOG = Int32(14)
export XPRS_IFUN_LOG

global const XPRS_IFUN_LOG10 = Int32(14)
export XPRS_IFUN_LOG10

global const XPRS_IFUN_MAX = Int32(34)
export XPRS_IFUN_MAX

global const XPRS_IFUN_MIN = Int32(33)
export XPRS_IFUN_MIN

global const XPRS_IFUN_PWL = Int32(35)
export XPRS_IFUN_PWL

global const XPRS_IFUN_SIGN = Int32(46)
export XPRS_IFUN_SIGN

global const XPRS_IFUN_SIN = Int32(27)
export XPRS_IFUN_SIN

global const XPRS_IFUN_SQRT = Int32(18)
export XPRS_IFUN_SQRT

global const XPRS_IFUN_TAN = Int32(29)
export XPRS_IFUN_TAN

global const XPRS_KKT_CALCULATION_ACTIVITY_BASED = Int32(0)
export XPRS_KKT_CALCULATION_ACTIVITY_BASED

global const XPRS_KKT_CALCULATION_ACTIVITY_BOTH = Int32(2)
export XPRS_KKT_CALCULATION_ACTIVITY_BOTH

global const XPRS_KKT_CALCULATION_MEASURE_BOTH = Int32(2)
export XPRS_KKT_CALCULATION_MEASURE_BOTH

global const XPRS_KKT_CALCULATION_MINIMZE_KKT_ERROR = Int32(1)
export XPRS_KKT_CALCULATION_MINIMZE_KKT_ERROR

global const XPRS_KKT_CALCULATION_RECALCULATE_RDJ = Int32(0)
export XPRS_KKT_CALCULATION_RECALCULATE_RDJ

global const XPRS_KKT_CALCULATION_RESPECT_BASIS = Int32(1)
export XPRS_KKT_CALCULATION_RESPECT_BASIS

global const XPRS_KKT_JUST_CALCULATE = Int32(0)
export XPRS_KKT_JUST_CALCULATE

global const XPRS_KKT_UPDATE_MULTIPLIERS = Int32(1)
export XPRS_KKT_UPDATE_MULTIPLIERS

global const XPRS_LOCALSOLVER_AUTO = Int32(-1)
export XPRS_LOCALSOLVER_AUTO

global const XPRS_LOCALSOLVER_KNITRO = Int32(1)
export XPRS_LOCALSOLVER_KNITRO

global const XPRS_LOCALSOLVER_OPTIMIZER = Int32(2)
export XPRS_LOCALSOLVER_OPTIMIZER

global const XPRS_LOCALSOLVER_XSLP = Int32(0)
export XPRS_LOCALSOLVER_XSLP

global const XPRS_MSSET_INITIALFILTERED = Int32(6)
export XPRS_MSSET_INITIALFILTERED

global const XPRS_MSSET_INITIALVALUES = Int32(0)
export XPRS_MSSET_INITIALVALUES

global const XPRS_MSSET_KNITRO_BASIC = Int32(4)
export XPRS_MSSET_KNITRO_BASIC

global const XPRS_MSSET_KNITRO_EXTENDED = Int32(5)
export XPRS_MSSET_KNITRO_EXTENDED

global const XPRS_MSSET_SLP_BASIC = Int32(2)
export XPRS_MSSET_SLP_BASIC

global const XPRS_MSSET_SLP_EXTENDED = Int32(3)
export XPRS_MSSET_SLP_EXTENDED

global const XPRS_MSSET_SOLVERS = Int32(1)
export XPRS_MSSET_SOLVERS

global const XPRS_NLP1DERIVATIVE = Int32(128)
export XPRS_NLP1DERIVATIVE

global const XPRS_NLP2DERIVATIVE = Int32(64)
export XPRS_NLP2DERIVATIVE

global const XPRS_NLPALLCALCS = Int32(32)
export XPRS_NLPALLCALCS

global const XPRS_NLPALLDERIVATIVES = Int32(256)
export XPRS_NLPALLDERIVATIVES

global const XPRS_NLPFORMULACOEFFCOLUMNINDEX = Int32(-1000)
export XPRS_NLPFORMULACOEFFCOLUMNINDEX

global const XPRS_NLPINSTANCEFUNCTION = Int32(512)
export XPRS_NLPINSTANCEFUNCTION

global const XPRS_NLPINTERNALFUNCNAMES = Int32(8)
export XPRS_NLPINTERNALFUNCNAMES

global const XPRS_NLPINTERNALFUNCNAMESNOCASE = Int32(10)
export XPRS_NLPINTERNALFUNCNAMESNOCASE

global const XPRS_NLPPRESOLVEDOMAIN = Int32(32)
export XPRS_NLPPRESOLVEDOMAIN

global const XPRS_NLPPRESOLVEFIXALL = Int32(4)
export XPRS_NLPPRESOLVEFIXALL

global const XPRS_NLPPRESOLVEFIXZERO = Int32(2)
export XPRS_NLPPRESOLVEFIXZERO

global const XPRS_NLPPRESOLVEINTBOUNDS = Int32(16)
export XPRS_NLPPRESOLVEINTBOUNDS

global const XPRS_NLPPRESOLVELEVEL_BASIC = Int32(2)
export XPRS_NLPPRESOLVELEVEL_BASIC

global const XPRS_NLPPRESOLVELEVEL_FULL = Int32(4)
export XPRS_NLPPRESOLVELEVEL_FULL

global const XPRS_NLPPRESOLVELEVEL_LINEAR = Int32(3)
export XPRS_NLPPRESOLVELEVEL_LINEAR

global const XPRS_NLPPRESOLVELEVEL_LOCALIZED = Int32(1)
export XPRS_NLPPRESOLVELEVEL_LOCALIZED

global const XPRS_NLPPRESOLVEOPS_ELIMINATIONS = Int32(2048)
export XPRS_NLPPRESOLVEOPS_ELIMINATIONS

global const XPRS_NLPPRESOLVEOPS_GENERAL = Int32(1)
export XPRS_NLPPRESOLVEOPS_GENERAL

global const XPRS_NLPPRESOLVEOPS_NOLINEAR = Int32(4096)
export XPRS_NLPPRESOLVEOPS_NOLINEAR

global const XPRS_NLPPRESOLVEOPS_NOSIMPLIFIER = Int32(8192)
export XPRS_NLPPRESOLVEOPS_NOSIMPLIFIER

global const XPRS_NLPPRESOLVEOPS_NO_DUAL_SIDE = Int32(1024)
export XPRS_NLPPRESOLVEOPS_NO_DUAL_SIDE

global const XPRS_NLPPRESOLVEPROTECT = Int32(32768)
export XPRS_NLPPRESOLVEPROTECT

global const XPRS_NLPPRESOLVESETBOUNDS = Int32(8)
export XPRS_NLPPRESOLVESETBOUNDS

global const XPRS_NLPRECALC = Int32(8)
export XPRS_NLPRECALC

global const XPRS_NLPREFORMULATE_ABS = Int32(128)
export XPRS_NLPREFORMULATE_ABS

global const XPRS_NLPREFORMULATE_ALLABS = Int32(512)
export XPRS_NLPREFORMULATE_ALLABS

global const XPRS_NLPREFORMULATE_ALLMINMAX = Int32(1024)
export XPRS_NLPREFORMULATE_ALLMINMAX

global const XPRS_NLPREFORMULATE_MINMAX = Int32(256)
export XPRS_NLPREFORMULATE_MINMAX

global const XPRS_NLPREFORMULATE_PWL = Int32(64)
export XPRS_NLPREFORMULATE_PWL

global const XPRS_NLPREFORMULATE_QCQP2SLP = Int32(8)
export XPRS_NLPREFORMULATE_QCQP2SLP

global const XPRS_NLPREFORMULATE_QP2SLP = Int32(2)
export XPRS_NLPREFORMULATE_QP2SLP

global const XPRS_NLPREFORMULATE_QPSOLVE = Int32(32)
export XPRS_NLPREFORMULATE_QPSOLVE

global const XPRS_NLPREFORMULATE_SLP2QCQP = Int32(4)
export XPRS_NLPREFORMULATE_SLP2QCQP

global const XPRS_NLPREFORMULATE_SLP2QP = Int32(1)
export XPRS_NLPREFORMULATE_SLP2QP

global const XPRS_NLPREFORMULATE_SOCP2SLP = Int32(16)
export XPRS_NLPREFORMULATE_SOCP2SLP

global const XPRS_NLPSOLSTATUS_GLOBALLYOPTIMAL_NODUALS = Int32(3)
export XPRS_NLPSOLSTATUS_GLOBALLYOPTIMAL_NODUALS

global const XPRS_NLPSOLSTATUS_GLOBALLYOPTIMAL_WITHDUALS = Int32(4)
export XPRS_NLPSOLSTATUS_GLOBALLYOPTIMAL_WITHDUALS

global const XPRS_NLPSOLSTATUS_LOCALLYOPTIMAL_WITHDUALS = Int32(2)
export XPRS_NLPSOLSTATUS_LOCALLYOPTIMAL_WITHDUALS

global const XPRS_NLPSOLSTATUS_NONE = Int32(0)
export XPRS_NLPSOLSTATUS_NONE

global const XPRS_NLPSOLSTATUS_SOLUTION_NODUALS = Int32(1)
export XPRS_NLPSOLSTATUS_SOLUTION_NODUALS

global const XPRS_NLPSOLVER_AUTOMATIC = Int32(-1)
export XPRS_NLPSOLVER_AUTOMATIC

global const XPRS_NLPSOLVER_GLOBAL = Int32(2)
export XPRS_NLPSOLVER_GLOBAL

global const XPRS_NLPSOLVER_LOCAL = Int32(1)
export XPRS_NLPSOLVER_LOCAL

global const XPRS_NLPSTATUS_INFEASIBLE = Int32(4)
export XPRS_NLPSTATUS_INFEASIBLE

global const XPRS_NLPSTATUS_LOCALLY_INFEASIBLE = Int32(3)
export XPRS_NLPSTATUS_LOCALLY_INFEASIBLE

global const XPRS_NLPSTATUS_LOCALLY_OPTIMAL = Int32(1)
export XPRS_NLPSTATUS_LOCALLY_OPTIMAL

global const XPRS_NLPSTATUS_NOSOLUTION = Int32(3)
export XPRS_NLPSTATUS_NOSOLUTION

global const XPRS_NLPSTATUS_OPTIMAL = Int32(2)
export XPRS_NLPSTATUS_OPTIMAL

global const XPRS_NLPSTATUS_SOLUTION = Int32(1)
export XPRS_NLPSTATUS_SOLUTION

global const XPRS_NLPSTATUS_UNBOUNDED = Int32(5)
export XPRS_NLPSTATUS_UNBOUNDED

global const XPRS_NLPSTATUS_UNFINISHED = Int32(6)
export XPRS_NLPSTATUS_UNFINISHED

global const XPRS_NLPSTATUS_UNSOLVED = Int32(7)
export XPRS_NLPSTATUS_UNSOLVED

global const XPRS_NLPSTATUS_UNSTARTED = Int32(0)
export XPRS_NLPSTATUS_UNSTARTED

global const XPRS_NLPTOLCALC = Int32(16)
export XPRS_NLPTOLCALC

global const XPRS_NLPUSERFUNCNAMES = Int32(7)
export XPRS_NLPUSERFUNCNAMES

global const XPRS_NLPUSERFUNCNAMESNOCASE = Int32(9)
export XPRS_NLPUSERFUNCNAMESNOCASE

global const XPRS_OP_DIVIDE = Int32(4)
export XPRS_OP_DIVIDE

global const XPRS_OP_EXPONENT = Int32(2)
export XPRS_OP_EXPONENT

global const XPRS_OP_MINUS = Int32(6)
export XPRS_OP_MINUS

global const XPRS_OP_MULTIPLY = Int32(3)
export XPRS_OP_MULTIPLY

global const XPRS_OP_PLUS = Int32(5)
export XPRS_OP_PLUS

global const XPRS_OP_UMINUS = Int32(1)
export XPRS_OP_UMINUS

global const XPRS_SLPACTIVEPENALTY = Int32(32768)
export XPRS_SLPACTIVEPENALTY

global const XPRS_SLPACTIVESBROW = Int32(262144)
export XPRS_SLPACTIVESBROW

global const XPRS_SLPACTIVESTEPBOUND = Int32(131072)
export XPRS_SLPACTIVESTEPBOUND

global const XPRS_SLPALLERRORVECTORS = Int32(8)
export XPRS_SLPALLERRORVECTORS

global const XPRS_SLPALLROWERRORVECTORS = Int32(512)
export XPRS_SLPALLROWERRORVECTORS

global const XPRS_SLPAMEANWEIGHT = Int32(32)
export XPRS_SLPAMEANWEIGHT

global const XPRS_SLPANALYZE_AUTOSAVEPOOL = Int32(32)
export XPRS_SLPANALYZE_AUTOSAVEPOOL

global const XPRS_SLPANALYZE_EXTENDEDFINALSUMMARY = Int32(8)
export XPRS_SLPANALYZE_EXTENDEDFINALSUMMARY

global const XPRS_SLPANALYZE_INFEASIBLE_ITERATION = Int32(16)
export XPRS_SLPANALYZE_INFEASIBLE_ITERATION

global const XPRS_SLPANALYZE_RECORDCASCADE = Int32(2)
export XPRS_SLPANALYZE_RECORDCASCADE

global const XPRS_SLPANALYZE_RECORDLINEARIZATION = Int32(1)
export XPRS_SLPANALYZE_RECORDLINEARIZATION

global const XPRS_SLPANALYZE_RECORDLINESEARCH = Int32(4)
export XPRS_SLPANALYZE_RECORDLINESEARCH

global const XPRS_SLPANALYZE_SAVEFILE = Int32(256)
export XPRS_SLPANALYZE_SAVEFILE

global const XPRS_SLPANALYZE_SAVEITERBASIS = Int32(128)
export XPRS_SLPANALYZE_SAVEITERBASIS

global const XPRS_SLPANALYZE_SAVELINEARIZATIONS = Int32(64)
export XPRS_SLPANALYZE_SAVELINEARIZATIONS

global const XPRS_SLPBOUNDSSET = Int32(67108864)
export XPRS_SLPBOUNDSSET

global const XPRS_SLPCASCADECONTRACTION = Int32(536870912)
export XPRS_SLPCASCADECONTRACTION

global const XPRS_SLPCASCADEDBOUNDS = Int32(16384)
export XPRS_SLPCASCADEDBOUNDS

global const XPRS_SLPCASCADE_ALL = Int32(1)
export XPRS_SLPCASCADE_ALL

global const XPRS_SLPCASCADE_ALL_COEF_VAR = Int32(4)
export XPRS_SLPCASCADE_ALL_COEF_VAR

global const XPRS_SLPCASCADE_ALL_STRUCT_VAR = Int32(16)
export XPRS_SLPCASCADE_ALL_STRUCT_VAR

global const XPRS_SLPCASCADE_AUTOAPPLY = Int32(256)
export XPRS_SLPCASCADE_AUTOAPPLY

global const XPRS_SLPCASCADE_COEF_VAR = Int32(2)
export XPRS_SLPCASCADE_COEF_VAR

global const XPRS_SLPCASCADE_DRCOL_PREVOUSVALUE = Int32(64)
export XPRS_SLPCASCADE_DRCOL_PREVOUSVALUE

global const XPRS_SLPCASCADE_DRCOL_PVRANGE = Int32(128)
export XPRS_SLPCASCADE_DRCOL_PVRANGE

global const XPRS_SLPCASCADE_SECONDARY_GROUPS = Int32(32)
export XPRS_SLPCASCADE_SECONDARY_GROUPS

global const XPRS_SLPCASCADE_STRUCT_VAR = Int32(8)
export XPRS_SLPCASCADE_STRUCT_VAR

global const XPRS_SLPCLAMPEXTENDEDACTIVESB = Int32(32768)
export XPRS_SLPCLAMPEXTENDEDACTIVESB

global const XPRS_SLPCLAMPEXTENDEDALL = Int32(65536)
export XPRS_SLPCLAMPEXTENDEDALL

global const XPRS_SLPCOLINFO_DELTA = Int32(4)
export XPRS_SLPCOLINFO_DELTA

global const XPRS_SLPCOLINFO_DELTADJ = Int32(5)
export XPRS_SLPCOLINFO_DELTADJ

global const XPRS_SLPCOLINFO_DELTAINDEX = Int32(3)
export XPRS_SLPCOLINFO_DELTAINDEX

global const XPRS_SLPCOLINFO_LPVALUE = Int32(9)
export XPRS_SLPCOLINFO_LPVALUE

global const XPRS_SLPCOLINFO_RDJ = Int32(2)
export XPRS_SLPCOLINFO_RDJ

global const XPRS_SLPCOLINFO_SB = Int32(7)
export XPRS_SLPCOLINFO_SB

global const XPRS_SLPCOLINFO_SBDUAL = Int32(8)
export XPRS_SLPCOLINFO_SBDUAL

global const XPRS_SLPCOLINFO_UPDATEROW = Int32(6)
export XPRS_SLPCOLINFO_UPDATEROW

global const XPRS_SLPCOLINFO_VALUE = Int32(1)
export XPRS_SLPCOLINFO_VALUE

global const XPRS_SLPCONVERGEBIT_ATOL = Int32(2)
export XPRS_SLPCONVERGEBIT_ATOL

global const XPRS_SLPCONVERGEBIT_CTOL = Int32(1)
export XPRS_SLPCONVERGEBIT_CTOL

global const XPRS_SLPCONVERGEBIT_EXTENDEDSCALING = Int32(1024)
export XPRS_SLPCONVERGEBIT_EXTENDEDSCALING

global const XPRS_SLPCONVERGEBIT_ITOL = Int32(8)
export XPRS_SLPCONVERGEBIT_ITOL

global const XPRS_SLPCONVERGEBIT_MTOL = Int32(4)
export XPRS_SLPCONVERGEBIT_MTOL

global const XPRS_SLPCONVERGEBIT_NOQUADCHECK = Int32(8192)
export XPRS_SLPCONVERGEBIT_NOQUADCHECK

global const XPRS_SLPCONVERGEBIT_OTOL = Int32(256)
export XPRS_SLPCONVERGEBIT_OTOL

global const XPRS_SLPCONVERGEBIT_STOL = Int32(16)
export XPRS_SLPCONVERGEBIT_STOL

global const XPRS_SLPCONVERGEBIT_USER = Int32(32)
export XPRS_SLPCONVERGEBIT_USER

global const XPRS_SLPCONVERGEBIT_VALIDATION = Int32(2048)
export XPRS_SLPCONVERGEBIT_VALIDATION

global const XPRS_SLPCONVERGEBIT_VALIDATION_K = Int32(4096)
export XPRS_SLPCONVERGEBIT_VALIDATION_K

global const XPRS_SLPCONVERGEBIT_VTOL = Int32(64)
export XPRS_SLPCONVERGEBIT_VTOL

global const XPRS_SLPCONVERGEBIT_WTOL = Int32(512)
export XPRS_SLPCONVERGEBIT_WTOL

global const XPRS_SLPCONVERGEBIT_XTOL = Int32(128)
export XPRS_SLPCONVERGEBIT_XTOL

global const XPRS_SLPDELTA_CONT = Int32(0)
export XPRS_SLPDELTA_CONT

global const XPRS_SLPDELTA_EXPLORE = Int32(3)
export XPRS_SLPDELTA_EXPLORE

global const XPRS_SLPDELTA_INTEGER = Int32(2)
export XPRS_SLPDELTA_INTEGER

global const XPRS_SLPDELTA_SEMICONT = Int32(1)
export XPRS_SLPDELTA_SEMICONT

global const XPRS_SLPDYNAMICDAMPING = Int32(8)
export XPRS_SLPDYNAMICDAMPING

global const XPRS_SLPEQUALITYERRORVECTORS = Int32(4)
export XPRS_SLPEQUALITYERRORVECTORS

global const XPRS_SLPESCALATEPENALTIES = Int32(256)
export XPRS_SLPESCALATEPENALTIES

global const XPRS_SLPESTIMATESTEPBOUNDS = Int32(4)
export XPRS_SLPESTIMATESTEPBOUNDS

global const XPRS_SLPEVENHANDEDAUGMENTATION = Int32(2)
export XPRS_SLPEVENHANDEDAUGMENTATION

global const XPRS_SLPFILTER_CASCADE = Int32(2)
export XPRS_SLPFILTER_CASCADE

global const XPRS_SLPFILTER_KEEPBEST = Int32(1)
export XPRS_SLPFILTER_KEEPBEST

global const XPRS_SLPFILTER_ZEROLINESEARCH = Int32(4)
export XPRS_SLPFILTER_ZEROLINESEARCH

global const XPRS_SLPFILTER_ZEROLINESEARCHTR = Int32(8)
export XPRS_SLPFILTER_ZEROLINESEARCHTR

global const XPRS_SLPFIXEDVAR = Int32(33554432)
export XPRS_SLPFIXEDVAR

global const XPRS_SLPGRIDANNEALING = Int32(4)
export XPRS_SLPGRIDANNEALING

global const XPRS_SLPGRIDCYCLIC = Int32(2)
export XPRS_SLPGRIDCYCLIC

global const XPRS_SLPGRIDENUMERATE = Int32(1)
export XPRS_SLPGRIDENUMERATE

global const XPRS_SLPHASCALCIV = Int32(8)
export XPRS_SLPHASCALCIV

global const XPRS_SLPHASCONVERGED = Int32(65536)
export XPRS_SLPHASCONVERGED

global const XPRS_SLPHASDELTA = Int32(2)
export XPRS_SLPHASDELTA

global const XPRS_SLPHASERROR = Int32(768)
export XPRS_SLPHASERROR

global const XPRS_SLPHASIV = Int32(4)
export XPRS_SLPHASIV

global const XPRS_SLPHASMINUSERROR = Int32(512)
export XPRS_SLPHASMINUSERROR

global const XPRS_SLPHASNOCOEFS = Int32(1)
export XPRS_SLPHASNOCOEFS

global const XPRS_SLPHASNONZEROCOEF = Int32(4096)
export XPRS_SLPHASNONZEROCOEF

global const XPRS_SLPHASPLUSERROR = Int32(256)
export XPRS_SLPHASPLUSERROR

global const XPRS_SLPHASSLPELEMENT = Int32(65536)
export XPRS_SLPHASSLPELEMENT

global const XPRS_SLPHASZEROBOUND = Int32(16777216)
export XPRS_SLPHASZEROBOUND

global const XPRS_SLPHOLDVALUES = Int32(16)
export XPRS_SLPHOLDVALUES

global const XPRS_SLPISDELTA = Int32(256)
export XPRS_SLPISDELTA

global const XPRS_SLPISDETERMININGROW = Int32(1024)
export XPRS_SLPISDETERMININGROW

global const XPRS_SLPISEQUALSCOLUMN = Int32(16384)
export XPRS_SLPISEQUALSCOLUMN

global const XPRS_SLPISERRORVECTOR = Int32(6144)
export XPRS_SLPISERRORVECTOR

global const XPRS_SLPISINCOEFS = Int32(4194304)
export XPRS_SLPISINCOEFS

global const XPRS_SLPISINGLOBAL = Int32(8388608)
export XPRS_SLPISINGLOBAL

global const XPRS_SLPISINTEGER = Int32(268435456)
export XPRS_SLPISINTEGER

global const XPRS_SLPISMINUSERRORVECTOR = Int32(4096)
export XPRS_SLPISMINUSERRORVECTOR

global const XPRS_SLPISMINUSPENALTYDELTA = Int32(1024)
export XPRS_SLPISMINUSPENALTYDELTA

global const XPRS_SLPISMISCROW = Int32(64)
export XPRS_SLPISMISCROW

global const XPRS_SLPISMISCVECTOR = Int32(8192)
export XPRS_SLPISMISCVECTOR

global const XPRS_SLPISPENALTYDELTA = Int32(1536)
export XPRS_SLPISPENALTYDELTA

global const XPRS_SLPISPENALTYROW = Int32(4)
export XPRS_SLPISPENALTYROW

global const XPRS_SLPISPLUSERRORVECTOR = Int32(2048)
export XPRS_SLPISPLUSERRORVECTOR

global const XPRS_SLPISPLUSPENALTYDELTA = Int32(512)
export XPRS_SLPISPLUSPENALTYDELTA

global const XPRS_SLPISSBROW = Int32(128)
export XPRS_SLPISSBROW

global const XPRS_SLPISSTRUCTURALCOLUMN = Int32(2097152)
export XPRS_SLPISSTRUCTURALCOLUMN

global const XPRS_SLPISUPDATEROW = Int32(2)
export XPRS_SLPISUPDATEROW

global const XPRS_SLPMAXCOSTOPTION = Int32(2048)
export XPRS_SLPMAXCOSTOPTION

global const XPRS_SLPMINIMUMAUGMENTATION = Int32(1)
export XPRS_SLPMINIMUMAUGMENTATION

global const XPRS_SLPMIPFINALFIXSLP = Int32(256)
export XPRS_SLPMIPFINALFIXSLP

global const XPRS_SLPMIPFINALRELAXSLP = Int32(128)
export XPRS_SLPMIPFINALRELAXSLP

global const XPRS_SLPMIPINITIALFIXSLP = Int32(8)
export XPRS_SLPMIPINITIALFIXSLP

global const XPRS_SLPMIPINITIALRELAXSLP = Int32(4)
export XPRS_SLPMIPINITIALRELAXSLP

global const XPRS_SLPMIPINITIALSLP = Int32(1)
export XPRS_SLPMIPINITIALSLP

global const XPRS_SLPMIPNODEFIXSLP = Int32(32)
export XPRS_SLPMIPNODEFIXSLP

global const XPRS_SLPMIPNODELIMITSLP = Int32(64)
export XPRS_SLPMIPNODELIMITSLP

global const XPRS_SLPMIPNODERELAXSLP = Int32(16)
export XPRS_SLPMIPNODERELAXSLP

global const XPRS_SLPMIPWITHINSLP = Int32(512)
export XPRS_SLPMIPWITHINSLP

global const XPRS_SLPNOERRORVECTORS = Int32(2048)
export XPRS_SLPNOERRORVECTORS

global const XPRS_SLPNOFORMULADOMAINIV = Int32(2048)
export XPRS_SLPNOFORMULADOMAINIV

global const XPRS_SLPNOLPPOLISHING = Int32(8192)
export XPRS_SLPNOLPPOLISHING

global const XPRS_SLPNONZEROBOUND = Int32(1024)
export XPRS_SLPNONZEROBOUND

global const XPRS_SLPNOPRESOLVECOEFFICIENTS = Int32(256)
export XPRS_SLPNOPRESOLVECOEFFICIENTS

global const XPRS_SLPNOPRESOLVEDELTAS = Int32(512)
export XPRS_SLPNOPRESOLVEDELTAS

global const XPRS_SLPNOSTEPBOUNDS = Int32(1)
export XPRS_SLPNOSTEPBOUNDS

global const XPRS_SLPNOUPDATEIFONLYIV = Int32(1024)
export XPRS_SLPNOUPDATEIFONLYIV

global const XPRS_SLPNOUSEFULDELTA = Int32(134217728)
export XPRS_SLPNOUSEFULDELTA

global const XPRS_SLPPENALTYDELTAVECTORS = Int32(16)
export XPRS_SLPPENALTYDELTAVECTORS

global const XPRS_SLPQUICKCONVERGENCECHECK = Int32(128)
export XPRS_SLPQUICKCONVERGENCECHECK

global const XPRS_SLPREDUNDANTROW = Int32(8192)
export XPRS_SLPREDUNDANTROW

global const XPRS_SLPRESETDELTAZ = Int32(64)
export XPRS_SLPRESETDELTAZ

global const XPRS_SLPRESIDUALERRORS = Int32(4096)
export XPRS_SLPRESIDUALERRORS

global const XPRS_SLPRETAINPREVIOUSVALUE = Int32(32)
export XPRS_SLPRETAINPREVIOUSVALUE

global const XPRS_SLPROOTMIPDRIVEN = Int32(4096)
export XPRS_SLPROOTMIPDRIVEN

global const XPRS_SLPROWINFO_CURRENTPENALTYERROR = Int32(6)
export XPRS_SLPROWINFO_CURRENTPENALTYERROR

global const XPRS_SLPROWINFO_CURRENTPENALTYFACTOR = Int32(7)
export XPRS_SLPROWINFO_CURRENTPENALTYFACTOR

global const XPRS_SLPROWINFO_DUAL = Int32(2)
export XPRS_SLPROWINFO_DUAL

global const XPRS_SLPROWINFO_MAXPENALTYERROR = Int32(4)
export XPRS_SLPROWINFO_MAXPENALTYERROR

global const XPRS_SLPROWINFO_NUMPENALTYERRORS = Int32(3)
export XPRS_SLPROWINFO_NUMPENALTYERRORS

global const XPRS_SLPROWINFO_PENALTYCOLUMNMINUS = Int32(11)
export XPRS_SLPROWINFO_PENALTYCOLUMNMINUS

global const XPRS_SLPROWINFO_PENALTYCOLUMNMINUSDJ = Int32(13)
export XPRS_SLPROWINFO_PENALTYCOLUMNMINUSDJ

global const XPRS_SLPROWINFO_PENALTYCOLUMNMINUSVALUE = Int32(12)
export XPRS_SLPROWINFO_PENALTYCOLUMNMINUSVALUE

global const XPRS_SLPROWINFO_PENALTYCOLUMNPLUS = Int32(8)
export XPRS_SLPROWINFO_PENALTYCOLUMNPLUS

global const XPRS_SLPROWINFO_PENALTYCOLUMNPLUSDJ = Int32(10)
export XPRS_SLPROWINFO_PENALTYCOLUMNPLUSDJ

global const XPRS_SLPROWINFO_PENALTYCOLUMNPLUSVALUE = Int32(9)
export XPRS_SLPROWINFO_PENALTYCOLUMNPLUSVALUE

global const XPRS_SLPROWINFO_SLACK = Int32(1)
export XPRS_SLPROWINFO_SLACK

global const XPRS_SLPROWINFO_TOTALPENALTYERROR = Int32(5)
export XPRS_SLPROWINFO_TOTALPENALTYERROR

global const XPRS_SLPSBFROMABSVALUES = Int32(128)
export XPRS_SLPSBFROMABSVALUES

global const XPRS_SLPSBFROMVALUES = Int32(64)
export XPRS_SLPSBFROMVALUES

global const XPRS_SLPSKIPIVLPHEURISTICS = Int32(4096)
export XPRS_SLPSKIPIVLPHEURISTICS

global const XPRS_SLPSLPTHENMIP = Int32(1024)
export XPRS_SLPSLPTHENMIP

global const XPRS_SLPSTATUS_ADAPTIVEITERS = Int32(33554432)
export XPRS_SLPSTATUS_ADAPTIVEITERS

global const XPRS_SLPSTATUS_CLAMPING = Int32(16777216)
export XPRS_SLPSTATUS_CLAMPING

global const XPRS_SLPSTATUS_CONSECUTIVE_INFEAS = Int32(4194304)
export XPRS_SLPSTATUS_CONSECUTIVE_INFEAS

global const XPRS_SLPSTATUS_CONVERGEDOBJOBJ = Int32(128)
export XPRS_SLPSTATUS_CONVERGEDOBJOBJ

global const XPRS_SLPSTATUS_CONVERGEDOBJSBX = Int32(2)
export XPRS_SLPSTATUS_CONVERGEDOBJSBX

global const XPRS_SLPSTATUS_CONVERGEDOBJUCC = Int32(1)
export XPRS_SLPSTATUS_CONVERGEDOBJUCC

global const XPRS_SLPSTATUS_ENFORCED = Int32(2097152)
export XPRS_SLPSTATUS_ENFORCED

global const XPRS_SLPSTATUS_ERROTOL = Int32(131072)
export XPRS_SLPSTATUS_ERROTOL

global const XPRS_SLPSTATUS_EVTOL = Int32(262144)
export XPRS_SLPSTATUS_EVTOL

global const XPRS_SLPSTATUS_INTEGERINFEASIBLE = Int32(32)
export XPRS_SLPSTATUS_INTEGERINFEASIBLE

global const XPRS_SLPSTATUS_KEEPBEST = Int32(8388608)
export XPRS_SLPSTATUS_KEEPBEST

global const XPRS_SLPSTATUS_LPINFEASIBLE = Int32(4)
export XPRS_SLPSTATUS_LPINFEASIBLE

global const XPRS_SLPSTATUS_LPUNFINISHED = Int32(8)
export XPRS_SLPSTATUS_LPUNFINISHED

global const XPRS_SLPSTATUS_MAXSLPITERATIONS = Int32(16)
export XPRS_SLPSTATUS_MAXSLPITERATIONS

global const XPRS_SLPSTATUS_MAXTIME = Int32(512)
export XPRS_SLPSTATUS_MAXTIME

global const XPRS_SLPSTATUS_NOVARSINACTIVE = Int32(4096)
export XPRS_SLPSTATUS_NOVARSINACTIVE

global const XPRS_SLPSTATUS_OBJQNONCONVEX = Int32(67108864)
export XPRS_SLPSTATUS_OBJQNONCONVEX

global const XPRS_SLPSTATUS_OTOL = Int32(8192)
export XPRS_SLPSTATUS_OTOL

global const XPRS_SLPSTATUS_POLISHED = Int32(524288)
export XPRS_SLPSTATUS_POLISHED

global const XPRS_SLPSTATUS_POLISH_FAILURE = Int32(1048576)
export XPRS_SLPSTATUS_POLISH_FAILURE

global const XPRS_SLPSTATUS_RESIDUALPENALTIES = Int32(64)
export XPRS_SLPSTATUS_RESIDUALPENALTIES

global const XPRS_SLPSTATUS_USER = Int32(1024)
export XPRS_SLPSTATUS_USER

global const XPRS_SLPSTATUS_VARSLINKEDINACTIVE = Int32(2048)
export XPRS_SLPSTATUS_VARSLINKEDINACTIVE

global const XPRS_SLPSTATUS_VTOL = Int32(16384)
export XPRS_SLPSTATUS_VTOL

global const XPRS_SLPSTATUS_WTOL = Int32(65536)
export XPRS_SLPSTATUS_WTOL

global const XPRS_SLPSTATUS_XTOL = Int32(32768)
export XPRS_SLPSTATUS_XTOL

global const XPRS_SLPSTEPBOUNDROWS = Int32(256)
export XPRS_SLPSTEPBOUNDROWS

global const XPRS_SLPSTEPBOUNDSASREQUIRED = Int32(2)
export XPRS_SLPSTEPBOUNDSASREQUIRED

global const XPRS_SLPSWITCHTOPRIMAL = Int32(512)
export XPRS_SLPSWITCHTOPRIMAL

global const XPRS_SLPTOLSETBIT_RA = Int32(4)
export XPRS_SLPTOLSETBIT_RA

global const XPRS_SLPTOLSETBIT_RI = Int32(64)
export XPRS_SLPTOLSETBIT_RI

global const XPRS_SLPTOLSETBIT_RM = Int32(16)
export XPRS_SLPTOLSETBIT_RM

global const XPRS_SLPTOLSETBIT_RS = Int32(256)
export XPRS_SLPTOLSETBIT_RS

global const XPRS_SLPTOLSETBIT_TA = Int32(2)
export XPRS_SLPTOLSETBIT_TA

global const XPRS_SLPTOLSETBIT_TC = Int32(1)
export XPRS_SLPTOLSETBIT_TC

global const XPRS_SLPTOLSETBIT_TI = Int32(32)
export XPRS_SLPTOLSETBIT_TI

global const XPRS_SLPTOLSETBIT_TM = Int32(8)
export XPRS_SLPTOLSETBIT_TM

global const XPRS_SLPTOLSETBIT_TS = Int32(128)
export XPRS_SLPTOLSETBIT_TS

global const XPRS_SLPTOLSET_RA = Int32(2)
export XPRS_SLPTOLSET_RA

global const XPRS_SLPTOLSET_RI = Int32(6)
export XPRS_SLPTOLSET_RI

global const XPRS_SLPTOLSET_RM = Int32(4)
export XPRS_SLPTOLSET_RM

global const XPRS_SLPTOLSET_RS = Int32(8)
export XPRS_SLPTOLSET_RS

global const XPRS_SLPTOLSET_TA = Int32(1)
export XPRS_SLPTOLSET_TA

global const XPRS_SLPTOLSET_TC = Int32(0)
export XPRS_SLPTOLSET_TC

global const XPRS_SLPTOLSET_TI = Int32(5)
export XPRS_SLPTOLSET_TI

global const XPRS_SLPTOLSET_TM = Int32(3)
export XPRS_SLPTOLSET_TM

global const XPRS_SLPTOLSET_TS = Int32(7)
export XPRS_SLPTOLSET_TS

global const XPRS_SLPTRACEMASK_CASCADE = Int32(8)
export XPRS_SLPTRACEMASK_CASCADE

global const XPRS_SLPTRACEMASK_COLS = Int32(4)
export XPRS_SLPTRACEMASK_COLS

global const XPRS_SLPTRACEMASK_CONVERGE = Int32(4096)
export XPRS_SLPTRACEMASK_CONVERGE

global const XPRS_SLPTRACEMASK_DUAL = Int32(64)
export XPRS_SLPTRACEMASK_DUAL

global const XPRS_SLPTRACEMASK_GENERALFIT = Int32(1)
export XPRS_SLPTRACEMASK_GENERALFIT

global const XPRS_SLPTRACEMASK_LINESEARCH = Int32(8192)
export XPRS_SLPTRACEMASK_LINESEARCH

global const XPRS_SLPTRACEMASK_REDUCEDCOST = Int32(512)
export XPRS_SLPTRACEMASK_REDUCEDCOST

global const XPRS_SLPTRACEMASK_ROWS = Int32(2)
export XPRS_SLPTRACEMASK_ROWS

global const XPRS_SLPTRACEMASK_SLACK = Int32(32)
export XPRS_SLPTRACEMASK_SLACK

global const XPRS_SLPTRACEMASK_SLPVALUE = Int32(1024)
export XPRS_SLPTRACEMASK_SLPVALUE

global const XPRS_SLPTRACEMASK_SOLUTION = Int32(256)
export XPRS_SLPTRACEMASK_SOLUTION

global const XPRS_SLPTRACEMASK_STEPBOUND = Int32(2048)
export XPRS_SLPTRACEMASK_STEPBOUND

global const XPRS_SLPTRACEMASK_TYPE = Int32(16)
export XPRS_SLPTRACEMASK_TYPE

global const XPRS_SLPTRACEMASK_WEIGHT = Int32(128)
export XPRS_SLPTRACEMASK_WEIGHT

global const XPRS_SLPTRANSFERROW = Int32(262144)
export XPRS_SLPTRANSFERROW

global const XPRS_SLPUNCONVERGEDROW = Int32(16384)
export XPRS_SLPUNCONVERGEDROW

global const XPRS_SLPUSEFULDELTA = Int32(134217728)
export XPRS_SLPUSEFULDELTA

global const XPRS_TOK_COL = Int32(10)
export XPRS_TOK_COL

global const XPRS_TOK_CON = Int32(1)
export XPRS_TOK_CON

global const XPRS_TOK_DEL = Int32(24)
export XPRS_TOK_DEL

global const XPRS_TOK_EOF = Int32(0)
export XPRS_TOK_EOF

global const XPRS_TOK_FUN = Int32(11)
export XPRS_TOK_FUN

global const XPRS_TOK_IFUN = Int32(12)
export XPRS_TOK_IFUN

global const XPRS_TOK_LB = Int32(21)
export XPRS_TOK_LB

global const XPRS_TOK_OP = Int32(31)
export XPRS_TOK_OP

global const XPRS_TOK_RB = Int32(22)
export XPRS_TOK_RB

global const XPRS_USERFUNCTION_MAP = Int32(1)
export XPRS_USERFUNCTION_MAP

global const XPRS_USERFUNCTION_MAPDELTA = Int32(4)
export XPRS_USERFUNCTION_MAPDELTA

global const XPRS_USERFUNCTION_MULTIMAP = Int32(3)
export XPRS_USERFUNCTION_MULTIMAP

global const XPRS_USERFUNCTION_MULTIMAPDELTA = Int32(6)
export XPRS_USERFUNCTION_MULTIMAPDELTA

global const XPRS_USERFUNCTION_VECMAP = Int32(2)
export XPRS_USERFUNCTION_VECMAP

global const XPRS_USERFUNCTION_VECMAPDELTA = Int32(5)
export XPRS_USERFUNCTION_VECMAPDELTA

"""
    XPRS_ACTIVENODES
Number of outstanding nodes. (integer)
"""
global const XPRS_ACTIVENODES = Int32(1015)
export XPRS_ACTIVENODES

"""
    XPRS_ALGORITHM
The algorithm the optimizer currently is running / was running just before completition. (integer)

Values:
1
: No LP optimization yet.
2
: Dual simplex.
3
: Primal simplex.
4
: Newton barrier or hybrid gradient.
5
: Network simplex.
"""
global const XPRS_ALGORITHM = Int32(1049)
export XPRS_ALGORITHM

"""
    XPRS_ATTENTIONLEVEL
A measure between 0 and 1 for how numerically unstable the problem is. (double)

The attention level is based on a weighted combination of the number of basis condition numbers exceeding certain thresholds. It considers all nodes sampled by MIPKAPPAFREQ, with a setting of 1 being the most frequent sampling rate. The higher the attention level, the worse conditioned is the problem.
"""
global const XPRS_ATTENTIONLEVEL = Int32(2097)
export XPRS_ATTENTIONLEVEL

"""
    XPRS_AVAILABLEMEMORY
The amount of heap memory detected by Xpress as free. (integer)
"""
global const XPRS_AVAILABLEMEMORY = Int32(1324)
export XPRS_AVAILABLEMEMORY

"""
    XPRS_BARAASIZE
Number of nonzeros in AAT. (integer)
"""
global const XPRS_BARAASIZE = Int32(5002)
export XPRS_BARAASIZE

"""
    XPRS_BARCGAP
Convergence criterion for the Newton barrier algorithm. (double)
"""
global const XPRS_BARCGAP = Int32(4005)
export XPRS_BARCGAP

"""
    XPRS_BARCONDA
Absolute condition measure calculated in the last iteration of the barrier algorithm. (double)
"""
global const XPRS_BARCONDA = Int32(2063)
export XPRS_BARCONDA

"""
    XPRS_BARCONDD
Condition measure calculated in the last iteration of the barrier algorithm. (double)
"""
global const XPRS_BARCONDD = Int32(2064)
export XPRS_BARCONDD

"""
    XPRS_BARCROSSOVER
Indicates whether or not the basis crossover phase has been entered. (integer)

Values:
0
: the crossover phase has not been entered.
1
: the crossover phase has been entered.
"""
global const XPRS_BARCROSSOVER = Int32(5005)
export XPRS_BARCROSSOVER

"""
    XPRS_BARDENSECOL
Number of dense columns found in the matrix. (integer)
"""
global const XPRS_BARDENSECOL = Int32(5004)
export XPRS_BARDENSECOL

"""
    XPRS_BARDUALINF
Sum of the dual infeasibilities for the Newton barrier algorithm. (double)
"""
global const XPRS_BARDUALINF = Int32(4004)
export XPRS_BARDUALINF

"""
    XPRS_BARDUALOBJ
Dual objective value calculated by the Newton barrier algorithm. (double)
"""
global const XPRS_BARDUALOBJ = Int32(4002)
export XPRS_BARDUALOBJ

"""
    XPRS_BARITER
Number of Newton barrier iterations. (integer)
"""
global const XPRS_BARITER = Int32(5001)
export XPRS_BARITER

"""
    XPRS_BARLSIZE
Number of nonzeros in L resulting from the Cholesky factorization. (integer)
"""
global const XPRS_BARLSIZE = Int32(5003)
export XPRS_BARLSIZE

"""
    XPRS_BARPRIMALINF
Sum of the primal infeasibilities for the Newton barrier algorithm. (double)
"""
global const XPRS_BARPRIMALINF = Int32(4003)
export XPRS_BARPRIMALINF

"""
    XPRS_BARPRIMALOBJ
Primal objective value calculated by the Newton barrier algorithm. (double)
"""
global const XPRS_BARPRIMALOBJ = Int32(4001)
export XPRS_BARPRIMALOBJ

"""
    XPRS_BARSING
Number of linearly dependent binding constraints at the optimal barrier solution. (double)

These results in singularities in the Cholesky decomposition during the barrier that may cause numerical troubles. Larger dependence means more chance for numerical difficulties.
"""
global const XPRS_BARSING = Int32(1281)
export XPRS_BARSING

"""
    XPRS_BARSINGR
Regularized number of linearly dependent binding constraints at the optimal barrier solution. (double)

These results in singularities in the Cholesky decomposition during the barrier that may cause numerical troubles. Larger dependence means more chance for numerical difficulties.
"""
global const XPRS_BARSINGR = Int32(1282)
export XPRS_BARSINGR

"""
    XPRS_BESTBOUND
Value of the best bound determined so far by the MIP search. (double)
"""
global const XPRS_BESTBOUND = Int32(2004)
export XPRS_BESTBOUND

"""
    XPRS_BOUNDNAME
Active bound name. (string)
"""
global const XPRS_BOUNDNAME = Int32(3002)
export XPRS_BOUNDNAME

"""
    XPRS_BRANCHVALUE
The value of the branching variable at a node of the Branch and Bound tree. (double)
"""
global const XPRS_BRANCHVALUE = Int32(2009)
export XPRS_BRANCHVALUE

"""
    XPRS_BRANCHVAR
The branching variable at a node of the Branch and Bound tree. (integer)
"""
global const XPRS_BRANCHVAR = Int32(1036)
export XPRS_BRANCHVAR

"""
    XPRS_CALLBACKCOUNT_CUTMGR
This attribute counts the number of times the cut manager callback set by XPRSaddcbcutmgr has been called for the current node, including the current callback call. (integer)

The value of this attribute should only be used from within the cut manager callback.
"""
global const XPRS_CALLBACKCOUNT_CUTMGR = Int32(1137)
export XPRS_CALLBACKCOUNT_CUTMGR

"""
    XPRS_CALLBACKCOUNT_OPTNODE
This attribute counts the number of times the optimal node callback set by XPRSaddcboptnode has been called for the current node, including the current callback call. (integer)

The value of this attribute should only be used from within the optimal node callback.
"""
global const XPRS_CALLBACKCOUNT_OPTNODE = Int32(1136)
export XPRS_CALLBACKCOUNT_OPTNODE

"""
    XPRS_CHECKSONMAXCUTTIME
This attribute is used to set the value of the MAXCHECKSONMAXCUTTIME control. (integer)

Its value is the number of times the optimizer checked the MAXCUTTIME criterion during the last call to the optimization routine XPRSmipoptimize. If a run terminates cutting operations on the `MAXCUTTIME` criterion then the attribute is the negative of the number of times the optimizer checked the `MAXCUTTIME` criterion up to and including the check when the termination was activated. Note that the attribute is set to zero at the beginning of each call to an optimization routine.
"""
global const XPRS_CHECKSONMAXCUTTIME = Int32(1209)
export XPRS_CHECKSONMAXCUTTIME

"""
    XPRS_CHECKSONMAXTIME
This attribute is used to set the value of the MAXCHECKSONMAXTIME control. (integer)

Its value is the number of times the optimizer checked the MAXTIME criterion during the last call to the optimization routine XPRSmipoptimize. If a run terminates on the `MAXTIME` criterion then the attribute is the negative of the number of times the optimizer checked the `MAXTIME` criterion up to and including the check when the termination was activated. Note that the attribute is set to zero at the beginning of each call to an optimization routine.
"""
global const XPRS_CHECKSONMAXTIME = Int32(1208)
export XPRS_CHECKSONMAXTIME

"""
    XPRS_COLS
Number of columns (i.e. variables) in the matrix. (integer)
"""
global const XPRS_COLS = Int32(1018)
export XPRS_COLS

"""
    XPRS_COMPUTEEXECUTIONS
The number of solves executed on a compute server. (integer)
"""
global const XPRS_COMPUTEEXECUTIONS = Int32(1356)
export XPRS_COMPUTEEXECUTIONS

"""
    XPRS_CONEELEMS
Number of second order cone coefficients in the problem. (integer)
"""
global const XPRS_CONEELEMS = Int32(1308)
export XPRS_CONEELEMS

"""
    XPRS_CONES
Number of second order and rotated second order cones in the problem. (integer)
"""
global const XPRS_CONES = Int32(1307)
export XPRS_CONES

"""
    XPRS_CORESDETECTED
Number of logical cores detected by the optimizer, which is the total number of threads the hardware can execute across all CPUs. (integer)

Values:
>=1
: Detected number of logical cores.
"""
global const XPRS_CORESDETECTED = Int32(1260)
export XPRS_CORESDETECTED

"""
    XPRS_CORESPERCPUDETECTED
Number of logical cores per CPU unit detected by the optimizer, which is the number of threads each CPU can execute. (integer)

Values:
>=1
: Detected number of logical cores per CPU unit.
"""
global const XPRS_CORESPERCPUDETECTED = Int32(1258)
export XPRS_CORESPERCPUDETECTED

"""
    XPRS_CPISCALEFACTOR
scale factor from primal integral computation. (double)
"""
global const XPRS_CPISCALEFACTOR = Int32(2117)
export XPRS_CPISCALEFACTOR

"""
    XPRS_CPUSDETECTED
Number of CPU units detected by the optimizer. (integer)

Values:
>=1
: Detected number of CPU units.
"""
global const XPRS_CPUSDETECTED = Int32(1259)
export XPRS_CPUSDETECTED

"""
    XPRS_CROSSOVERITER
Number of simplex iterations performed in crossover. (integer)
"""
global const XPRS_CROSSOVERITER = Int32(1051)
export XPRS_CROSSOVERITER

"""
    XPRS_CURRENTMEMORY
The amount of dynamically allocated heap memory by the problem being solved. (integer)
"""
global const XPRS_CURRENTMEMORY = Int32(1285)
export XPRS_CURRENTMEMORY

"""
    XPRS_CURRENTNODE
The unique identifier of the current node in the tree search. (integer)
"""
global const XPRS_CURRENTNODE = Int32(1248)
export XPRS_CURRENTNODE

"""
    XPRS_CURRMIPCUTOFF
The current MIP cut off. (double)
"""
global const XPRS_CURRMIPCUTOFF = Int32(2062)
export XPRS_CURRMIPCUTOFF

"""
    XPRS_CUTS
Number of cuts being added to the matrix. (integer)
"""
global const XPRS_CUTS = Int32(1012)
export XPRS_CUTS

"""
    XPRS_DUALINFEAS
Number of dual infeasibilities. (integer)
"""
global const XPRS_DUALINFEAS = Int32(1008)
export XPRS_DUALINFEAS

"""
    XPRS_ELEMS
Number of matrix nonzeros (elements). (integer)
"""
global const XPRS_ELEMS = Int32(1006)
export XPRS_ELEMS

"""
    XPRS_ERRORCODE
The most recent Optimizer error number that occurred. (integer)

This is useful to determine the precise error or warning that has occurred, after an Optimizer function has signalled an error by returning a non-zero value. The return value itself is not the error number. Refer to the section for a list of possible error numbers, the errors and warnings that they indicate, and advice on what they mean and how to resolve them. A short error message may be obtained using XPRSgetlasterror, and all messages may be intercepted using the user output callback function; see XPRSaddcbmessage.
"""
global const XPRS_ERRORCODE = Int32(1023)
export XPRS_ERRORCODE

"""
    XPRS_GENCONCOLS
Number of input variables in general constraints (i.e. MIN/MAX/AND/OR/ABS constraints) in the problem. (integer)
"""
global const XPRS_GENCONCOLS = Int32(1328)
export XPRS_GENCONCOLS

"""
    XPRS_GENCONS
The number of general constraints (i.e. MIN/MAX/AND/OR/ABS constraints) in the problem. (integer)
"""
global const XPRS_GENCONS = Int32(1327)
export XPRS_GENCONS

"""
    XPRS_GENCONVALS
Number of constant values in general constraints (MIN/MAX constraints) in the problem. (integer)
"""
global const XPRS_GENCONVALS = Int32(1329)
export XPRS_GENCONVALS

"""
    XPRS_GLOBALBOUNDINGBOXAPPLIED
Whether a bounding box equal to the absolute value of the GLOBALBOUNDINGBOX control was applied to the problem after the initial solve came back infeasible and if so, to which variables. (double)

Values:
0
: No bounding box applied(`XPRS_GLOBALBOUNDINGBOX_NOT_APPLIED`).
1
: Bounding box applied to all original variables(`XPRS_GLOBALBOUNDINGBOX_ORIGINAL`).
2
: Bounding box applied to all original and auxiliary variables(`XPRS_GLOBALBOUNDINGBOX_AUXILIARY`).
"""
global const XPRS_GLOBALBOUNDINGBOXAPPLIED = Int32(1396)
export XPRS_GLOBALBOUNDINGBOXAPPLIED

"""
    XPRS_GLOBALNLPINFEAS
Number of nonlinear infeasibilities at the current node of a global solve, measured as the number of violated atomic formulas. (integer)
"""
global const XPRS_GLOBALNLPINFEAS = Int32(1403)
export XPRS_GLOBALNLPINFEAS

"""
    XPRS_IISSOLSTATUS
IIS solution status. (integer)

Values:
0
: Unstarted (`XPRS_IIS_UNSTARTED`), typically due to a license or input error.
1
: Feasible (`XPRS_IIS_FEASIBLE`), so no IIS can be produced.
2
: Completed (`XPRS_IIS_COMPLETED`); this is the normal termination. The number of IIS sets can be queried through the NUMIIS attribute.
3
: Unfinished (`XPRS_IIS_UNFINISHED`), either because of hitting the time limit or because of a user interrupt. When the IIS procedure terminates with this status the last IIS set may not be irreducible.
"""
global const XPRS_IISSOLSTATUS = Int32(1406)
export XPRS_IISSOLSTATUS

"""
    XPRS_INDICATORS
Number of indicator constrains in the problem. (integer)
"""
global const XPRS_INDICATORS = Int32(1254)
export XPRS_INDICATORS

"""
    XPRS_INPUTCOLS
Number of columns (i.e. variables) in the original matrix before nonlinear reformulations. (integer)
"""
global const XPRS_INPUTCOLS = Int32(1409)
export XPRS_INPUTCOLS

"""
    XPRS_INPUTROWS
Number of rows (i.e. constraints) in the original matrix before nonlinear reformulations. (integer)
"""
global const XPRS_INPUTROWS = Int32(1408)
export XPRS_INPUTROWS

global const XPRS_LOCALSOLVERSELECTED = Int32(12075)
export XPRS_LOCALSOLVERSELECTED

"""
    XPRS_LPOBJVAL
Value of the objective function of the last LP solved. (double)
"""
global const XPRS_LPOBJVAL = Int32(2001)
export XPRS_LPOBJVAL

"""
    XPRS_LPSTATUS
LP solution status. (integer)

Values:
0
: Unstarted (`XPRS_LP_UNSTARTED`).
1
: Optimal (`XPRS_LP_OPTIMAL`).
2
: Infeasible (`XPRS_LP_INFEAS`).
3
: Objective worse than cutoff (`XPRS_LP_CUTOFF`).
4
: Unfinished (`XPRS_LP_UNFINISHED`).
5
: Unbounded (`XPRS_LP_UNBOUNDED`).
6
: Cutoff in dual (`XPRS_LP_CUTOFF_IN_DUAL`).
7
: Problem could not be solved due to numerical issues. (`XPRS_LP_UNSOLVED`).
8
: Problem contains quadratic data, which is not convex (`XPRS_LP_NONCONVEX`). Consider using FICO Xpress Global.
"""
global const XPRS_LPSTATUS = Int32(1010)
export XPRS_LPSTATUS

"""
    XPRS_MATRIXNAME
The matrix name. (string)
"""
global const XPRS_MATRIXNAME = Int32(3001)
export XPRS_MATRIXNAME

"""
    XPRS_MAXABSDUALINFEAS
Maximum calculated absolute dual infeasibility in the unscaled original problem. (double)
"""
global const XPRS_MAXABSDUALINFEAS = Int32(2075)
export XPRS_MAXABSDUALINFEAS

"""
    XPRS_MAXABSPRIMALINFEAS
Maximum calculated absolute primal infeasibility in the unscaled original problem. (double)
"""
global const XPRS_MAXABSPRIMALINFEAS = Int32(2073)
export XPRS_MAXABSPRIMALINFEAS

"""
    XPRS_MAXKAPPA
Largest basis condition number (also known as kappa) calculated through all nodes sampled by MIPKAPPAFREQ. (double)
"""
global const XPRS_MAXKAPPA = Int32(2098)
export XPRS_MAXKAPPA

"""
    XPRS_MAXMIPINFEAS
Maximum integer fractionality in the solution. (double)
"""
global const XPRS_MAXMIPINFEAS = Int32(2083)
export XPRS_MAXMIPINFEAS

"""
    XPRS_MAXPROBNAMELENGTH
Maximum size of the problem name and also the maximum allowed length of the file or path string for any function that accepts such an argument (not including the nothing terminator). (integer)
"""
global const XPRS_MAXPROBNAMELENGTH = Int32(1158)
export XPRS_MAXPROBNAMELENGTH

"""
    XPRS_MAXRELDUALINFEAS
Maximum calculated relative dual infeasibility in the unscaled original problem. (double)
"""
global const XPRS_MAXRELDUALINFEAS = Int32(2076)
export XPRS_MAXRELDUALINFEAS

"""
    XPRS_MAXRELPRIMALINFEAS
Maximum calculated relative primal infeasibility in the unscaled original problem. (double)
"""
global const XPRS_MAXRELPRIMALINFEAS = Int32(2074)
export XPRS_MAXRELPRIMALINFEAS

"""
    XPRS_MEMORYLIMITDETECTED
The detected amount of memory accessible to the solver process, in megabytes. (integer)

This is the minimum of physical memory, virtual memory limitations, and detected container limitations (Linux only).
"""
global const XPRS_MEMORYLIMITDETECTED = Int32(1380)
export XPRS_MEMORYLIMITDETECTED

"""
    XPRS_MIPBESTOBJVAL
Objective function value of the best integer solution found. (double)
"""
global const XPRS_MIPBESTOBJVAL = Int32(2006)
export XPRS_MIPBESTOBJVAL

"""
    XPRS_MIPENTS
Number of MIP entities (i.e. binary, integer, semi-continuous, partial integer, and semi-continuous integer variables) but excluding the number of special ordered sets. (integer)
"""
global const XPRS_MIPENTS = Int32(1032)
export XPRS_MIPENTS

"""
    XPRS_MIPINFEAS
Number of integer infeasibilities, including violations of special ordered sets, at the current node. (integer)
"""
global const XPRS_MIPINFEAS = Int32(1024)
export XPRS_MIPINFEAS

"""
    XPRS_MIPOBJVAL
Objective function value of the last integer solution found. (double)
"""
global const XPRS_MIPOBJVAL = Int32(2003)
export XPRS_MIPOBJVAL

"""
    XPRS_MIPSOLNODE
Node at which the last integer feasible solution was found. (integer)
"""
global const XPRS_MIPSOLNODE = Int32(1016)
export XPRS_MIPSOLNODE

"""
    XPRS_MIPSOLS
Number of integer solutions that have been found. (integer)
"""
global const XPRS_MIPSOLS = Int32(1017)
export XPRS_MIPSOLS

"""
    XPRS_MIPSOLTIME
Time at which the last integer feasible solution was found. (double)
"""
global const XPRS_MIPSOLTIME = Int32(1371)
export XPRS_MIPSOLTIME

"""
    XPRS_MIPSTATUS
(MIP) solution status. (integer)

Values:
0
: Problem has not been loaded (`XPRS_MIP_NOT_LOADED`).
1
: MIP search incomplete - the initial continuous relaxation has not been solved and no integer solution has been found (`XPRS_MIP_LP_NOT_OPTIMAL`).
2
: MIP search incomplete - the initial continuous relaxation has been solved and no integer solution has been found (`XPRS_MIP_LP_OPTIMAL`).
3
: MIP search incomplete - no integer solution found (`XPRS_MIP_NO_SOL_FOUND`).
4
: MIP search incomplete - an integer solution has been found (`XPRS_MIP_SOLUTION`).
5
: MIP search complete - no integer solution found (`XPRS_MIP_INFEAS`).
6
: MIP search complete - integer solution found (`XPRS_MIP_OPTIMAL`).
7
: MIP search incomplete - the initial continuous relaxation was found to be unbounded. A solution may have been found (`XPRS_MIP_UNBOUNDED`).
"""
global const XPRS_MIPSTATUS = Int32(1011)
export XPRS_MIPSTATUS

"""
    XPRS_MIPTHREADID
The ID for the MIP thread. (integer)
"""
global const XPRS_MIPTHREADID = Int32(1037)
export XPRS_MIPTHREADID

"""
    XPRS_NAMELENGTH
The length (in 8 character units) of row and column names in the matrix. (integer)

To allocate a character array to store names, you must allow `8*NAMELENGTH+1` characters per name (the `+1` allows for the string terminator character).
"""
global const XPRS_NAMELENGTH = Int32(1028)
export XPRS_NAMELENGTH

global const XPRS_NLPEQUALSCOLUMN = Int32(12013)
export XPRS_NLPEQUALSCOLUMN

global const XPRS_NLPIFS = Int32(12008)
export XPRS_NLPIFS

global const XPRS_NLPIMPLICITVARIABLES = Int32(12015)
export XPRS_NLPIMPLICITVARIABLES

global const XPRS_NLPJOBID = Int32(12081)
export XPRS_NLPJOBID

global const XPRS_NLPKEEPBESTITER = Int32(12042)
export XPRS_NLPKEEPBESTITER

global const XPRS_NLPMODELCOLS = Int32(12080)
export XPRS_NLPMODELCOLS

global const XPRS_NLPMODELROWS = Int32(12079)
export XPRS_NLPMODELROWS

global const XPRS_NLPOBJVAL = Int32(12179)
export XPRS_NLPOBJVAL

global const XPRS_NLPOPTTIME = Int32(12147)
export XPRS_NLPOPTTIME

global const XPRS_NLPORIGINALCOLS = Int32(12000)
export XPRS_NLPORIGINALCOLS

global const XPRS_NLPORIGINALROWS = Int32(11999)
export XPRS_NLPORIGINALROWS

global const XPRS_NLPPRESOLVEELIMINATIONS = Int32(12090)
export XPRS_NLPPRESOLVEELIMINATIONS

global const XPRS_NLPSTATUS = Int32(12044)
export XPRS_NLPSTATUS

global const XPRS_NLPSTOPSTATUS = Int32(12089)
export XPRS_NLPSTOPSTATUS

global const XPRS_NLPUFS = Int32(12007)
export XPRS_NLPUFS

global const XPRS_NLPUSEDERIVATIVES = Int32(12037)
export XPRS_NLPUSEDERIVATIVES

global const XPRS_NLPUSERFUNCCALLS = Int32(12031)
export XPRS_NLPUSERFUNCCALLS

global const XPRS_NLPVALIDATIONINDEX_A = Int32(12167)
export XPRS_NLPVALIDATIONINDEX_A

global const XPRS_NLPVALIDATIONINDEX_K = Int32(12718)
export XPRS_NLPVALIDATIONINDEX_K

global const XPRS_NLPVALIDATIONINDEX_R = Int32(12168)
export XPRS_NLPVALIDATIONINDEX_R

global const XPRS_NLPVARIABLES = Int32(12014)
export XPRS_NLPVARIABLES

"""
    XPRS_NODEDEPTH
Depth of the current node. (integer)
"""
global const XPRS_NODEDEPTH = Int32(1014)
export XPRS_NODEDEPTH

"""
    XPRS_NODES
Number of nodes solved so far in the MIP search. (integer)

A node is counted as solved when it is either dropped or branched on.
"""
global const XPRS_NODES = Int32(1013)
export XPRS_NODES

global const XPRS_NONLINEARCONSTRAINTS = Int32(12026)
export XPRS_NONLINEARCONSTRAINTS

"""
    XPRS_NUMIIS
Number of IISs found. (integer)

You should first query the IISSOLSTATUS attribute to make sure that the IIS procedure terminated successfully.
"""
global const XPRS_NUMIIS = Int32(1031)
export XPRS_NUMIIS

"""
    XPRS_OBJECTIVES
Number of objectives in the problem. (integer)
"""
global const XPRS_OBJECTIVES = Int32(1397)
export XPRS_OBJECTIVES

"""
    XPRS_OBJNAME
**Deprecated**To find the name of the objective function use XPRSgetnamelist, passing `XPRS_NAMES_OBJECTIVE` in the `type` parameter. (string)
"""
global const XPRS_OBJNAME = Int32(3003)
export XPRS_OBJNAME

"""
    XPRS_OBJRHS
Fixed part of the objective function. (double)
"""
global const XPRS_OBJRHS = Int32(2005)
export XPRS_OBJRHS

"""
    XPRS_OBJSENSE
Sense of the optimization being performed. (double)

Values:
-1.0
: For maximization problems.
1.0
: For minimization problems.
"""
global const XPRS_OBJSENSE = Int32(2008)
export XPRS_OBJSENSE

"""
    XPRS_OBJSTOSOLVE
Number of objectives that will be solved during the current multi-objective solve. (integer)
"""
global const XPRS_OBJSTOSOLVE = Int32(1400)
export XPRS_OBJSTOSOLVE

"""
    XPRS_OBJVAL
Value of the objective function of the last problem solved with XPRSoptimize. (double)
"""
global const XPRS_OBJVAL = Int32(2118)
export XPRS_OBJVAL

"""
    XPRS_OBSERVEDPRIMALINTEGRAL
Value of the (observed) primal integral. (double)
"""
global const XPRS_OBSERVEDPRIMALINTEGRAL = Int32(2106)
export XPRS_OBSERVEDPRIMALINTEGRAL

"""
    XPRS_OPTIMIZETYPEUSED
The type of solver used in the last call to XPRSoptimize, XPRSmipoptimize, XPRSlpoptimize or `XPRSnlpoptimize`. (integer)

Values:
-1
: No solver was selected yet (`XPRS_OPTIMIZETYPE_NONE`). This can occur if the solve was interrupted while determining the problem type.
0
: The LP solver was selected (`XPRS_OPTIMIZETYPE_LP`). The LP algorithm used by default is controlled by DEFAULTALG.
1
: The MIP solver was selected (`XPRS_OPTIMIZETYPE_MIP`).
2
: A local nonlinear solver was selected (`XPRS_OPTIMIZETYPE_LOCAL`). See XPRS_LOCALSOLVERSELECTED for which local solver was selected.
3
: The global nonlinear solver was selected (`XPRS_OPTIMIZETYPE_GLOBAL`).
"""
global const XPRS_OPTIMIZETYPEUSED = Int32(1268)
export XPRS_OPTIMIZETYPEUSED

"""
    XPRS_ORIGINALCOLS
Number of columns (i.e. variables) in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALCOLS = Int32(1214)
export XPRS_ORIGINALCOLS

"""
    XPRS_ORIGINALGENCONCOLS
Number of input variables in general constraints in the original problem before presolving. (integer)
"""
global const XPRS_ORIGINALGENCONCOLS = Int32(1339)
export XPRS_ORIGINALGENCONCOLS

"""
    XPRS_ORIGINALGENCONS
Number of general constraints in the original problem before presolving. (integer)
"""
global const XPRS_ORIGINALGENCONS = Int32(1338)
export XPRS_ORIGINALGENCONS

"""
    XPRS_ORIGINALGENCONVALS
Number of constant values in general constraints in the original problem before presolving. (integer)
"""
global const XPRS_ORIGINALGENCONVALS = Int32(1340)
export XPRS_ORIGINALGENCONVALS

"""
    XPRS_ORIGINALINDICATORS
Number of indicator constraints in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALINDICATORS = Int32(1255)
export XPRS_ORIGINALINDICATORS

"""
    XPRS_ORIGINALMIPENTS
Number of MIP entities (i.e. binary, integer, semi-continuous, partial integer, and semi-continuous integer variables) but excluding the number of special ordered sets in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALMIPENTS = Int32(1191)
export XPRS_ORIGINALMIPENTS

"""
    XPRS_ORIGINALPWLPOINTS
Number of breakpoints of piecewise linear constraints in the original problem before presolving. (integer)
"""
global const XPRS_ORIGINALPWLPOINTS = Int32(1337)
export XPRS_ORIGINALPWLPOINTS

"""
    XPRS_ORIGINALPWLS
Number of piecewise linear constraints in the original problem before presolving. (integer)
"""
global const XPRS_ORIGINALPWLS = Int32(1336)
export XPRS_ORIGINALPWLS

"""
    XPRS_ORIGINALQCELEMS
Number of quadratic row coefficients in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALQCELEMS = Int32(1237)
export XPRS_ORIGINALQCELEMS

"""
    XPRS_ORIGINALQCONSTRAINTS
Number of rows with quadratic coefficients in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALQCONSTRAINTS = Int32(1239)
export XPRS_ORIGINALQCONSTRAINTS

"""
    XPRS_ORIGINALQELEMS
Number of quadratic non-zeros in the original objective before presolving. (integer)
"""
global const XPRS_ORIGINALQELEMS = Int32(1157)
export XPRS_ORIGINALQELEMS

"""
    XPRS_ORIGINALROWS
Number of rows (i.e. constraints) in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALROWS = Int32(1124)
export XPRS_ORIGINALROWS

"""
    XPRS_ORIGINALSETMEMBERS
Number of variables within special ordered sets (set members) in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALSETMEMBERS = Int32(1195)
export XPRS_ORIGINALSETMEMBERS

"""
    XPRS_ORIGINALSETS
Number of special ordered sets in the original matrix before presolving. (integer)
"""
global const XPRS_ORIGINALSETS = Int32(1194)
export XPRS_ORIGINALSETS

"""
    XPRS_PARENTNODE
The parent node of the current node in the tree search. (integer)
"""
global const XPRS_PARENTNODE = Int32(1027)
export XPRS_PARENTNODE

"""
    XPRS_PEAKMEMORY
An estimate of the peak amount of dynamically allocated heap memory by the problem. (integer)
"""
global const XPRS_PEAKMEMORY = Int32(1286)
export XPRS_PEAKMEMORY

"""
    XPRS_PEAKTOTALTREEMEMORYUSAGE
The peak size, in megabytes, that the branch-and-bound search tree reached during the solve. (integer)

Note that this value will include the uncompressed size of any compressed data and the size of any data saved to the tree file.
"""
global const XPRS_PEAKTOTALTREEMEMORYUSAGE = Int32(1240)
export XPRS_PEAKTOTALTREEMEMORYUSAGE

"""
    XPRS_PENALTYVALUE
The weighted sum of violations in the solution to the relaxed problem identified by the infeasibility repair function. (double)
"""
global const XPRS_PENALTYVALUE = Int32(2061)
export XPRS_PENALTYVALUE

"""
    XPRS_PHYSICALCORESDETECTED
The total number of physical cores across all CPUs detected by the optimizer. (integer)

Values:
>=1
: Detected number of physical cores.
"""
global const XPRS_PHYSICALCORESDETECTED = Int32(1261)
export XPRS_PHYSICALCORESDETECTED

"""
    XPRS_PHYSICALCORESPERCPUDETECTED
The number of physical cores per CPU detected by the optimizer. (integer)

Values:
>=1
: Detected number of physical cores per CPU.
"""
global const XPRS_PHYSICALCORESPERCPUDETECTED = Int32(1262)
export XPRS_PHYSICALCORESPERCPUDETECTED

"""
    XPRS_PREDICTEDATTLEVEL
A measure between 0 and 1 to predict how numerically unstable the current MIP solve can be expected to be. (double)

After the root LP solve, a machine learning model is used to predict the actual ATTENTIONLEVEL which will only be computed if MIPKAPPAFREQ is set to a nonzero value. If the predicted attention level exceeds a value of 0.1, a message will be printed to the log.
"""
global const XPRS_PREDICTEDATTLEVEL = Int32(2105)
export XPRS_PREDICTEDATTLEVEL

"""
    XPRS_PRESOLVEINDEX
Presolve: The row or column index on which presolve detected a problem to be infeasible or unbounded. (integer)
"""
global const XPRS_PRESOLVEINDEX = Int32(1284)
export XPRS_PRESOLVEINDEX

"""
    XPRS_PRESOLVESTATE
Problem status as a bit map. (integer)

Values are a bitset:
bit 0
: Problem has been loaded.
bit 1
: Problem has been LP presolved.
bit 2
: Problem has been MIP presolved.
bit 7
: Solution in memory is valid.
"""
global const XPRS_PRESOLVESTATE = Int32(1026)
export XPRS_PRESOLVESTATE

"""
    XPRS_PRIMALDUALINTEGRAL
Value of the primal-dual integral. (double)
"""
global const XPRS_PRIMALDUALINTEGRAL = Int32(2079)
export XPRS_PRIMALDUALINTEGRAL

"""
    XPRS_PRIMALINFEAS
Number of primal infeasibilities. (integer)
"""
global const XPRS_PRIMALINFEAS = Int32(1007)
export XPRS_PRIMALINFEAS

"""
    XPRS_PWLCONS
Number of piecewise linear constraints in the problem. (integer)
"""
global const XPRS_PWLCONS = Int32(1325)
export XPRS_PWLCONS

"""
    XPRS_PWLPOINTS
Number of breakpoints of piecewise linear constraints in the problem. (integer)
"""
global const XPRS_PWLPOINTS = Int32(1326)
export XPRS_PWLPOINTS

"""
    XPRS_QCELEMS
Number of quadratic row coefficients in the matrix. (integer)
"""
global const XPRS_QCELEMS = Int32(1232)
export XPRS_QCELEMS

"""
    XPRS_QCONSTRAINTS
Number of rows with quadratic coefficients in the matrix. (integer)
"""
global const XPRS_QCONSTRAINTS = Int32(1234)
export XPRS_QCONSTRAINTS

"""
    XPRS_QELEMS
Number of quadratic non-zeros in the objective. (integer)
"""
global const XPRS_QELEMS = Int32(1030)
export XPRS_QELEMS

"""
    XPRS_RANGENAME
Active range name. (string)
"""
global const XPRS_RANGENAME = Int32(3005)
export XPRS_RANGENAME

"""
    XPRS_RESTARTS
Total number of restarts performed. (integer)
"""
global const XPRS_RESTARTS = Int32(1381)
export XPRS_RESTARTS

"""
    XPRS_RHSNAME
Active right hand side name. (string)
"""
global const XPRS_RHSNAME = Int32(3004)
export XPRS_RHSNAME

"""
    XPRS_ROWS
Number of rows (i.e. constraints) in the matrix. (integer)
"""
global const XPRS_ROWS = Int32(1001)
export XPRS_ROWS

"""
    XPRS_SETMEMBERS
Number of variables within special ordered sets (set members) in the matrix. (integer)
"""
global const XPRS_SETMEMBERS = Int32(1005)
export XPRS_SETMEMBERS

"""
    XPRS_SETS
Number of special ordered sets in the matrix. (integer)
"""
global const XPRS_SETS = Int32(1004)
export XPRS_SETS

"""
    XPRS_SIMPLEXITER
Number of simplex iterations performed. (integer)
"""
global const XPRS_SIMPLEXITER = Int32(1009)
export XPRS_SIMPLEXITER

global const XPRS_SLPCOEFFICIENTS = Int32(12016)
export XPRS_SLPCOEFFICIENTS

global const XPRS_SLPCURRENTDELTACOST = Int32(12701)
export XPRS_SLPCURRENTDELTACOST

global const XPRS_SLPCURRENTERRORCOST = Int32(12702)
export XPRS_SLPCURRENTERRORCOST

global const XPRS_SLPDELTAS = Int32(12041)
export XPRS_SLPDELTAS

global const XPRS_SLPECFCOUNT = Int32(12035)
export XPRS_SLPECFCOUNT

global const XPRS_SLPERRORCOSTS = Int32(12153)
export XPRS_SLPERRORCOSTS

global const XPRS_SLPITER = Int32(12001)
export XPRS_SLPITER

global const XPRS_SLPMINUSPENALTYERRORS = Int32(12020)
export XPRS_SLPMINUSPENALTYERRORS

global const XPRS_SLPMIPITER = Int32(12023)
export XPRS_SLPMIPITER

global const XPRS_SLPMIPNODES = Int32(12022)
export XPRS_SLPMIPNODES

global const XPRS_SLPMIPSOLS = Int32(12088)
export XPRS_SLPMIPSOLS

global const XPRS_SLPNONCONSTANTCOEFFS = Int32(12058)
export XPRS_SLPNONCONSTANTCOEFFS

global const XPRS_SLPPENALTYDELTACOLUMN = Int32(12010)
export XPRS_SLPPENALTYDELTACOLUMN

global const XPRS_SLPPENALTYDELTAROW = Int32(12009)
export XPRS_SLPPENALTYDELTAROW

global const XPRS_SLPPENALTYDELTAS = Int32(12017)
export XPRS_SLPPENALTYDELTAS

global const XPRS_SLPPENALTYDELTATOTAL = Int32(12706)
export XPRS_SLPPENALTYDELTATOTAL

global const XPRS_SLPPENALTYDELTAVALUE = Int32(12707)
export XPRS_SLPPENALTYDELTAVALUE

global const XPRS_SLPPENALTYERRORCOLUMN = Int32(12012)
export XPRS_SLPPENALTYERRORCOLUMN

global const XPRS_SLPPENALTYERRORROW = Int32(12011)
export XPRS_SLPPENALTYERRORROW

global const XPRS_SLPPENALTYERRORS = Int32(12018)
export XPRS_SLPPENALTYERRORS

global const XPRS_SLPPENALTYERRORTOTAL = Int32(12704)
export XPRS_SLPPENALTYERRORTOTAL

global const XPRS_SLPPENALTYERRORVALUE = Int32(12705)
export XPRS_SLPPENALTYERRORVALUE

global const XPRS_SLPPLUSPENALTYERRORS = Int32(12019)
export XPRS_SLPPLUSPENALTYERRORS

global const XPRS_SLPSBXCONVERGED = Int32(12004)
export XPRS_SLPSBXCONVERGED

global const XPRS_SLPSTATUS = Int32(12002)
export XPRS_SLPSTATUS

global const XPRS_SLPTOLSETS = Int32(12028)
export XPRS_SLPTOLSETS

global const XPRS_SLPUCCONSTRAINEDCOUNT = Int32(12021)
export XPRS_SLPUCCONSTRAINEDCOUNT

global const XPRS_SLPUNCONVERGED = Int32(12003)
export XPRS_SLPUNCONVERGED

global const XPRS_SLPZEROESRESET = Int32(12046)
export XPRS_SLPZEROESRESET

global const XPRS_SLPZEROESRETAINED = Int32(12048)
export XPRS_SLPZEROESRETAINED

global const XPRS_SLPZEROESTOTAL = Int32(12047)
export XPRS_SLPZEROESTOTAL

"""
    XPRS_SOLSTATUS
Status of the solution of the last problem solved with XPRSoptimize. (integer)

Values:
0
: `XPRS_SOLSTATUS_NOTFOUND` No solution available.
1
: `XPRS_SOLSTATUS_OPTIMAL` An optimal solution has been found.
2
: `XPRS_SOLSTATUS_FEASIBLE` A solution that is not proven optimal is found.
3
: `XPRS_SOLSTATUS_INFEASIBLE` No solution exists.
4
: `XPRS_SOLSTATUS_UNBOUNDED` The problem is unbounded, if feasible.
"""
global const XPRS_SOLSTATUS = Int32(1053)
export XPRS_SOLSTATUS

"""
    XPRS_SOLVEDOBJS
Number of objectives that have been solved so far during a multi-objective solve. (integer)
"""
global const XPRS_SOLVEDOBJS = Int32(1399)
export XPRS_SOLVEDOBJS

"""
    XPRS_SOLVESTATUS
Status of the solve of the last problem solved with XPRSoptimize. (integer)

Values:
0
: `XPRS_SOLVESTATUS_UNSTARTED` The solve has not been started.
1
: `XPRS_SOLVESTATUS_STOPPED` Optimization has been interrupted.
2
: `XPRS_SOLVESTATUS_FAILED` Optimization has run into a nonrecoverable problem and failed.
3
: `XPRS_SOLVESTATUS_COMPLETED` Search completed.
"""
global const XPRS_SOLVESTATUS = Int32(1394)
export XPRS_SOLVESTATUS

"""
    XPRS_SPARECOLS
Number of spare columns in the matrix. (integer)
"""
global const XPRS_SPARECOLS = Int32(1020)
export XPRS_SPARECOLS

"""
    XPRS_SPAREELEMS
Number of spare matrix elements in the matrix. (integer)
"""
global const XPRS_SPAREELEMS = Int32(1021)
export XPRS_SPAREELEMS

"""
    XPRS_SPAREMIPENTS
Number of spare MIP entities in the matrix. (integer)
"""
global const XPRS_SPAREMIPENTS = Int32(1022)
export XPRS_SPAREMIPENTS

"""
    XPRS_SPAREROWS
Number of spare rows in the matrix. (integer)
"""
global const XPRS_SPAREROWS = Int32(1019)
export XPRS_SPAREROWS

"""
    XPRS_SPARESETELEMS
Number of spare set elements in the matrix. (integer)
"""
global const XPRS_SPARESETELEMS = Int32(1204)
export XPRS_SPARESETELEMS

"""
    XPRS_SPARESETS
Number of spare sets in the matrix. (integer)
"""
global const XPRS_SPARESETS = Int32(1203)
export XPRS_SPARESETS

"""
    XPRS_STOPSTATUS
Status of the optimization process. (integer)
"""
global const XPRS_STOPSTATUS = Int32(1179)
export XPRS_STOPSTATUS

"""
    XPRS_SUMPRIMALINF
Scaled sum of primal infeasibilities. (double)
"""
global const XPRS_SUMPRIMALINF = Int32(2002)
export XPRS_SUMPRIMALINF

"""
    XPRS_SYSTEMMEMORY
The amount of non problem specific memory used by the solver. (integer)
"""
global const XPRS_SYSTEMMEMORY = Int32(1148)
export XPRS_SYSTEMMEMORY

"""
    XPRS_TIME
Time spent solving the problem as measured by the optimizer. (double)
"""
global const XPRS_TIME = Int32(1122)
export XPRS_TIME

"""
    XPRS_TOTALMEMORY
The amount of dynamically allocated heap memory by the optimizer, including all problems currently exsisting. (integer)
"""
global const XPRS_TOTALMEMORY = Int32(1322)
export XPRS_TOTALMEMORY

"""
    XPRS_TREECOMPLETION
Estimation of the relative completion of the search tree as fraction between 0 and 1. (double)

Its accuracy mainly depends on the level of degeneracy of a problem and the balancedness of the search tree.
"""
global const XPRS_TREECOMPLETION = Int32(2104)
export XPRS_TREECOMPLETION

"""
    XPRS_TREEFILESIZE
The allocated size of the tree file, in megabytes. (integer)

Because data can be removed from the tree file during the branch and bound search, the size of the tree file is usually greater than the amount of data currently within it (represented by the TREEFILEUSAGE attribute).
"""
global const XPRS_TREEFILESIZE = Int32(1252)
export XPRS_TREEFILESIZE

"""
    XPRS_TREEFILEUSAGE
The number of megabytes of data from the branch-and-bound tree that have been saved to the tree file. (integer)

Note that the actual allocated size of the tree file (represented by the TREEFILESIZE attribute) may be greater than this value.
"""
global const XPRS_TREEFILEUSAGE = Int32(1253)
export XPRS_TREEFILEUSAGE

"""
    XPRS_TREEMEMORYUSAGE
The amount of physical memory, in megabytes, currently being used to store the branch-and-bound search tree. (integer)
"""
global const XPRS_TREEMEMORYUSAGE = Int32(1251)
export XPRS_TREEMEMORYUSAGE

"""
    XPRS_TREERESTARTS
Number of in-tree restarts performed. (integer)
"""
global const XPRS_TREERESTARTS = Int32(1335)
export XPRS_TREERESTARTS

"""
    XPRS_UUID
Universally Unique Identifier for the problem instance. (string)
"""
global const XPRS_UUID = Int32(3011)
export XPRS_UUID

"""
    XPRS_XPRESSVERSION
The Xpress version number. (string)
"""
global const XPRS_XPRESSVERSION = Int32(3010)
export XPRS_XPRESSVERSION

"""
    XPRS_ALGAFTERCROSSOVER
The algorithm to be used for the final clean up step after the crossover. (integer)

Default value: `1`

Values:
1
: Automatically determined.
2
: Dual simplex.
3
: Primal simplex.
4
: Concurrent.
"""
global const XPRS_ALGAFTERCROSSOVER = Int32(8208)
export XPRS_ALGAFTERCROSSOVER

"""
    XPRS_ALGAFTERNETWORK
The algorithm to be used for the clean up step after the network simplex solver. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
2
: Dual simplex.
3
: Primal simplex.
"""
global const XPRS_ALGAFTERNETWORK = Int32(8129)
export XPRS_ALGAFTERNETWORK

"""
    XPRS_ALTERNATIVEREDCOSTS
Controls aggressiveness of searching for alternative reduced cost (integer)

Default value: `-1`

Values:
-1
: The solver decides if searching for alternative reduced cost is beneficial or not. This is the default setting.
0
: Searching for alternative reduced cost is disabled.
1
: Searching for alternative reduced cost is enabled.
"""
global const XPRS_ALTERNATIVEREDCOSTS = Int32(8478)
export XPRS_ALTERNATIVEREDCOSTS

"""
    XPRS_AUTOCUTTING
Should the Optimizer automatically decide whether to generate cutting planes at local nodes in the tree or not? If the `CUTFREQ` control is set, no automatic selection will be made and local cutting will be enabled. (integer)

Default value: -1

Values:
-1
: Automatic.
0
: Disabled.
1
: Enabled.
"""
global const XPRS_AUTOCUTTING = Int32(8446)
export XPRS_AUTOCUTTING

"""
    XPRS_AUTOPERTURB
Simplex: This indicates whether automatic perturbation is performed. (integer)

If this is set to `1`, the problem will be perturbed whenever the simplex method encounters an excessive number of degenerate pivot steps, thus preventing the Optimizer being hindered by degeneracies.

Default value: `1`

Values:
0
: No perturbation performed.
1
: Automatic perturbation is performed.
"""
global const XPRS_AUTOPERTURB = Int32(8084)
export XPRS_AUTOPERTURB

"""
    XPRS_AUTOSCALING
Whether the Optimizer should automatically select between different scaling algorithms. (integer)

If the `SCALING` control is set, no automatic scaling will be applied.

Default value: -1

Values:
-1
: Automatic.
0
: Disabled.
1
: Cautious strategy. Non-standard scaling will only be selected if it appears to be clearly superior.
2
: Moderate strategy.
3
: Aggressive strategy. Standard scaling will only be selected if it appears to be clearly superior.
"""
global const XPRS_AUTOSCALING = Int32(8406)
export XPRS_AUTOSCALING

"""
    XPRS_BACKGROUNDMAXTHREADS
Limit the number of threads to use in background jobs (for example in parallel to the root cut loop). (integer)

Default value: -1, let Xpress decide.

Domain: [-1,+INF]
"""
global const XPRS_BACKGROUNDMAXTHREADS = Int32(8461)
export XPRS_BACKGROUNDMAXTHREADS

"""
    XPRS_BACKGROUNDSELECT
Select which tasks to run in background jobs (for example in parallel to the root cut loop). (integer)

Default value: -1

Values are a bitset:
bit 0
: Feasibility jump heuristic.
bit 1
: Fast branch-and-bound heuristic.
bit 2
: Same as bit 1 but with some additional heuristics enabled.
bit 3
: Fix-propagate-repair heuristic.
"""
global const XPRS_BACKGROUNDSELECT = Int32(8463)
export XPRS_BACKGROUNDSELECT

"""
    XPRS_BACKTRACK
Branch and Bound: Specifies how to select the next node to work on when a full backtrack is performed. (integer)

Default value: `3`

Values:
-1
: Automatically determined.
1
: Unused.
2
: Select the node with the best estimated solution.
3
: Select the node with the best bound on the solution.
4
: Select the deepest node in the search tree (equivalent to depth-first search).
5
: Select the highest node in the search tree (equivalent to breadth-first search).
6
: Select the earliest node created.
7
: Select the latest node created.
8
: Select a node randomly.
9
: Select the node whose LP relaxation contains the fewest number of infeasible MIP entities.
10
: Combination of 2 and 9.
11
: Combination of 2 and 4.
12
: Combination of 3 and 4.
"""
global const XPRS_BACKTRACK = Int32(8027)
export XPRS_BACKTRACK

"""
    XPRS_BACKTRACKTIE
Branch and Bound: Specifies how to break ties when selecting the next node to work on when a full backtrack is performed. (integer)

The options are the same as for the BACKTRACK control.

Default value: `-1`

Values:
-1
: Default selection.
1
: Unused.
2
: Select the node with the best estimated solution.
3
: Select the node with the best bound on the solution.
4
: Select the deepest node in the search tree (equivalent to depth-first search).
5
: Select the highest node in the search tree (equivalent to breadth-first search).
6
: Select the earliest node created.
7
: Select the latest node created.
8
: Select a node randomly.
9
: Select the node whose LP relaxation contains the fewest number of infeasible MIP entities.
10
: Combination of 2 and 9.
11
: Combination of 2 and 4.
12
: Combination of 3 and 4.
"""
global const XPRS_BACKTRACKTIE = Int32(8266)
export XPRS_BACKTRACKTIE

"""
    XPRS_BARALG
This control determines which barrier algorithm is used to solve the problem. (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: Unused.
1
: Use the infeasible-start barrier algorithm.
2
: Use the homogeneous self-dual barrier algorithm.
3
: Start with 2 and optionally switch to 1 during the execution.
4
: Use the hybrid gradient algorithm.
"""
global const XPRS_BARALG = Int32(8315)
export XPRS_BARALG

"""
    XPRS_BARCORES
If set to a positive integer it determines the number of physical CPU cores assumed to be present in the system by the barrier and hybrid gradient algorithms. (integer)

If the value is set to the default value (`-1`), Xpress will automatically detect the number of cores.

Default value: `-1`(automatically detected)

Domain: -1~+INF
"""
global const XPRS_BARCORES = Int32(8202)
export XPRS_BARCORES

"""
    XPRS_BARCRASH
Newton barrier and hybrid gradient: This determines the type of crash used for the crossover. (integer)

During the crash procedure, an initial basis is determined which attempts to speed up the crossover. A good choice at this stage will significantly reduce the number of iterations required to crossover to an optimal solution. The possible values increase proportionally to their time-consumption.

Default value: `4`

Values:
0
: Turns off all crash procedures.
1-6
: Available strategies with 1 being conservative and 6 being aggressive.
"""
global const XPRS_BARCRASH = Int32(8211)
export XPRS_BARCRASH

"""
    XPRS_BARDUALSTOP
Newton barrier and hybrid gradient: This is a convergence parameter, representing the tolerance for dual infeasibilities. (double)

If the difference between the constraints and their bounds in the dual problem falls below this tolerance in absolute value, optimization will stop and the current solution will be returned.

Default value: `0`

Values:
0
: The default value is determined automatically based on the problem size, structure and algorithm choice.
>=0
: The tolerance for dual infeasibilities.
"""
global const XPRS_BARDUALSTOP = Int32(7034)
export XPRS_BARDUALSTOP

"""
    XPRS_BARFAILITERLIMIT
Newton barrier: The maximum number of consecutive iterations that fail to improve the solution in the barrier algorithm. (integer)

Default value: `0`

Values:
0
: Determined automatically
>0
: Maximum number of consecutive barrier iterations allowed without progress.
"""
global const XPRS_BARFAILITERLIMIT = Int32(8398)
export XPRS_BARFAILITERLIMIT

"""
    XPRS_BARFREESCALE
Defines how the barrier algorithm scales free variables. (double)

Default value: `1e-6`

Domain: -1,[0,1]
"""
global const XPRS_BARFREESCALE = Int32(7077)
export XPRS_BARFREESCALE

"""
    XPRS_BARGAPSTOP
Newton barrier and hybrid gradient: This is a convergence parameter, representing the tolerance for the relative duality gap. (double)

When the difference between the primal and dual objective function values falls below this tolerance, the Optimizer determines that the optimal solution has been found.

Default value: `0`

Values:
0
: The default value is determined automatically based on the problem size, structure and algorithm choice.
>=0
: The tolerance for the relative duality gap.
"""
global const XPRS_BARGAPSTOP = Int32(7033)
export XPRS_BARGAPSTOP

"""
    XPRS_BARGAPTARGET
Newton barrier: The target tolerance for the relative duality gap. (double)

The barrier algorithm will keep iterating until either `BARGAPTARGET` is satisfied or until no further improvements are possible. In the latter case, if BARGAPSTOP is satisfied, it will declare the problem optimal.

Default value: `0`

Values:
0
: The default value is determined automatically based on the problem size, structure and algorithm choice.
>=0
: The target tolerance for the relative duality gap.
"""
global const XPRS_BARGAPTARGET = Int32(7073)
export XPRS_BARGAPTARGET

"""
    XPRS_BARHGEXTRAPOLATE
Extrapolation parameter for the hybrid gradient algorithm. (double)

Although theory suggests that a value of 1 is best, slightly smaller values perform better in general.

Default value: `0.99`

Domain: [0,1]
"""
global const XPRS_BARHGEXTRAPOLATE = Int32(7166)
export XPRS_BARHGEXTRAPOLATE

"""
    XPRS_BARHGMAXRESTARTS
The maximum number of restarts in the hybrid gradient algorithm. (integer)

Restarts play the role of iterations in the hybrid gradient algorithm. A log line is printed at every restart, unless BAROUTPUT is set to 0.

Default value: `500`

Domain: [0,+INF]
"""
global const XPRS_BARHGMAXRESTARTS = Int32(8484)
export XPRS_BARHGMAXRESTARTS

"""
    XPRS_BARHGOPS
Control options for the hybrid gradient algorithm. (integer)

Bits 1, 2 and 3 control which norms of the coefficient matrix are used for solution normalization. The normalization factor is the maximum of the selected norms. By default, or if all three bits are set to 0, the infinity norm is used. The omega parameter referenced in bits 4, 5 and 6 is a measure of the relative magnitudes of the objective and the right-hand side.

Default value: `8`, only the infinity norm is used for normalization, the other options are all off.

Values are a bitset:
bit 0
: Use an asymmetric average for the primal averaging.
bit 1
: Use the 1-norm of the coefficient matrix in normalizing the initial solution.
bit 2
: Use the 2-norm of the coefficient matrix in normalizing the initial solution.
bit 3
: Use the infinity norm of the coefficient matrix in normalizing the initial solution.
bit 4
: Take the square root of omega.
bit 5
: Contract omega towards 1 if the infeasibility is small enough.
bit 6
: Omega is based on the infeasibility.
"""
global const XPRS_BARHGOPS = Int32(8483)
export XPRS_BARHGOPS

"""
    XPRS_BARINDEFLIMIT
Newton Barrier. (integer)

This limits the number of consecutive indefinite barrier iterations that will be performed. The optimizer will try to minimize (resp. maximize) a QP problem even if the Q matrix is not positive (resp. negative) semi-definite. However, the optimizer may detect that the Q matrix is indefinite and this can result in the optimizer not converging. This control specifies how many indefinite iterations may occur before the optimizer stops and reports that the problem is indefinite. It is usual to specify a value greater than one, and only stop after a series of indefinite matrices, as the problem may be found to be indefinite incorrectly on a few iterations for numerical reasons.

Default value: `15`

Domain: 0~+INF
"""
global const XPRS_BARINDEFLIMIT = Int32(8153)
export XPRS_BARINDEFLIMIT

"""
    XPRS_BARITERLIMIT
Newton barrier: The maximum number of iterations. (integer)

While the simplex method usually performs a number of iterations which is proportional to the number of constraints (rows) in a problem, the barrier method standardly finds the optimal solution to a given accuracy after a number of iterations which is independent of the problem size. The penalty is rather that the time for each iteration increases with the size of the problem. `BARITERLIMIT` specifies the maximum number of iterations which will be carried out by the barrier.

Default value: `500`

Domain: 0~+INF
"""
global const XPRS_BARITERLIMIT = Int32(8045)
export XPRS_BARITERLIMIT

"""
    XPRS_BARKERNEL
Newton barrier: Defines how centrality is weighted in the barrier algorithm. (double)

Default value: `0.0`

Values:
>=+1.0
: Increases the emphasis on centrality when larger value is set.
<=-1.0
: Selects a value adaptively in every iteration from [+1, -BARKERNEL].
"""
global const XPRS_BARKERNEL = Int32(7130)
export XPRS_BARKERNEL

"""
    XPRS_BARLARGEBOUND
Threshold for the barrier to handle large bounds. (double)

Default value: `0`

Domain: [0,+INF]
"""
global const XPRS_BARLARGEBOUND = Int32(7067)
export XPRS_BARLARGEBOUND

global const XPRS_BARNUMSTABILITY = Int32(8186)
export XPRS_BARNUMSTABILITY

"""
    XPRS_BAROBJPERTURB
Defines how the barrier perturbs the objective. (double)

Default value: `1e-6`

Values:
>0
: Let the optimizer decide if the objective is perturbed or not and use the parameter value as the scale of the perturbation.
0
: Turn off objective perturbation.
<0
: Always perturb the objective by the absolute value of the parameter.
"""
global const XPRS_BAROBJPERTURB = Int32(7146)
export XPRS_BAROBJPERTURB

"""
    XPRS_BAROBJSCALE
Defines how the barrier scales the objective. (double)

Default value: `-1`

Values:
-1
: Let the optimizer decide.
0
: Scale by geometric mean.
>=0
: Scale such that the largest objective coefficient's largest element does not exceed this number. In quadratic problems, the quadratic diagonal is used as reference valuses instead of the linear objective.
"""
global const XPRS_BAROBJSCALE = Int32(7026)
export XPRS_BAROBJSCALE

"""
    XPRS_BARORDER
Newton barrier: This controls the Cholesky factorization in the Newton-Barrier. (integer)

Default value: `0`

Values:
0
: Choose automatically.
1
: Minimum degree method. This selects diagonal elements with the smallest number of nonzeros in their rows or columns.
2
: Minimum local fill method. This considers the adjacency graph of nonzeros in the matrix and seeks to eliminate nodes that minimize the creation of new edges.
3
: Nested dissection method. This considers the adjacency graph and recursively seeks to separate it into non-adjacent pieces.
"""
global const XPRS_BARORDER = Int32(8080)
export XPRS_BARORDER

"""
    XPRS_BARORDERTHREADS
If set to a positive integer it determines the number of concurrent threads for the sparse matrix ordering algorithm in the Newton-barrier method. (integer)

Default value: `0`

Values:
0
: The default value is determined automatically based on the problem size, structure and algorithm choice.
>=0
: The number of concurrent threads for the sparse matrix ordering algorithm in the Newton-barrier method.
"""
global const XPRS_BARORDERTHREADS = Int32(8187)
export XPRS_BARORDERTHREADS

"""
    XPRS_BAROUTPUT
Newton barrier and hybrid gradient: This specifies the level of solution output provided. (integer)

Output is provided either after each iteration of the algorithm, or else can be turned off completely by this parameter.

Default value: `1`

Values:
0
: No output.
1
: At each iteration.
"""
global const XPRS_BAROUTPUT = Int32(8047)
export XPRS_BAROUTPUT

"""
    XPRS_BARPERTURB
Newton barrier: In numerically challenging cases it is often advantageous to apply perturbations on the KKT system to improve its numerical properties. (double)

`BARPERTURB` controlls how much perturbation is allowed during the barrier iterations. By default no perturbation is allowed. Set this parameter with care as larger perturbations may lead to less efficient iterates and the best settings are problem-dependent.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_BARPERTURB = Int32(7011)
export XPRS_BARPERTURB

"""
    XPRS_BARPRESOLVEOPS
Newton barrier: This controls the Newton-Barrier specific presolve operations. (integer)

Default value: `0`

Values are a bitset:
bit 0
: Use standard presolve.
bit 1
: Extra effort is spent in barrier specific presolve.
bit 2
: Do full matrix eliminations (reduce matrix size).
"""
global const XPRS_BARPRESOLVEOPS = Int32(8286)
export XPRS_BARPRESOLVEOPS

"""
    XPRS_BARPRIMALSTOP
Newton barrier and hybrid gradient: This is a convergence parameter, indicating the tolerance for primal infeasibilities. (double)

If the difference between the constraints and their bounds in the primal problem falls below this tolerance in absolute value, the Optimizer will terminate and return the current solution.

Default value: `0`

Values:
0
: The default value is determined automatically based on the problem size, structure and algorithm choice.
>=0
: The tolerance for primal infeasibilities.
"""
global const XPRS_BARPRIMALSTOP = Int32(7035)
export XPRS_BARPRIMALSTOP

"""
    XPRS_BARREFITER
Newton barrier: After terminating the barrier algorithm, further refinement steps can be performed. (integer)

Such refinement steps are especially helpful if the solution is near to the optimum and can improve primal feasibility and decrease the complementarity gap. It is also often advantageous for the crossover algorithm. `BARREFITER` specifies the maximum number of such refinement iterations.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_BARREFITER = Int32(8431)
export XPRS_BARREFITER

"""
    XPRS_BARREGULARIZE
This control determines how the barrier algorithm applies regularization on the KKT system. (integer)

Default value: `-1`

Values are a bitset:
bit 0
: Standard regularization is turned on/off.
bit 1
: Reduced regularization is turned on/off. This option reduces the perturbation effect of the standard regularization.
bit 2
: Forces to keep dependent rows in the KKT system.
bit 3
: Forces to preserve degenerate rows in the KKT system.
bit 4
: Restrict regularization to infeasible iterates.
bit 5
: Disable iterative regularizations.
bit 6
: Apply iterative regularization more often.
"""
global const XPRS_BARREGULARIZE = Int32(8163)
export XPRS_BARREGULARIZE

"""
    XPRS_BARRHSSCALE
Defines how the barrier scales the right hand side. (double)

Default value: `-1`

Values:
-1
: Let the optimizer decide.
0
: Scale by geometric mean.
>=0
: Scale such that the largest right hand side coefficient's largest element does not exceed this number.
"""
global const XPRS_BARRHSSCALE = Int32(7027)
export XPRS_BARRHSSCALE

"""
    XPRS_BARSOLUTION
This determines whether the barrier has to decide which is the best solution found or return the solution computed by the last barrier iteration. (integer)

Default value: `0`

Values:
-1
: (callback only: do not save current soulution as the best one).
0
: return the best solution found (in callback: let the barrier decide the current solution is the best or not).
1
: return the last barrier iteration (in callback: save current solution as the best solution so far).
"""
global const XPRS_BARSOLUTION = Int32(8038)
export XPRS_BARSOLUTION

"""
    XPRS_BARSTART
Controls the computation of the starting point and warm-starting for the Newton barrier and the hybrid gradient algorithms. (integer)

Default value: 0

Values:
-1
: Uses the existing solution for warm-start if one is available.
0
: Warm-start is disabled; the starting point is determined automatically from the next three options.
1
: Uses simple heuristics to compute the starting point based on the magnitudes of the matrix entries.
2
: Uses the pseudoinverse of the constraint matrix to determine primal and dual initial solutions. Less sensitive to scaling and numerically more robust, but in several case less efficient than 1.
3
: Uses the unit starting point for the homogeneous self-dual barrier algorithm.
"""
global const XPRS_BARSTART = Int32(8180)
export XPRS_BARSTART

"""
    XPRS_BARSTARTWEIGHT
Newton barrier: This sets a weight for the warm-start point when warm-start is set for the barrier algorithm. (double)

Using larger weight gives more emphasis for the supplied starting point.

Default value: 0.85

Domain: [0,1]
"""
global const XPRS_BARSTARTWEIGHT = Int32(7076)
export XPRS_BARSTARTWEIGHT

"""
    XPRS_BARSTEPSTOP
Newton barrier: A convergence parameter, representing the minimal step size. (double)

On each iteration of the barrier algorithm, a step is taken along a computed search direction. If that step size is smaller than `BARSTEPSTOP`, the Optimizer will terminate and return the current solution.

Default value: `1.0E-16`

Domain: [-INF,+INF]
"""
global const XPRS_BARSTEPSTOP = Int32(7036)
export XPRS_BARSTEPSTOP

"""
    XPRS_BARTHREADS
If set to a positive integer it determines the number of threads implemented to run the Newton-barrier and hybrid gradient algorithms. (integer)

If the value is set to the default value (`-1`), the THREADS control will determine the number of threads used.

Default value: `-1`(determined by the `THREADS` control)

Domain: 0~+INF
"""
global const XPRS_BARTHREADS = Int32(8053)
export XPRS_BARTHREADS

"""
    XPRS_BIGM
The infeasibility penalty used if the "Big M" method is implemented. (double)

Default value: Dependent on the matrix characteristics.

Domain: [-INF,+INF]
"""
global const XPRS_BIGM = Int32(7018)
export XPRS_BIGM

"""
    XPRS_BIGMMETHOD
Simplex: This specifies whether to use the "Big M" method, or the standard phase I (achieving feasibility) and phase II (achieving optimality). (integer)

In the "Big M" method, the objective coefficients of the variables are considered during the feasibility phase, possibly leading to an initial feasible basis which is closer to optimal. The side-effects involve possible round-off errors due to the presence of the "Big M" factor in the problem.

Default value: `1`

Values:
0
: For phase I / phase II.
1
: If "Big M" method to be used.
"""
global const XPRS_BIGMMETHOD = Int32(8068)
export XPRS_BIGMMETHOD

"""
    XPRS_BRANCHCHOICE
Once a MIP entity has been selected for branching, this control determines which of the branches is solved first. (integer)

Default value: `0`

Values:
0
: Minimum estimate branch first.
1
: Maximum estimate branch first.
2
: If an incumbent solution exists, solve the branch satisfied by that solution first. Otherwise solve the minimum estimate branch first (option 0).
3
: Solve first the branch that forces the value of the branching variable to move farther away from the value it had at the root node. If the branching entity is not a simple variable, solve the minimum estimate branch first (option 0).
"""
global const XPRS_BRANCHCHOICE = Int32(8162)
export XPRS_BRANCHCHOICE

"""
    XPRS_BRANCHDISJ
Branch and Bound: Determines whether the optimizer should attempt to branch on general split disjunctions during the branch and bound search. (integer)

Default value: -1

Values:
-1
: Automatic selection of the strategy.
0
: Disabled.
1
: Cautious strategy. Disjunctive branches will be created only for general integers with a wide range.
2
: Moderate strategy.
3
: Aggressive strategy. Disjunctive branches will be created for both binaries and integers.
"""
global const XPRS_BRANCHDISJ = Int32(8267)
export XPRS_BRANCHDISJ

"""
    XPRS_BRANCHSTRUCTURAL
Branch and Bound: Determines whether the optimizer should search for special structure in the problem to branch on during the branch and bound search. (integer)

Default value: -1

Values:
-1
: Automatically determined.
0
: Disabled.
1
: Enabled.
"""
global const XPRS_BRANCHSTRUCTURAL = Int32(8282)
export XPRS_BRANCHSTRUCTURAL

"""
    XPRS_BREADTHFIRST
The number of nodes to include in the best-first search before switching to the local first search (NODESELECTION `=` `4`). (integer)

Default value: `11`

Domain: 0~+INF
"""
global const XPRS_BREADTHFIRST = Int32(8082)
export XPRS_BREADTHFIRST

"""
    XPRS_CACHESIZE
**Deprecated**Newton Barrier: L2 or L3 (see notes) cache size in kB (kilobytes) of the CPU. (integer)

On Intel (or compatible) platforms a value of `-1` may be used to determine the cache size automatically. If the CPU model is new then the cache size may not be correctly detected by an older release of the software.

Default value: -1

Domain: -1,0~+INF
"""
global const XPRS_CACHESIZE = Int32(8043)
export XPRS_CACHESIZE

"""
    XPRS_CALLBACKCHECKTIMEDELAY
Minimum delay in milliseconds between two consecutive executions of the CHECKTIME callback in the same solution process (integer)

Default value: `0`

Values:
0
: Callback delay is disabled - the callback is executed every time;
n>0
: Callback invocation is suppressed if less than n milliseconds have passed since the last invocation.
"""
global const XPRS_CALLBACKCHECKTIMEDELAY = Int32(8451)
export XPRS_CALLBACKCHECKTIMEDELAY

"""
    XPRS_CALLBACKFROMMASTERTHREAD
Branch and Bound: specifies whether the MIP callbacks should only be called on the master thread. (integer)

Default value: `0`

Values:
0
: Invoke callbacks on worker threads during parallel MIP;
1
: Only ever invoke a callback on the thread that called `XPRSmipoptimize`.
"""
global const XPRS_CALLBACKFROMMASTERTHREAD = Int32(8090)
export XPRS_CALLBACKFROMMASTERTHREAD

"""
    XPRS_CHECKINPUTDATA
Check input arrays for bad data. (integer)

Default value: `1 (on)`

Values:
0
: Do not check.
1
: Check input arrays.
"""
global const XPRS_CHECKINPUTDATA = Int32(8436)
export XPRS_CHECKINPUTDATA

"""
    XPRS_CHOLESKYALG
Newton barrier: type of Cholesky factorization used. (integer)

Default value: `-1 (automatic)`

Values are a bitset:
bit 0
: matrix blocking: 0: automatic setting; 1: manual setting.
bit 1
: if manual selection of matrix blocking: 0: multi-pass; 1: single-pass.
bit 2
: nonseparable QP relaxation: 0: off; 1: on.
bit 3
: corrector weight: 0: automatic setting; 1: manual setting.
bit 4
: if manual selection of corrector weight: 0: off; 1: on.
bit 5
: refinement: 0: automatic setting; 1: manual setting.
bit 6
: preconditioned conjugate gradient method (PCGM): 0: PCGM off; 1: PCGM on.
bit 7
: Preconditioned quasi minimal residual (QMR) to refine solution: 0: QMR off; 1: QMR on.
bit 8
: Perform refinement on the augmented system 0: off; 1: on.
bit 9
: Force highest accuracy in refinement 0: off; 1: on.
"""
global const XPRS_CHOLESKYALG = Int32(8046)
export XPRS_CHOLESKYALG

"""
    XPRS_CHOLESKYTOL
Newton barrier: The tolerance for pivot elements in the Cholesky decomposition of the normal equations coefficient matrix, computed at each iteration of the barrier algorithm. (double)

If the absolute value of the pivot element is less than or equal to `CHOLESKYTOL`, it merits special treatment in the Cholesky decomposition process.

Default value: `1.0E-15`

Domain: [-INF,+INF]
"""
global const XPRS_CHOLESKYTOL = Int32(7032)
export XPRS_CHOLESKYTOL

"""
    XPRS_CLAMPING
This control allows for the adjustment of returned solution values such that they are always within bounds. (integer)

Default value: `0`

Values are a bitset:
bit -1
: Determined automatically.
bit 0
: Adjust primal solution to always be within primal bounds. Slacks if provided will be adjusted accordingly.
bit 1
: Adjust primal slack values to always be within constraint bounds.
bit 2
: Adjust dual solution to always be within the dual bounds implied by the slacks. Reduced costs, if provided, will be adjusted accordingly.
bit 3
: Adjust reduced costs to always be within dual bounds implied by the primal solution.
"""
global const XPRS_CLAMPING = Int32(8301)
export XPRS_CLAMPING

"""
    XPRS_COMPUTE
Controls whether the next solve is performed directly or on an Insight Compute Interface. (integer)

Default value: Depends on environment

Values:
0
: Solve locally.
1
: Solve using an Insight Compute Interface.
"""
global const XPRS_COMPUTE = Int32(8411)
export XPRS_COMPUTE

"""
    XPRS_COMPUTEEXECSERVICE
Selects the Insight execution service that will be used for solving remote optimizations. (string)

Default value: Empty string

Domain: ?
"""
global const XPRS_COMPUTEEXECSERVICE = Int32(6022)
export XPRS_COMPUTEEXECSERVICE

"""
    XPRS_COMPUTEJOBPRIORITY
Selects the priority that will be used for remote optimization jobs. (integer)

Default value: 0

Domain: -100~100
"""
global const XPRS_COMPUTEJOBPRIORITY = Int32(8409)
export XPRS_COMPUTEJOBPRIORITY

"""
    XPRS_COMPUTELOG
Controls how the run log is fetched when a solve is performed on an Insight Compute Interface. (integer)

Default value: 1

Values:
0
: Run log will not be fetched
1
: Run log will be fetched in real-time
2
: Run log will be fetched at the end of the solve
3
: Run log will be fetched at the end of the solve if the solve fails with an error
"""
global const XPRS_COMPUTELOG = Int32(8434)
export XPRS_COMPUTELOG

"""
    XPRS_CONCURRENTTHREADS
Determines the number of threads used by the concurrent solver. (integer)

Default value: `-1`

Values:
-1
: Determined automatically
>0
: Number of threads to use.
"""
global const XPRS_CONCURRENTTHREADS = Int32(8274)
export XPRS_CONCURRENTTHREADS

"""
    XPRS_CONFLICTCUTS
Branch and Bound: Specifies how cautious or aggressive the optimizer should be when searching for and applying conflict cuts. (integer)

Conflict cuts are in-tree cuts derived from nodes found to be infeasible or cut off, which can be used to cut off other branches of the search tree.

Default value: `-1`

Values:
-1
: Automatic.
0
: Disable conflict cuts.
1
: Cautious application of conflict cuts.
2
: Medium application of conflict cuts.
3
: Aggressive application of conflict cuts.
"""
global const XPRS_CONFLICTCUTS = Int32(8292)
export XPRS_CONFLICTCUTS

"""
    XPRS_CORESPERCPU
Used to override the detected value of the number of cores on a CPU. (integer)

The cache size (either detected or specified via the CACHESIZE control) used in Barrier methods will be divided by this amount, and this scaled-down value will be the amount of cache allocated to each Barrier thread

Default value: `-1`

Domain: -1~+INF
"""
global const XPRS_CORESPERCPU = Int32(8296)
export XPRS_CORESPERCPU

"""
    XPRS_COVERCUTS
Branch and Bound: The number of rounds of lifted cover inequalities at the top node. (integer)

A lifted cover inequality is an additional constraint that can be particularly effective at reducing the size of the feasible region without removing potential integral solutions. The process of generating these can be carried out a number of times, further reducing the feasible region, albeit incurring a time penalty. There is usually a good payoff from generating these at the top node, since these inequalities then apply to every subsequent node in the tree search.

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_COVERCUTS = Int32(8134)
export XPRS_COVERCUTS

"""
    XPRS_CPIALPHA
decay term for confined primal integral computation. (double)

Default value: `0`

Domain: [0,1]
"""
global const XPRS_CPIALPHA = Int32(7149)
export XPRS_CPIALPHA

"""
    XPRS_CPUPLATFORM
Newton Barrier: Selects the AMD, Intel x86 or ARM vectorization instruction set that Barrier should run optimized code for. (integer)

On AMD / Intel x86 platforms the SSE2, AVX and AVX2 instruction sets are supported while on ARM platforms the NEON architecture extension can be activated.

Default value: `-2`, using AVX2 instructions if supported by the CPU

Values:
-2
: Highest supported [Generic, SSE2, AVX or AVX2].
-1
: Highest supported solve path consistent code [Generic, SSE2 or AVX].
0
: Use generic code compatible with all CPUs.
1
: Use SSE2 / NEON optimized code.
2
: Use AVX optimized code.
3
: Use AVX2 optimized code.
"""
global const XPRS_CPUPLATFORM = Int32(8312)
export XPRS_CPUPLATFORM

"""
    XPRS_CPUTIME
How time should be measured when timings are reported in the log and when checking against time limits (integer)

Default value: `0`

Values:
-1
: Disable the timer.
0
: Use elapsed time.
1
: Use process time.
"""
global const XPRS_CPUTIME = Int32(8133)
export XPRS_CPUTIME

"""
    XPRS_CRASH
Simplex: This determines the type of crash used when the algorithm begins. (integer)

During the crash procedure, an initial basis is determined which is as close to feasibility and triangularity as possible. A good choice at this stage will significantly reduce the number of iterations required to find an optimal solution. The possible values increase proportionally to their time-consumption.

Default value: `2`

Values are a bitset:
bit 0
: Perform standard crash.
bit 1
: Perform additional numerical checks during crash.
bit 2
: Extend the set of column candidates for crash.
bit 3
: Extend the set of row candidates for crash.
bit 4
: Force crash, i.e., consider all suitable columns/rows as candidates for crash.
"""
global const XPRS_CRASH = Int32(8012)
export XPRS_CRASH

"""
    XPRS_CROSSOVER
Newton barrier and hybrid gradient: This control determines whether the barrier method will cross over to the simplex method when at optimal solution has been found, to provide an end basis (see XPRSgetbasis, XPRSwritebasis) and advanced sensitivity analysis information (see XPRSobjsa, XPRSrhssa, XPRSbndsa). (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: No crossover.
1
: Primal crossover first.
2
: Dual crossover first.
"""
global const XPRS_CROSSOVER = Int32(8044)
export XPRS_CROSSOVER

"""
    XPRS_CROSSOVERACCURACYTOL
Newton barrier: This control determines how crossover adjusts the default relative pivot tolerance. (double)

When re-inversion is necessary, crossover will compare the recalculated working basic solution with the assumed ones just before re-inversion took place. If the error is above this threshold, crossover will adjust the relative pivot tolerance to address the build-up of numerical inaccuracies.

Default value: `1e-6`

Domain: ?
"""
global const XPRS_CROSSOVERACCURACYTOL = Int32(7023)
export XPRS_CROSSOVERACCURACYTOL

global const XPRS_CROSSOVERDRP = Int32(8227)
export XPRS_CROSSOVERDRP

global const XPRS_CROSSOVERFEASWEIGHT = Int32(7133)
export XPRS_CROSSOVERFEASWEIGHT

"""
    XPRS_CROSSOVERITERLIMIT
Newton barrier and hybrid gradient: The maximum number of iterations that will be performed in the crossover procedure before the optimization process terminates. (integer)

Default value: `2147483647`

Domain: 0~+INF
"""
global const XPRS_CROSSOVERITERLIMIT = Int32(8104)
export XPRS_CROSSOVERITERLIMIT

"""
    XPRS_CROSSOVEROPS
Newton barrier and hybrid gradient: a bit vector for adjusting the behavior of the crossover procedure. (integer)

Default value: `0`

Values are a bitset:
bit 0
: Returned solution when the crossover terminates prematurely: 0: Return the last basis from the crossover; 1: Return the barrier solution.
bit 1
: Select the crossover stages to be performed: 0: Perform both crossover stages; 1: Skip second crossover stage.
bit 2
: Set crossover behaviour: 0: Force to perform all pivots; 1: Skip pivots that are numerically less reliable.
bit 3
: Set crossover behaviour: 0: Perform standard crossover; 1: Perform a slower, but numerically more careful crossover.
"""
global const XPRS_CROSSOVEROPS = Int32(8060)
export XPRS_CROSSOVEROPS

global const XPRS_CROSSOVERRELPIVOTTOL = Int32(7113)
export XPRS_CROSSOVERRELPIVOTTOL

global const XPRS_CROSSOVERRELPIVOTTOLSAFE = Int32(7114)
export XPRS_CROSSOVERRELPIVOTTOLSAFE

"""
    XPRS_CROSSOVERTHREADS
Determines the maximum number of threads that parallel crossover is allowed to use. (integer)

If `CROSSOVERTHREADS` is set to the default value (`-1`), the BARTHREADS control will determine the number of threads used.

Default value: `-1` (determined by the `BARTHREADS` control)

Domain: -1,0~+INF
"""
global const XPRS_CROSSOVERTHREADS = Int32(8065)
export XPRS_CROSSOVERTHREADS

"""
    XPRS_CUTDEPTH
Branch and Bound: Sets the maximum depth in the tree search at which cuts will be generated. (integer)

Generating cuts can take a lot of time, and is often less important at deeper levels of the tree since tighter bounds on the variables have already reduced the feasible region. A value of `0` signifies that no cuts will be generated.

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_CUTDEPTH = Int32(8139)
export XPRS_CUTDEPTH

"""
    XPRS_CUTFACTOR
Limit on the number of cuts and cut coefficients the optimizer is allowed to add to the matrix during tree search. (double)

The cuts and cut coefficients are limited by `CUTFACTOR` times the number of rows and coefficients in the initial matrix.

Default value: `-1`

Values:
-1
: Let the optimizer decide on the maximum amount of cuts based on CUTSTRATEGY.
>=0
: Multiple of number of rows and coefficients to use.
"""
global const XPRS_CUTFACTOR = Int32(7091)
export XPRS_CUTFACTOR

"""
    XPRS_CUTFREQ
Branch and Bound: This specifies the frequency at which cuts are generated in the tree search. (integer)

If the depth of the node modulo `CUTFREQ` is zero, then cuts will be generated.

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_CUTFREQ = Int32(8116)
export XPRS_CUTFREQ

"""
    XPRS_CUTSELECT
A bit vector providing detailed control of the cuts created for the root node of a MIP solve. (integer)

Use TREECUTSELECT to control cuts during the tree search.

Default value: `-1`

Values are a bitset:
bit 5
: Clique cuts.
bit 6
: Mixed Integer Rounding (MIR) cuts.
bit 7
: Lifted cover cuts.
bit 8
: Turn on row aggregation for MIR cuts.
bit 11
: Flow path cuts.
bit 12
: Implication cuts.
bit 13
: Turn on automatic Lift-and-Project cutting strategy.
bit 14
: Disable cutting from cut rows.
bit 15
: Lifted GUB cover cuts.
bit 16
: Zero-half cuts.
bit 17
: Indicator constraint cuts.
bit 18
: Strong Chvatal-Gomory cuts.
bit 20
: Farkas cuts.
"""
global const XPRS_CUTSELECT = Int32(8142)
export XPRS_CUTSELECT

"""
    XPRS_CUTSTRATEGY
Branch and Bound: This specifies the cut strategy. (integer)

A more aggressive cut strategy, generating a greater number of cuts, will result in fewer nodes to be explored, but with an associated time cost in generating the cuts. The fewer cuts generated, the less time taken, but the greater subsequent number of nodes to be explored.

Default value: `-1`

Values:
-1
: Automatic selection of the cut strategy.
0
: No cuts.
1
: Conservative cut strategy.
2
: Moderate cut strategy.
3
: Aggressive cut strategy.
"""
global const XPRS_CUTSTRATEGY = Int32(8138)
export XPRS_CUTSTRATEGY

"""
    XPRS_DEFAULTALG
This selects the algorithm that will be used to solve LPs, standalone or during MIP optimization. (integer)

Default value: `1`

Values:
1
: Automatically determined.
2
: Dual simplex.
3
: Primal simplex.
4
: Newton barrier (or hybrid gradient, if BARALG=4 is set).
"""
global const XPRS_DEFAULTALG = Int32(8023)
export XPRS_DEFAULTALG

"""
    XPRS_DENSECOLLIMIT
Newton barrier: Columns with more than `DENSECOLLIMIT` elements are considered to be dense. (integer)

Such columns will be handled specially in the Cholesky factorization of this matrix.

Default value: `0` determined automatically.

Domain: 0~+INF
"""
global const XPRS_DENSECOLLIMIT = Int32(8086)
export XPRS_DENSECOLLIMIT

"""
    XPRS_DETERMINISTIC
Selects whether to use a deterministic or opportunistic mode when solving a problem using multiple threads. (integer)

Default value: `1`

Values:
0
: Use opportunistic mode.
1
: Use deterministic mode.
2
: Use deterministic mode, except allow the initial concurrent continuous solve of a MIP to be opportunistic.
"""
global const XPRS_DETERMINISTIC = Int32(8232)
export XPRS_DETERMINISTIC

global const XPRS_DETLOGFREQ = Int32(7116)
export XPRS_DETLOGFREQ

"""
    XPRS_DUALGRADIENT
Simplex: This specifies the dual simplex pricing method. (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: Devex.
1
: Steepest edge.
2
: Direct steepest edge.
3
: Sparse Devex.
"""
global const XPRS_DUALGRADIENT = Int32(8145)
export XPRS_DUALGRADIENT

"""
    XPRS_DUALIZE
For a linear problem or the initial linear relaxation of a MIP, determines whether to form and solve the dual problem. (integer)

Default value: `-1`

Values:
-1
: Determine automatically which version would be faster.
0
: Solve the original problem.
1
: Solve the dualized problem.
"""
global const XPRS_DUALIZE = Int32(8144)
export XPRS_DUALIZE

"""
    XPRS_DUALIZEOPS
Bit-vector control for adjusting the behavior when a problem is dualized. (integer)

Default value: `1` (bit `0` is set)

Values are a bitset:
bit 0
: Swap the simplex algorithm to run. If dual simplex is selected for the original problem then primal simplex will be run on the dualized problem, and simiarly if primal simplex is selected.
"""
global const XPRS_DUALIZEOPS = Int32(8097)
export XPRS_DUALIZEOPS

"""
    XPRS_DUALPERTURB
The factor by which the problem will be perturbed prior to optimization by dual simplex. (double)

A value of `0.0` results in no perturbation prior to optimization. Note the interconnection to the AUTOPERTURB control. If AUTOPERTURB is set to `1`, the decision whether to perturb or not is left to the Optimizer. When the problem is automatically perturbed in dual simplex, however, the value of DUALPERTURB will be used for perturbation.

Default value: `-1` determined automatically.

Domain: -1,[0,+INF]
"""
global const XPRS_DUALPERTURB = Int32(7025)
export XPRS_DUALPERTURB

"""
    XPRS_DUALSTRATEGY
This bit-vector control specifies the dual simplex strategy. (integer)

Default value: `1`

Values are a bitset:
bit 0
: Switch to primal when re-optimization goes dual infeasible and numerically unstable.
bit 1
: When dual intend to switch to primal, stop the solve instead of switching to primal.
bit 2
: Use more aggressive cut-off in MIP search.
bit 3
: Use dual simplex to remove cost perturbations.
bit 4
: Enable more aggressive dual pivoting strategy.
bit 5
: Keep using dual simplex even when it's numerically unstable.
"""
global const XPRS_DUALSTRATEGY = Int32(8174)
export XPRS_DUALSTRATEGY

"""
    XPRS_DUALTHREADS
Determines the maximum number of threads that dual simplex is allowed to use. (integer)

If `DUALTHREADS` is set to the default value (`-1`), the THREADS control will determine the number of threads used.

Default value: `-1` (determined by the `THREADS` control)

Domain: -1~+INF
"""
global const XPRS_DUALTHREADS = Int32(8334)
export XPRS_DUALTHREADS

global const XPRS_DUMMYCONTROL = Int32(7075)
export XPRS_DUMMYCONTROL

"""
    XPRS_EIGENVALUETOL
A quadratic matrix is considered not to be positive semi-definite, if its smallest eigenvalue is smaller than the negative of this value. (double)

Default value: `1E-6`

Domain: [0,+INF]
"""
global const XPRS_EIGENVALUETOL = Int32(7097)
export XPRS_EIGENVALUETOL

"""
    XPRS_ELIMFILLIN
Amount of fill-in allowed when performing an elimination in presolve . (integer)

Default value: `7`

Domain: -INF~+INF
"""
global const XPRS_ELIMFILLIN = Int32(8073)
export XPRS_ELIMFILLIN

"""
    XPRS_ELIMTOL
The Markowitz tolerance for the elimination phase of the presolve. (double)

Default value: `0.001`

Domain: [-INF,+INF]
"""
global const XPRS_ELIMTOL = Int32(7042)
export XPRS_ELIMTOL

"""
    XPRS_ESCAPENAMES
If characters illegal to an mps or lp file should be escaped to guarantee readability, and whether escaped characters should be transformed back when reading such a file. (integer)

Default value: `1`

Values:
0
: Illegal characters are not escaped.
1
: Illegal characters are escaped.
"""
global const XPRS_ESCAPENAMES = Int32(8440)
export XPRS_ESCAPENAMES

"""
    XPRS_ETATOL
Tolerance on eta elements. (double)

During each iteration, the basis inverse is premultiplied by an elementary matrix, which is the identity except for one column - the eta vector. Elements of eta vectors whose absolute value is smaller than `ETATOL` are taken to be zero in this step.

Default value: `1.0E-13`

Domain: (0,+INF]
"""
global const XPRS_ETATOL = Int32(7007)
export XPRS_ETATOL

"""
    XPRS_EXTRACOLS
The initial number of extra columns to allow for in the matrix. (integer)

If columns are to be added to the matrix, then, for maximum efficiency, space should be reserved for the columns before the matrix is input by setting the `EXTRACOLS` control. If this is not done, resizing will occur automatically, but more space may be allocated than the user actually requires.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_EXTRACOLS = Int32(8005)
export XPRS_EXTRACOLS

"""
    XPRS_EXTRAELEMS
The initial number of extra matrix elements to allow for in the matrix, including coefficients for cuts. (integer)

If rows or columns are to be added to the matrix, then, for maximum efficiency, space should be reserved for the extra matrix elements before the matrix is input by setting the `EXTRAELEMS` control. If this is not done, resizing will occur automatically, but more space may be allocated than the user actually requires.

Default value: Hardware/platform dependent.

Domain: 0~+INF
"""
global const XPRS_EXTRAELEMS = Int32(8006)
export XPRS_EXTRAELEMS

"""
    XPRS_EXTRAMIPENTS
The initial number of extra MIP entities to allow for. (integer)

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_EXTRAMIPENTS = Int32(8051)
export XPRS_EXTRAMIPENTS

"""
    XPRS_EXTRAROWS
The initial number of extra rows to allow for in the matrix, including cuts. (integer)

If rows are to be added to the matrix, then, for maximum efficiency, space should be reserved for the rows before the matrix is input by setting the `EXTRAROWS` control. If this is not done, resizing will occur automatically, but more space may be allocated than the user actually requires.

Default value: 0

Domain: 0~+INF
"""
global const XPRS_EXTRAROWS = Int32(8004)
export XPRS_EXTRAROWS

"""
    XPRS_EXTRASETELEMS
The initial number of extra elements in sets to allow for in the matrix. (integer)

If sets are to be added to the matrix, then, for maximum efficiency, space should be reserved for the set elements before the matrix is input by setting the `EXTRASETELEMS` control. If this is not done, resizing will occur automatically, but more space may be allocated than the user actually requires.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_EXTRASETELEMS = Int32(8191)
export XPRS_EXTRASETELEMS

"""
    XPRS_EXTRASETS
The initial number of extra sets to allow for in the matrix. (integer)

If sets are to be added to the matrix, then, for maximum efficiency, space should be reserved for the sets before the matrix is input by setting the `EXTRASETS` control. If this is not done, resizing will occur automatically, but more space may be allocated than the user actually requires.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_EXTRASETS = Int32(8190)
export XPRS_EXTRASETS

"""
    XPRS_FEASIBILITYJUMP
MIP: Decides if the Feasibility Jump heuristic should be run. (integer)

The value for this control is either -1 (let Xpress decide), 0 (off) or a value that indicates for which type of models the heuristic should be run.

Default value: `-1`

Values:
-1
: Use automatic settings.
0
: Turned off.
1
: Run the heuristic on models with all integer variables.
2
: Run the heuristic on models in which all non-integer variables have bounds [0,1].
3
: Run the heuristic on models in which all non-integer variables have integer bounds.
"""
global const XPRS_FEASIBILITYJUMP = Int32(8471)
export XPRS_FEASIBILITYJUMP

"""
    XPRS_FEASIBILITYPUMP
Branch and Bound: Decides if the Feasibility Pump heuristic should be run at the top node. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Turned off.
1
: Always try the Feasibility Pump.
2
: Try the Feasibility Pump only if other heuristics have failed to find an integer solution.
"""
global const XPRS_FEASIBILITYPUMP = Int32(8193)
export XPRS_FEASIBILITYPUMP

"""
    XPRS_FEASTOL
This tolerance determines when a solution is treated as feasible. (double)

If the amount by which a constraint's activity violates its right-hand side or ranged bound is less in absolute magnitude than `FEASTOL`, then the constraint is treated as satisfied. Similarly, if the amount by which a column violates its bounds is less in absolute magnitude than `FEASTOL`, those bounds are also treated as satisfied.

Default value: `1.0E-06`

Domain: (0,+INF]
"""
global const XPRS_FEASTOL = Int32(7003)
export XPRS_FEASTOL

"""
    XPRS_FEASTOLPERTURB
This tolerance determines how much a feasible primal basic solution is allowed to be perturbed when performing basis changes. (double)

The tolerance `FEASTOL` is always considered as an upper limit for the perturbations, but in some cases smaller value can be more desirable.

Default value: `1.0E-06`

Domain: (0,+INF]
"""
global const XPRS_FEASTOLPERTURB = Int32(7132)
export XPRS_FEASTOLPERTURB

"""
    XPRS_FEASTOLTARGET
This specifies the target feasibility tolerance for the solution refiner. (double)

Default value: `0` use the value specified by FEASTOL.``

Domain: (0,+INF]
"""
global const XPRS_FEASTOLTARGET = Int32(7121)
export XPRS_FEASTOLTARGET

"""
    XPRS_FORCEOUTPUT
Certain names in the problem object may be incompatible with different file formats (such as names containing spaces for LP files). (integer)

If the optimizer might be unable to read back a problem because of non-standard names, it will first attempt to write it out using an extended naming convention. If the names would not be possible to extend so that they would be reproducible and recognizable, it will give an error message and won't create the file. If the optimizer might be unable to read back a problem because of non-standard names, it will give an error message and won't create the file. This option may be used to force output anyway.

Default value: `0`

Values:
0
: Check format compatibility, and in case of failure try to extend names so that they are reproducible and recognizable.
1
: Force output using problem names as is.
2
: Always use 'x(' original name ')' in LP files to create a representation that can be read by Xpress. Default for problem having spaces in names
3
: Substitute spaces by the '_' character in LP files
"""
global const XPRS_FORCEOUTPUT = Int32(8229)
export XPRS_FORCEOUTPUT

"""
    XPRS_FORCEPARALLELDUAL
Dual simplex: specifies whether the dual simplex solver should always use the parallel simplex algorithm. (integer)

By default, when using a single thread, the dual simplex solver will execute a dedicated sequential simplex algorithm.

Default value: `0`

Values:
0
: Disabled.
1
: Enabled. Force the dual simplex solver to use the parallel algorithm.
"""
global const XPRS_FORCEPARALLELDUAL = Int32(8265)
export XPRS_FORCEPARALLELDUAL

"""
    XPRS_GENCONSABSTRANSFORMATION
This control specifies the reformulation method for absolute value general constraints at the beginning of the search. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Use a formulation based on indicator constraints.
1
: Use a formulation based on SOS1-constraints.
"""
global const XPRS_GENCONSABSTRANSFORMATION = Int32(8408)
export XPRS_GENCONSABSTRANSFORMATION

"""
    XPRS_GENCONSDUALREDUCTIONS
This parameter specifies whether dual reductions should be applied to reduce the number of columns and rows added when transforming general constraints to MIP structs. (integer)

Default value: `1`

Values:
0
: Disabled. No dual reductions, add columns and rows.
1
: Enabled. Only add neccessary columns and rows, drop those implied by the objective sense.
"""
global const XPRS_GENCONSDUALREDUCTIONS = Int32(8395)
export XPRS_GENCONSDUALREDUCTIONS

"""
    XPRS_GLOBALBOUNDINGBOX
If a nonlinear problem cannot be solved due to appearing unbounded, it can automatically be regularized by the application of a bounding box on the variables. (double)

If this control is set to a negative value, in a second solving attempt all original variables will be bounded by the absolute value of this control. If set to a positive value, there will be a third solving attempt afterwards, if necessary, in which also all auxiliary variables are bounded by this value.

Default value: `1.0E+06`

Values:
0
: Disabled. Problem will return unbounded.
n<0
: Enabled. Apply lower and upper bounds of this magnitude to all original variables if initial LP is unbounded.
n>0
: Enabled. Apply lower and upper bounds of this magnitude to all original and auxiliary variables if initial LP and first regularization are unbounded.
"""
global const XPRS_GLOBALBOUNDINGBOX = Int32(7154)
export XPRS_GLOBALBOUNDINGBOX

"""
    XPRS_GLOBALLSHEURSTRATEGY
When integer-feasible (for MINLP, any solution for NLP) but nonlinear-infeasible solutions are encountered within a global solve, the integer variables can be fixed and a local solver (as defined by the `LOCALSOLVER` control) can be called on the remaining continuous problem. (double)

This control defines the frequency and effort of such local solves.

Default value: `-1`

Values:
-1
: Automatic selection of the strategy.
0
: Never run a local solver on a partially fixed solution.
1
: Conservative strategy.
2
: Moderate strategy.
3
: Aggressive strategy.
"""
global const XPRS_GLOBALLSHEURSTRATEGY = Int32(8464)
export XPRS_GLOBALLSHEURSTRATEGY

"""
    XPRS_GLOBALNLPCUTS
Limit on the number of rounds of outer approximation and convexification cuts generated for the root node, when solving an (MI)NLP to global optimality. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_GLOBALNLPCUTS = Int32(8481)
export XPRS_GLOBALNLPCUTS

"""
    XPRS_GLOBALNUMINITNLPCUTS
Specifies the maximum number of tangent cuts when setting up the initial relaxation during a global solve. (integer)

By default, the algorithm chooses the number of cuts automatically. Adding more cuts tightens the problem, resulting in a smaller branch-and-bound tree, at the cost of slowing down each LP solve.

Default value: `-1` determined automatically.

Domain: -1,0~+INF
"""
global const XPRS_GLOBALNUMINITNLPCUTS = Int32(8449)
export XPRS_GLOBALNUMINITNLPCUTS

"""
    XPRS_GLOBALSPATIALBRANCHCUTTINGEFFORT
Limits the effort that is spent on creating cuts during spatial branching. (double)

Default value: -1.0

Values:
-1
: The algorithm chooses the effort limit automatically (default).
0
: Disables cuts on branching entities.
0<n<1
: Relative effort to spend on cutting on branching entities. Higher values lead to more cuts.
"""
global const XPRS_GLOBALSPATIALBRANCHCUTTINGEFFORT = Int32(7153)
export XPRS_GLOBALSPATIALBRANCHCUTTINGEFFORT

"""
    XPRS_GLOBALSPATIALBRANCHIFPREFERORIG
Whether spatial branchings on original variables should be preferred over branching on auxiliary variables that were introduced by the reformulation of the global solver. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Always consider both original and auxiliary variables.
1
: Always prefer branching on original variables over auxiliaries.
2
: Always prefer branching on auxiliary variables over originals.
"""
global const XPRS_GLOBALSPATIALBRANCHIFPREFERORIG = Int32(8465)
export XPRS_GLOBALSPATIALBRANCHIFPREFERORIG

"""
    XPRS_GLOBALSPATIALBRANCHPROPAGATIONEFFORT
Limits the effort that is spent on propagation during spatial branching. (double)

Default value: -1.0

Values:
-1
: The algorithm chooses the effort limit automatically (default).
0
: Disables propagation on branching entities.
n>0
: Relative effort to spend on propagating on branching entities. Higher values lead to more propagation.
"""
global const XPRS_GLOBALSPATIALBRANCHPROPAGATIONEFFORT = Int32(7152)
export XPRS_GLOBALSPATIALBRANCHPROPAGATIONEFFORT

"""
    XPRS_GLOBALTREENLPCUTS
Limit on the number of rounds of outer approximation and convexification cuts generated for each node in the tree, when solving an (MI)NLP to global optimality. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_GLOBALTREENLPCUTS = Int32(8482)
export XPRS_GLOBALTREENLPCUTS

"""
    XPRS_GOMCUTS
Branch and Bound: The number of rounds of Gomory or lift-and-project cuts at the top node. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_GOMCUTS = Int32(8135)
export XPRS_GOMCUTS

"""
    XPRS_HEURBEFORELP
Branch and Bound: Determines whether primal heuristics should be run before the initial LP relaxation has been solved. (integer)

Default value: `-1`

Values:
-1
: Automatic - let the optimizer decide if heuristics should be run.
0
: Disabled.
1
: Enabled.
"""
global const XPRS_HEURBEFORELP = Int32(8280)
export XPRS_HEURBEFORELP

"""
    XPRS_HEURDEPTH
Branch and Bound: Sets the maximum depth in the tree search at which heuristics will be used to find MIP solutions. (integer)

It may be worth stopping the heuristic search for solutions after a certain depth in the tree search. A value of 0 signifies that heuristics will not be used. This control no longer has any effect and will be removed from future releases.

Default value: `-1`

Domain: 0~+INF
"""
global const XPRS_HEURDEPTH = Int32(8156)
export XPRS_HEURDEPTH

"""
    XPRS_HEURDIVEITERLIMIT
Branch and Bound: Simplex iteration limit for reoptimizing during the diving heuristic. (double)

Default value: `-1`

Values:
>=1
: Fixed iteration limit.
0
: No iteration limit.
<0
: Automatic selection of the iteration limit based on the problem size. The absolute value is used as a multiplier on the automatic selection.
"""
global const XPRS_HEURDIVEITERLIMIT = Int32(7128)
export XPRS_HEURDIVEITERLIMIT

"""
    XPRS_HEURDIVERANDOMIZE
The level of randomization to apply in the diving heuristic. The diving heuristic uses priority weights on rows and columns to determine the order in which to e.g. round fractional columns, or the direction in which to round them. (double)

This control determines by how large a random factor these weights should be changed.

Default value: `0.0`

Values:
0.0-1.0
: Amount of randomization (0.0=none, 1.0=full)
"""
global const XPRS_HEURDIVERANDOMIZE = Int32(7089)
export XPRS_HEURDIVERANDOMIZE

"""
    XPRS_HEURDIVESOFTROUNDING
Branch and Bound: Enables a more cautious strategy for the diving heuristic, where it tries to push binaries and integer variables to their bounds using the objective, instead of directly fixing them. (integer)

This can be useful when the default diving heuristics fail to find any feasible solutions.

Default value: `-1`

Values:
-1
: Automatic selection.
0
: Do not use soft rounding.
1
: Cautious use of the soft rounding strategy.
2
: More aggressive use of the soft rounding strategy.
"""
global const XPRS_HEURDIVESOFTROUNDING = Int32(8215)
export XPRS_HEURDIVESOFTROUNDING

"""
    XPRS_HEURDIVESPEEDUP
Branch and Bound: Changes the emphasis of the diving heuristic from solution quality to diving speed. (integer)

Default value: `-1`

Values:
-2
: Automatic selection biased towards quality
-1
: Automatic selection biased towards speed.
0-4
: manual emphasis bias from emphasis on quality (0) to emphasis on speed (4).
"""
global const XPRS_HEURDIVESPEEDUP = Int32(8197)
export XPRS_HEURDIVESPEEDUP

"""
    XPRS_HEURDIVESTRATEGY
Branch and Bound: Chooses the strategy for the diving heuristic. (integer)

Default value: `-1`

Values:
-1
: Automatic selection of strategy.
0
: Disables the diving heuristic.
1-18
: Available pre-set strategies for rounding infeasible MIP entities and reoptimizing during the heuristic dive.
"""
global const XPRS_HEURDIVESTRATEGY = Int32(8177)
export XPRS_HEURDIVESTRATEGY

"""
    XPRS_HEUREMPHASIS
Branch and Bound: This control specifies an emphasis for the search w.r.t. (integer)

primal heuristics and other procedures that affect the speed of convergence of the primal-dual gap. For problems where the goal is to achieve a small gap but not neccessarily solving them to optimality, it is recommended to set `HEUREMPHASIS` to 1. This setting triggers many additional heuristic calls, aiming for reducing the gap at the beginning of the search, typically at the expense of an increased time for proving optimality.

Default value: `-1`

Values:
-1
: Optimizer default strategy.
0
: Disables all heuristics.
1
: Focus on reducing the primal-dual gap in the early part of the search.
2
: Extremely aggressive search heuristics.
"""
global const XPRS_HEUREMPHASIS = Int32(8427)
export XPRS_HEUREMPHASIS

"""
    XPRS_HEURFORCESPECIALOBJ
Branch and Bound: This specifies whether local search heuristics without objective or with an auxiliary objective should always be used, despite the automatic selection of the Optimiezr. (integer)

Deactivated by default.

Default value: `0`

Values:
0
: Disabled.
1
: Enabled. Run special objective heuristics on large problems and even if incumbent exists.
"""
global const XPRS_HEURFORCESPECIALOBJ = Int32(8350)
export XPRS_HEURFORCESPECIALOBJ

"""
    XPRS_HEURFREQ
Branch and Bound: This specifies the frequency at which heuristics are used in the tree search. (integer)

Heuristics will only be used at a node if the depth of the node is a multiple of `HEURFREQ`.

Default value: `-1`

Domain: 0~+INF
"""
global const XPRS_HEURFREQ = Int32(8155)
export XPRS_HEURFREQ

"""
    XPRS_HEURMAXSOL
Branch and Bound: This specifies the maximum number of heuristic solutions that will be found in the tree search. (integer)

This control no longer has any effect and will be removed from future releases.

Default value: `-1`

Domain: 0~+INF
"""
global const XPRS_HEURMAXSOL = Int32(8157)
export XPRS_HEURMAXSOL

"""
    XPRS_HEURNODES
Branch and Bound: This specifies the maximum number of nodes at which heuristics are used in the tree search. (integer)

This control no longer has any effect and will be removed from future releases.

Default value: `-1`

Domain: 0~+INF
"""
global const XPRS_HEURNODES = Int32(8158)
export XPRS_HEURNODES

"""
    XPRS_HEURSEARCHBACKGROUNDSELECT
Select which large neighborhood searches to run in the background (for example in parallel to the root cut loop). (integer)

Default value: -1

Values are a bitset:
bit 1
: Enable `L` heuristic.
"""
global const XPRS_HEURSEARCHBACKGROUNDSELECT = Int32(8477)
export XPRS_HEURSEARCHBACKGROUNDSELECT

"""
    XPRS_HEURSEARCHCOPYCONTROLS
Select how user-set controls should affect local search heuristics. (integer)

Default value: `1`

Values:
0
: Do not copy any user-set controls
1
: Automatic - Let the Optimizer decide which user-set controls to copy
2
: Copy all user-set controls
"""
global const XPRS_HEURSEARCHCOPYCONTROLS = Int32(8480)
export XPRS_HEURSEARCHCOPYCONTROLS

"""
    XPRS_HEURSEARCHEFFORT
Adjusts the overall level of the local search heuristics. (double)

Default value: `1.0`

Domain: (0,+INF]
"""
global const XPRS_HEURSEARCHEFFORT = Int32(7090)
export XPRS_HEURSEARCHEFFORT

"""
    XPRS_HEURSEARCHFREQ
Branch and Bound: This specifies how often the local search heuristic should be run in the tree. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disabled in the tree.
n>0
: Number of nodes between each run.
"""
global const XPRS_HEURSEARCHFREQ = Int32(8196)
export XPRS_HEURSEARCHFREQ

"""
    XPRS_HEURSEARCHROOTCUTFREQ
How frequently to run the local search heuristic during root cutting. (integer)

This is given as how many cut rounds to perform between runs of the heuristic. Set to zero to avoid applying the heuristic during root cutting. Branch and Bound: This specifies how often the local search heuristic should be run in the tree.

Default value: `-1`

Values:
-1
: Automatic.
0
: Disabled heuristic during cutting.
n>0
: Number of cutting rounds between each run.
"""
global const XPRS_HEURSEARCHROOTCUTFREQ = Int32(8351)
export XPRS_HEURSEARCHROOTCUTFREQ

"""
    XPRS_HEURSEARCHROOTSELECT
A bit vector control for selecting which local search heuristics to apply on the root node of a MIP solve. (integer)

Use HEURSEARCHTREESELECT to control local search heuristics during the tree search.

Default value: `117`

Values are a bitset:
bit 0
: Local search with a large neighborhood. Potentially slow but is good for finding solutions that differs significantly from the incumbent.
bit 1
: Local search with a small neighborhood centered around a node LP solution.
bit 2
: Local search with a small neighborhood centered around an integer solution. This heuristic will often provide smaller, incremental improvements to an incumbent solution.
bit 3
: Local search with a neighborhood set up through the combination of multiple integer solutions.
bit 4
: Unused
bit 5
: Local search without an objective function. Called seldom and only when no feasible solution is available.
bit 6
: Local search with an auxiliary objective function. Called seldom and only when no feasible solution is available.
"""
global const XPRS_HEURSEARCHROOTSELECT = Int32(8216)
export XPRS_HEURSEARCHROOTSELECT

global const XPRS_HEURSEARCHTARGETSIZE = Int32(7112)
export XPRS_HEURSEARCHTARGETSIZE

"""
    XPRS_HEURSEARCHTREESELECT
A bit vector control for selecting which local search heuristics to apply during the tree search of a MIP solve. (integer)

Use HEURSEARCHROOTSELECT to control local search heuristics on the root node.

Default value: `17`

Values are a bitset:
bit 0
: Local search with a large neighborhood. Potentially slow but is good for finding solutions that differs significantly from the incumbent.
bit 1
: Local search with a small neighborhood centered around a node LP solution.
bit 2
: Local search with a small neighborhood centered around an integer solution. This heuristic will often provide smaller, incremental improvements to an incumbent solution.
bit 3
: Local search with a neighborhood set up through the combination of multiple integer solutions.
bit 4
: Unused
bit 5
: Local search without an objective function. Called seldom and only when no feasible solution is available.
bit 6
: Local search with an auxiliary objective function. Called seldom and only when no feasible solution is available.
"""
global const XPRS_HEURSEARCHTREESELECT = Int32(8217)
export XPRS_HEURSEARCHTREESELECT

global const XPRS_HEURSELECT = Int32(8178)
export XPRS_HEURSELECT

"""
    XPRS_HEURSHIFTPROP
Determines whether the Shift-and-propagate primal heuristic should be executed. (integer)

If enabled, Shift-and-propagate is an LP-free primal heuristic that is executed immediately after presolve.

Default value: `-1`

Values:
-1
: The solver decides if Shift-and-propagate should be run. This is the default setting.
0
: Shift-and-propagate is disabled.
1
: Shift-and-propagate is enabled.
"""
global const XPRS_HEURSHIFTPROP = Int32(8479)
export XPRS_HEURSHIFTPROP

"""
    XPRS_HEURTHREADS
Branch and Bound: The number of threads to dedicate to running heuristics during the root solve. (integer)

Default value: `0`

Values:
-1
: Automatically determined from the THREADS control.
0
: Disabled.
>=1
: Number of additional threads to dedicate to parallel heuristics.
"""
global const XPRS_HEURTHREADS = Int32(8276)
export XPRS_HEURTHREADS

"""
    XPRS_HISTORYCOSTS
Branch and Bound: How to update the pseudo cost for a MIP entity when a strong branch or a regular branch is applied. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: No update.
1
: Update using only regular branches from the root to the current node.
2
: Same as 1, but update with strong branching results as well.
3
: Update using any regular branching or strong branching information from all nodes solves before the current node.
"""
global const XPRS_HISTORYCOSTS = Int32(8206)
export XPRS_HISTORYCOSTS

"""
    XPRS_IFCHECKCONVEXITY
Determines if the convexity of the problem is checked before optimization. (integer)

Applies to quadratic, mixed integer quadratic and quadratically constrained problems. Checking convexity takes some time, thus for problems that are known to be convex it might be reasonable to switch the checking off.

Default value: `1`

Values:
0
: Turn off convexity checking.
1
: Turn on convexity checking.
"""
global const XPRS_IFCHECKCONVEXITY = Int32(8251)
export XPRS_IFCHECKCONVEXITY

global const XPRS_IGNORECONTAINERCPULIMIT = Int32(8390)
export XPRS_IGNORECONTAINERCPULIMIT

global const XPRS_IGNORECONTAINERMEMORYLIMIT = Int32(8391)
export XPRS_IGNORECONTAINERMEMORYLIMIT

"""
    XPRS_IISLOG
Selects how much information should be printed during the IIS procedure. (integer)

Please refer to Appendix for a more detailed description of the IIS logging format.

Default value: `1`, a progress log is printed

Values:
0
: The IIS procedure does not produce any output.
1
: Prints general information and a progress log of the deletion filter, including bounds on the size of the IIS and timing information.
2
: Complete logging, including the full progress log of all the subproblem solves in the deletion filter. This setting is recommended only for debugging as it may produce a lot of output.
"""
global const XPRS_IISLOG = Int32(8165)
export XPRS_IISLOG

"""
    XPRS_IISOPS
Selects which part of the restrictions (bounds, constraints, entities) should always be kept in an IIS. (integer)

This is useful if certain types of restrictions cannot be violated, thus they are known not to be the cause of infeasibility. The IIS obtained this way is irreducible only for the non-protected restrictions. This control has an effect only on the deletion filter of the IIS procedure.

Default value: `0`, all restrictions are valid candidates for removal

Values are a bitset:
bit 0
: Keep binary integralities.
bit 1
: Keep the 0 lower bounds of variables.
bit 2
: Keep fixed variables.
bit 3
: Keep all variable bounds.
bit 4
: Keep all general integer entities, except binaries.
bit 5
: Keep all equality constraints.
bit 6
: Keep all general constraints.
bit 7
: Keep all piecewise linear constraints.
bit 8
: Keep all specially ordered set (SOS) constraints.
bit 9
: Keep all indicator constraints.
bit 10
: Keep all delayed rows.
bit 11
: Keep all constraints.
"""
global const XPRS_IISOPS = Int32(8472)
export XPRS_IISOPS

"""
    XPRS_INDLINBIGM
During presolve, indicator constraints will be linearized using a BigM coefficient whenever that BigM coefficient is small enough. (double)

This control defines the largest BigM for which such a linearized version will be added to the problem in addition to the original constraint. If the BigM is even smaller than INDPRELINBIGM, then the original indicator constraint will additionally be dropped from the problem.

Default value: `1.0E+05`

Domain: [0,+INF]
"""
global const XPRS_INDLINBIGM = Int32(7099)
export XPRS_INDLINBIGM

"""
    XPRS_INDPRELINBIGM
During presolve, indicator constraints will be linearized using a BigM coefficient whenever that BigM coefficient is small enough. (double)

This control defines the largest BigM for which the original constraint will be replaced by the linearized version. If the BigM is larger than INDPRELINBIGM but smaller than INDLINBIGM, the linearized row will be added but the original indicator constraint is kept as a numerically stable way to check feasibility.

Default value: `100.0`

Domain: [0,+INF]
"""
global const XPRS_INDPRELINBIGM = Int32(7102)
export XPRS_INDPRELINBIGM

"""
    XPRS_INPUTTOL
The tolerance on input values elements. (double)

If any value is less than or equal to `INPUTTOL` in absolute value, it is treated as zero. For the internal zero tolerance see MATRIXTOL.

Default value: `0.0`

Domain: [0,+INF]
"""
global const XPRS_INPUTTOL = Int32(7143)
export XPRS_INPUTTOL

"""
    XPRS_INVERTFREQ
Simplex: The frequency with which the basis will be inverted. (integer)

The basis is maintained in a factorized form and on most simplex iterations it is incrementally updated to reflect the step just taken. This is considerably faster than computing the full inverted matrix at each iteration, although after a number of iterations the basis becomes less well-conditioned and it becomes necessary to compute the full inverted matrix. The value of `INVERTFREQ` specifies the maximum number of iterations between full inversions.

Default value: `-1` the frequency is determined automatically.

Domain: -1,0~+INF
"""
global const XPRS_INVERTFREQ = Int32(8014)
export XPRS_INVERTFREQ

"""
    XPRS_INVERTMIN
Simplex: The minimum number of iterations between full inversions of the basis matrix. (integer)

See the description of INVERTFREQ for details.

Default value: `3`

Domain: 0~+INF
"""
global const XPRS_INVERTMIN = Int32(8015)
export XPRS_INVERTMIN

"""
    XPRS_IOTIMEOUT
The maximum number of seconds to wait for an I/O operation before it is cancelled. (integer)

Default value: `30`

Domain: 1~+INF
"""
global const XPRS_IOTIMEOUT = Int32(8442)
export XPRS_IOTIMEOUT

"""
    XPRS_KEEPBASIS
Simplex: This determines whether the basis should be kept when reoptimizing a problem. (integer)

The choice is between using a crash basis created at the beginning of simplex or using a basis from a previous solve (if such exists). By default, this control gets (re)set automatically in various situations. By default, it will be automatically set to 1 after a solve that produced a valid basis. This will automatically warmstart a subsequent solve. Explicitly loading a starting basis will also set this control to 1. If the control is explicitly set to 0, any existing basis will be ignored for a new solve, and the Optimizer will start from an ad-hoc crash basis.

Default value: `0`

Values:
0
: Problem optimization starts from scratch, i.e., any previous basis is ignored.
1
: The previous basis should be used as a starting basis.
2
: Use the previous basis only if it is valid for the current problem (the number of basic variables must match the number of rows).
3
: Use the previous basis only if it is valid and numerically stable in the current problem.
"""
global const XPRS_KEEPBASIS = Int32(8054)
export XPRS_KEEPBASIS

"""
    XPRS_KEEPNROWS
How nonbinding rows should be handled by the MPS reader. (integer)

Default value: `-1`

Values:
-1
: Delete N type rows from the matrix.
0
: Delete elements from N type rows leaving empty N type rows in the matrix.
1
: Keep N type rows.
"""
global const XPRS_KEEPNROWS = Int32(8030)
export XPRS_KEEPNROWS

global const XPRS_KNITRO_PARAM_ALGORITHM = Int32(101003)
export XPRS_KNITRO_PARAM_ALGORITHM

global const XPRS_KNITRO_PARAM_BAR_DIRECTINTERVAL = Int32(101058)
export XPRS_KNITRO_PARAM_BAR_DIRECTINTERVAL

global const XPRS_KNITRO_PARAM_BAR_FEASIBLE = Int32(101006)
export XPRS_KNITRO_PARAM_BAR_FEASIBLE

global const XPRS_KNITRO_PARAM_BAR_FEASMODETOL = Int32(101021)
export XPRS_KNITRO_PARAM_BAR_FEASMODETOL

global const XPRS_KNITRO_PARAM_BAR_INITMU = Int32(101025)
export XPRS_KNITRO_PARAM_BAR_INITMU

global const XPRS_KNITRO_PARAM_BAR_INITPT = Int32(101009)
export XPRS_KNITRO_PARAM_BAR_INITPT

global const XPRS_KNITRO_PARAM_BAR_MAXBACKTRACK = Int32(101044)
export XPRS_KNITRO_PARAM_BAR_MAXBACKTRACK

global const XPRS_KNITRO_PARAM_BAR_MAXCROSSIT = Int32(101039)
export XPRS_KNITRO_PARAM_BAR_MAXCROSSIT

global const XPRS_KNITRO_PARAM_BAR_MAXREFACTOR = Int32(101043)
export XPRS_KNITRO_PARAM_BAR_MAXREFACTOR

global const XPRS_KNITRO_PARAM_BAR_MURULE = Int32(101004)
export XPRS_KNITRO_PARAM_BAR_MURULE

global const XPRS_KNITRO_PARAM_BAR_PENCONS = Int32(101050)
export XPRS_KNITRO_PARAM_BAR_PENCONS

global const XPRS_KNITRO_PARAM_BAR_PENRULE = Int32(101049)
export XPRS_KNITRO_PARAM_BAR_PENRULE

global const XPRS_KNITRO_PARAM_BAR_RELAXCONS = Int32(101077)
export XPRS_KNITRO_PARAM_BAR_RELAXCONS

global const XPRS_KNITRO_PARAM_BAR_SWITCHRULE = Int32(101061)
export XPRS_KNITRO_PARAM_BAR_SWITCHRULE

global const XPRS_KNITRO_PARAM_BLASOPTION = Int32(101042)
export XPRS_KNITRO_PARAM_BLASOPTION

global const XPRS_KNITRO_PARAM_DEBUG = Int32(101031)
export XPRS_KNITRO_PARAM_DEBUG

global const XPRS_KNITRO_PARAM_DELTA = Int32(101020)
export XPRS_KNITRO_PARAM_DELTA

global const XPRS_KNITRO_PARAM_FEASTOL = Int32(101022)
export XPRS_KNITRO_PARAM_FEASTOL

global const XPRS_KNITRO_PARAM_FEASTOLABS = Int32(101023)
export XPRS_KNITRO_PARAM_FEASTOLABS

global const XPRS_KNITRO_PARAM_GRADOPT = Int32(101007)
export XPRS_KNITRO_PARAM_GRADOPT

global const XPRS_KNITRO_PARAM_HESSOPT = Int32(101008)
export XPRS_KNITRO_PARAM_HESSOPT

global const XPRS_KNITRO_PARAM_HONORBNDS = Int32(101002)
export XPRS_KNITRO_PARAM_HONORBNDS

global const XPRS_KNITRO_PARAM_INFEASTOL = Int32(101056)
export XPRS_KNITRO_PARAM_INFEASTOL

global const XPRS_KNITRO_PARAM_LINSOLVER = Int32(101057)
export XPRS_KNITRO_PARAM_LINSOLVER

global const XPRS_KNITRO_PARAM_LMSIZE = Int32(101038)
export XPRS_KNITRO_PARAM_LMSIZE

global const XPRS_KNITRO_PARAM_MAXCGIT = Int32(101013)
export XPRS_KNITRO_PARAM_MAXCGIT

global const XPRS_KNITRO_PARAM_MAXIT = Int32(101014)
export XPRS_KNITRO_PARAM_MAXIT

global const XPRS_KNITRO_PARAM_MA_TERMINATE = Int32(101063)
export XPRS_KNITRO_PARAM_MA_TERMINATE

global const XPRS_KNITRO_PARAM_MIP_BRANCHRULE = Int32(102002)
export XPRS_KNITRO_PARAM_MIP_BRANCHRULE

global const XPRS_KNITRO_PARAM_MIP_DEBUG = Int32(102013)
export XPRS_KNITRO_PARAM_MIP_DEBUG

global const XPRS_KNITRO_PARAM_MIP_GUB_BRANCH = Int32(102015)
export XPRS_KNITRO_PARAM_MIP_GUB_BRANCH

global const XPRS_KNITRO_PARAM_MIP_HEURISTIC = Int32(102022)
export XPRS_KNITRO_PARAM_MIP_HEURISTIC

global const XPRS_KNITRO_PARAM_MIP_HEUR_MAXIT = Int32(102023)
export XPRS_KNITRO_PARAM_MIP_HEUR_MAXIT

global const XPRS_KNITRO_PARAM_MIP_IMPLICATNS = Int32(102014)
export XPRS_KNITRO_PARAM_MIP_IMPLICATNS

global const XPRS_KNITRO_PARAM_MIP_INTGAPABS = Int32(102004)
export XPRS_KNITRO_PARAM_MIP_INTGAPABS

global const XPRS_KNITRO_PARAM_MIP_INTGAPREL = Int32(102005)
export XPRS_KNITRO_PARAM_MIP_INTGAPREL

global const XPRS_KNITRO_PARAM_MIP_KNAPSACK = Int32(102016)
export XPRS_KNITRO_PARAM_MIP_KNAPSACK

global const XPRS_KNITRO_PARAM_MIP_LPALG = Int32(102019)
export XPRS_KNITRO_PARAM_MIP_LPALG

global const XPRS_KNITRO_PARAM_MIP_MAXNODES = Int32(102021)
export XPRS_KNITRO_PARAM_MIP_MAXNODES

global const XPRS_KNITRO_PARAM_MIP_METHOD = Int32(102001)
export XPRS_KNITRO_PARAM_MIP_METHOD

global const XPRS_KNITRO_PARAM_MIP_OUTINTERVAL = Int32(102011)
export XPRS_KNITRO_PARAM_MIP_OUTINTERVAL

global const XPRS_KNITRO_PARAM_MIP_OUTLEVEL = Int32(102010)
export XPRS_KNITRO_PARAM_MIP_OUTLEVEL

global const XPRS_KNITRO_PARAM_MIP_PSEUDOINIT = Int32(102026)
export XPRS_KNITRO_PARAM_MIP_PSEUDOINIT

global const XPRS_KNITRO_PARAM_MIP_ROOTALG = Int32(102018)
export XPRS_KNITRO_PARAM_MIP_ROOTALG

global const XPRS_KNITRO_PARAM_MIP_ROUNDING = Int32(102017)
export XPRS_KNITRO_PARAM_MIP_ROUNDING

global const XPRS_KNITRO_PARAM_MIP_SELECTRULE = Int32(102003)
export XPRS_KNITRO_PARAM_MIP_SELECTRULE

global const XPRS_KNITRO_PARAM_MIP_STRONG_CANDLIM = Int32(102028)
export XPRS_KNITRO_PARAM_MIP_STRONG_CANDLIM

global const XPRS_KNITRO_PARAM_MIP_STRONG_LEVEL = Int32(102029)
export XPRS_KNITRO_PARAM_MIP_STRONG_LEVEL

global const XPRS_KNITRO_PARAM_MIP_STRONG_MAXIT = Int32(102027)
export XPRS_KNITRO_PARAM_MIP_STRONG_MAXIT

global const XPRS_KNITRO_PARAM_MSMAXBNDRANGE = Int32(101035)
export XPRS_KNITRO_PARAM_MSMAXBNDRANGE

global const XPRS_KNITRO_PARAM_MSMAXSOLVES = Int32(101034)
export XPRS_KNITRO_PARAM_MSMAXSOLVES

global const XPRS_KNITRO_PARAM_MSNUMTOSAVE = Int32(101051)
export XPRS_KNITRO_PARAM_MSNUMTOSAVE

global const XPRS_KNITRO_PARAM_MSSAVETOL = Int32(101052)
export XPRS_KNITRO_PARAM_MSSAVETOL

global const XPRS_KNITRO_PARAM_MSSEED = Int32(101066)
export XPRS_KNITRO_PARAM_MSSEED

global const XPRS_KNITRO_PARAM_MSSTARTPTRANGE = Int32(101055)
export XPRS_KNITRO_PARAM_MSSTARTPTRANGE

global const XPRS_KNITRO_PARAM_MSTERMINATE = Int32(101054)
export XPRS_KNITRO_PARAM_MSTERMINATE

global const XPRS_KNITRO_PARAM_MULTISTART = Int32(101033)
export XPRS_KNITRO_PARAM_MULTISTART

global const XPRS_KNITRO_PARAM_NEWPOINT = Int32(101001)
export XPRS_KNITRO_PARAM_NEWPOINT

global const XPRS_KNITRO_PARAM_OBJRANGE = Int32(101026)
export XPRS_KNITRO_PARAM_OBJRANGE

global const XPRS_KNITRO_PARAM_OPTTOL = Int32(101027)
export XPRS_KNITRO_PARAM_OPTTOL

global const XPRS_KNITRO_PARAM_OPTTOLABS = Int32(101028)
export XPRS_KNITRO_PARAM_OPTTOLABS

global const XPRS_KNITRO_PARAM_OUTLEV = Int32(101015)
export XPRS_KNITRO_PARAM_OUTLEV

global const XPRS_KNITRO_PARAM_PAR_NUMTHREADS = Int32(103001)
export XPRS_KNITRO_PARAM_PAR_NUMTHREADS

global const XPRS_KNITRO_PARAM_PIVOT = Int32(101029)
export XPRS_KNITRO_PARAM_PIVOT

global const XPRS_KNITRO_PARAM_PRESOLVE = Int32(101059)
export XPRS_KNITRO_PARAM_PRESOLVE

global const XPRS_KNITRO_PARAM_PRESOLVE_TOL = Int32(101060)
export XPRS_KNITRO_PARAM_PRESOLVE_TOL

global const XPRS_KNITRO_PARAM_SCALE = Int32(101017)
export XPRS_KNITRO_PARAM_SCALE

global const XPRS_KNITRO_PARAM_SOC = Int32(101019)
export XPRS_KNITRO_PARAM_SOC

global const XPRS_KNITRO_PARAM_XTOL = Int32(101030)
export XPRS_KNITRO_PARAM_XTOL

"""
    XPRS_L1CACHE
**Deprecated**Newton barrier: L1 cache size in kB (kilo bytes) of the CPU. (integer)

On Intel (or compatible) platforms a value of -1 may be used to determine the cache size automatically.

Default value: Hardware/platform dependent.

Domain: -1~+INF
"""
global const XPRS_L1CACHE = Int32(8175)
export XPRS_L1CACHE

"""
    XPRS_LNPBEST
Number of infeasible MIP entities to create lift-and-project cuts for during each round of Gomory cuts at the top node (see GOMCUTS). (integer)

Default value: `50`

Domain: 0~+INF
"""
global const XPRS_LNPBEST = Int32(8160)
export XPRS_LNPBEST

"""
    XPRS_LNPITERLIMIT
Number of iterations to perform in improving each lift-and-project cut. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_LNPITERLIMIT = Int32(8161)
export XPRS_LNPITERLIMIT

global const XPRS_LOCALBACKTRACK = Int32(8171)
export XPRS_LOCALBACKTRACK

"""
    XPRS_LOCALCHOICE
Controls when to perform a local backtrack between the two child nodes during a dive in the branch and bound tree. (integer)

Default value: `3`

Values:
1
: Never backtrack from the first child, unless it is dropped (infeasible or cut off).
2
: Always solve both child nodes before deciding which child to continue with.
3
: Automatically determined.
"""
global const XPRS_LOCALCHOICE = Int32(8170)
export XPRS_LOCALCHOICE

global const XPRS_LOCALSOLVER = Int32(12352)
export XPRS_LOCALSOLVER

"""
    XPRS_LPFLAGS
A bit-vector control which defines the algorithm for solving an LP problem or the initial LP relaxation of a MIP problem. (integer)

Default value: `0`

Values are a bitset:
bit 0
: Use the dual simplex method.
bit 1
: Use the primal simplex method.
bit 2
: Use the barrier method (or hybrid gradient method if BARALG=4 is set).
bit 3
: Use the network simplex method.
"""
global const XPRS_LPFLAGS = Int32(8385)
export XPRS_LPFLAGS

"""
    XPRS_LPFOLDING
Simplex and barrier: whether to fold an LP problem before solving it. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disable LP folding.
1
: Enable LP folding. Attempt to fold all LP problems and MIP initial relaxations.
"""
global const XPRS_LPFOLDING = Int32(8136)
export XPRS_LPFOLDING

"""
    XPRS_LPITERLIMIT
The maximum number of iterations that will be performed by primal simplex or dual simplex before the optimization process terminates. (integer)

For MIP problems, this is the maximum total number of iterations over all nodes explored by the Branch and Bound method.

Default value: `2147483647`

Domain: 0~+INF
"""
global const XPRS_LPITERLIMIT = Int32(8007)
export XPRS_LPITERLIMIT

"""
    XPRS_LPLOG
Simplex: The frequency at which the simplex log is printed. (integer)

Default value: `100`

Values:
n<0
: Detailed output every -n iterations.
0
: Log displayed at the end of the optimization only.
n>0
: Summary output every n iterations.
"""
global const XPRS_LPLOG = Int32(8009)
export XPRS_LPLOG

"""
    XPRS_LPLOGDELAY
Time interval between two LP log lines. (double)

Default value: `1.0`

Domain: [0,+INF)
"""
global const XPRS_LPLOGDELAY = Int32(7127)
export XPRS_LPLOGDELAY

"""
    XPRS_LPLOGSTYLE
Simplex: The style of the simplex log. (integer)

Default value: `1`

Values:
0
: Simplex log is printed based on simplex iteration count, at a fixed frequency as specified by the LPLOG control.
1
: Simplex log is printed based on an estimation of elapsed time, determined by an internal deterministic timer.
"""
global const XPRS_LPLOGSTYLE = Int32(8326)
export XPRS_LPLOGSTYLE

"""
    XPRS_LPREFINEITERLIMIT
This specifies the simplex iteration limit the solution refiner can spend in attempting to increase the accuracy of an LP solution. (integer)

Default value: `-1` determined automatically.``

Domain: -1~+INF
"""
global const XPRS_LPREFINEITERLIMIT = Int32(8094)
export XPRS_LPREFINEITERLIMIT

global const XPRS_LUPIVOTTOL = Int32(7139)
export XPRS_LUPIVOTTOL

"""
    XPRS_MARKOWITZTOL
The Markowitz tolerance used for the factorization of the basis matrix. (double)

Default value: `0.01`

Domain: [-INF,+INF]
"""
global const XPRS_MARKOWITZTOL = Int32(7047)
export XPRS_MARKOWITZTOL

"""
    XPRS_MATRIXTOL
The zero tolerance on matrix elements. (double)

If the value of a matrix element is less than or equal to `MATRIXTOL` in absolute value, it is treated as zero. The control applies when solving a problem, for an input tolerance see INPUTTOL.

Default value: `1.0E-09`

Domain: (0,+INF]
"""
global const XPRS_MATRIXTOL = Int32(7001)
export XPRS_MATRIXTOL

"""
    XPRS_MAXCHECKSONMAXCUTTIME
This control is intended for use where optimization runs that are terminated using the MAXCUTTIME control are required to be reproduced exactly. (integer)

This control is necessary because of the inherent difficulty in terminating algorithmic software in a consistent way using temporal criteria. The control value relates to the number of times the optimizer checks the `MAXCUTTIME` criterion up to and including the check when the termination of cutting was activated. To use the control the user first must obtain the value of the CHECKSONMAXCUTTIME attribute after the run returns. This attribute value is the number of times the optimizer checked the `MAXCUTTIME` criterion during the last call to the optimization routine XPRSmipoptimize. Note that this attribute value will be negative if the optimizer terminated cutting on the `MAXCUTTIME` criterion. To ensure accurate reproduction of a run the user should first ensure that `MAXCUTTIME` is set to its default value or to a large value so the run does not terminate again on `MAXCUTTIME` and then simply set the control `MAXCHECKSONMAXCUTTIME` to the absolute value of the `CHECKSONMAXCUTTIME` value.

Default value: `0`

Values:
0
: Not active.
n>0
: The number of times the optimizer should check the `MAXCUTTIME` criterion before triggering a termination.
"""
global const XPRS_MAXCHECKSONMAXCUTTIME = Int32(8204)
export XPRS_MAXCHECKSONMAXCUTTIME

"""
    XPRS_MAXCHECKSONMAXTIME
This control is intended for use where optimization runs that are terminated using the TIMELIMIT (or the deprecated MAXTIME) control are required to be reproduced exactly. (integer)

This control is necessary because of the inherent difficulty in terminating algorithmic software in a consistent way using temporal criteria. The control value relates to the number of times the optimizer checks the `TIMELIMIT` criterion up to and including the check when the termination was activated. To use the control the user first must obtain the value of the CHECKSONMAXTIME attribute after the run returns. This attribute value is the number of times the optimizer checked the `TIMELIMIT` criterion during the last call to the optimization routine XPRSmipoptimize. Note that this attribute value will be negative if the optimizer terminated on the `TIMELIMIT` criterion. To ensure that a reproduction of a run terminates in the same way the user should first ensure that `TIMELIMIT` is set to its default value or to a large value so the run does not terminate again on `TIMELIMIT` and then simply set the control `MAXCHECKSONMAXTIME` to the absolute value of the `CHECKSONMAXTIME` value.

Default value: `0`

Values:
0
: Not active.
n>0
: The number of times the optimizer should check the `TIMELIMIT` (or `MAXTIME`) criterion before triggering a termination.
"""
global const XPRS_MAXCHECKSONMAXTIME = Int32(8203)
export XPRS_MAXCHECKSONMAXTIME

"""
    XPRS_MAXCUTTIME
The maximum amount of time allowed for generation of cutting planes and reoptimization. (double)

The limit is checked during generation and no further cuts are added once this limit has been exceeded.

Default value: `0`

Values:
0
: No time limit.
>0
: Stop cut generation after the given number of seconds.
"""
global const XPRS_MAXCUTTIME = Int32(8149)
export XPRS_MAXCUTTIME

"""
    XPRS_MAXIIS
This function controls the number of Irreducible Infeasible Sets to be found using the XPRSiisall (IIS `-a`). (integer)

Default value: `-1`

Values:
-1
: Search for all IIS.
0
: Do not search for IIS.
n>0
: Search for the first n IIS.
"""
global const XPRS_MAXIIS = Int32(8131)
export XPRS_MAXIIS

"""
    XPRS_MAXIMPLIEDBOUND
Presolve: When tighter bounds are calculated during MIP preprocessing, only bounds whose absolute value are smaller than `MAXIMPLIEDBOUND` will be applied to the problem. (double)

Default value: `1.0E+08`

Domain: [0,+INF)
"""
global const XPRS_MAXIMPLIEDBOUND = Int32(7120)
export XPRS_MAXIMPLIEDBOUND

"""
    XPRS_MAXLOCALBACKTRACK
Branch-and-Bound: How far back up the current dive path the optimizer is allowed to look for a local backtrack candidate node. (integer)

Default value: `-1`

Values:
-1
: Automatic.
n>0
: Local backtrack limit.
"""
global const XPRS_MAXLOCALBACKTRACK = Int32(8257)
export XPRS_MAXLOCALBACKTRACK

"""
    XPRS_MAXMCOEFFBUFFERELEMS
The maximum number of matrix coefficients to buffer before flushing into the internal representation of the problem. (integer)

Buffering coefficients can offer a significant performance gain when you are building a matrix using XPRSchgcoef or XPRSchgmcoef, but can lead to a significant memory overhead for large matrices, which this control allows you to influence.

Default value: `2147483647`

Domain: 0~+INF
"""
global const XPRS_MAXMCOEFFBUFFERELEMS = Int32(8091)
export XPRS_MAXMCOEFFBUFFERELEMS

"""
    XPRS_MAXMEMORYHARD
This control sets the maximum amount of memory in megabytes the optimizer should allocate. (integer)

If this limit is exceeded, the solve will terminate. This control is designed to make the optimizer stop in a controlled manner, so that the problem object is valid once termination occurs. The solve state will be set to incomplete. This is different to an out of memory condition in which case the optimizer returns an error. The optimizer may still allocate memory once the limit is exceeded to be able to finsish the operations and stop in a controlled manner. When RESOURCESTRATEGY is enabled, the control also has the same effect as MAXMEMORYSOFT and will cause the optimizer to try preserving memory when possible.

Default value: `0 (no limit)`

Domain: 0~+INF
"""
global const XPRS_MAXMEMORYHARD = Int32(8119)
export XPRS_MAXMEMORYHARD

"""
    XPRS_MAXMEMORYSOFT
When RESOURCESTRATEGY is enabled, this control sets the maximum amount of memory in megabytes the optimizer targets to allocate. (integer)

This may change the solving path, but will not cause the solve to terminate early. To set a hard version of the same, please set MAXMEMORYHARD.

Default value: `0 (no limit)`

Domain: 0~+INF
"""
global const XPRS_MAXMEMORYSOFT = Int32(8112)
export XPRS_MAXMEMORYSOFT

"""
    XPRS_MAXMIPSOL
Branch and Bound: This specifies a limit on the number of integer solutions to be found by the Optimizer. (integer)

It is possible that during optimization the Optimizer will find the same objective solution from different nodes. However, `MAXMIPSOL` refers to the total number of integer solutions found, and not necessarily the number of distinct solutions.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_MAXMIPSOL = Int32(8021)
export XPRS_MAXMIPSOL

"""
    XPRS_MAXMIPTASKS
Branch-and-Bound: The maximum number of tasks to run in parallel during a MIP solve. (integer)

Default value: `-1`

Values:
-1
: Task limit determined automatically from `MIPTHREADS`.
>0
: Fixed task limit.
"""
global const XPRS_MAXMIPTASKS = Int32(8347)
export XPRS_MAXMIPTASKS

"""
    XPRS_MAXNODE
Branch and Bound: The maximum number of nodes that will be explored. (integer)

Default value: `2147483647`

Domain: 0~+INF
"""
global const XPRS_MAXNODE = Int32(8018)
export XPRS_MAXNODE

"""
    XPRS_MAXPAGELINES
Number of lines between page breaks in printable output. (integer)

Default value: `23`

Domain: 0~+INF
"""
global const XPRS_MAXPAGELINES = Int32(8034)
export XPRS_MAXPAGELINES

"""
    XPRS_MAXSCALEFACTOR
This determines the maximum scaling factor that can be applied during scaling. (integer)

The maximum is provided as an exponent of a power of 2.

Default value: `64`

Values:
0-64
: The maximum is provided an exponent of a power of 2.
"""
global const XPRS_MAXSCALEFACTOR = Int32(8275)
export XPRS_MAXSCALEFACTOR

"""
    XPRS_MAXSTALLTIME
The maximum time in seconds that the Optimizer will continue to search for improving solution after finding a new incumbent. (double)

Default value: `0`

Values:
0
: No stall time limit.
>0
: If an integer solution has been found, stop MIP search after the given number of seconds without a new incumbent. No effect as long as no solution was found.
"""
global const XPRS_MAXSTALLTIME = Int32(8443)
export XPRS_MAXSTALLTIME

"""
    XPRS_MAXTIME
**Deprecated**The maximum time in seconds that the Optimizer will run before it terminates, including the problem setup time and solution time. (integer)

For MIP problems, this is the total time taken to solve all nodes.

Default value: `0`

Values:
0
: No time limit.
n>0
: If an integer solution has been found, stop MIP search after n seconds, otherwise continue until an integer solution is finally found.
n<0
: Stop in LP or MIP search after n seconds.
"""
global const XPRS_MAXTIME = Int32(8020)
export XPRS_MAXTIME

"""
    XPRS_MAXTREEFILESIZE
The maximum size, in megabytes, to which the tree file may grow, or 0 for no limit. (integer)

When the tree file reaches this limit, a second tree file will be created. Useful if you are using a filesystem that puts a maximum limit on the size of a file.

Default value: `0`

Domain: 0~+INF
"""
global const XPRS_MAXTREEFILESIZE = Int32(8245)
export XPRS_MAXTREEFILESIZE

"""
    XPRS_MCFCUTSTRATEGY
Level of Multi-Commodity Flow (MCF) cutting planes separation: This specifies how much aggresively MCF cuts should be separated. (integer)

If the separation of MCF cuts is enabled, Xpress will try to detect a MCF network structure in the problem and, if such a structure is identified, it will separate specific cutting planes exploiting the identified network.

Default value: `-1`

Values:
-1
: Automatic - let the Optimizer decide.
0
: Separation of MCF cuts disabled.
1
: Moderate separation of MCF cuts.
2
: Aggressive separation of MCF cuts.
"""
global const XPRS_MCFCUTSTRATEGY = Int32(8486)
export XPRS_MCFCUTSTRATEGY

"""
    XPRS_MIPABSCUTOFF
Branch and Bound: If the user knows that they are interested only in values of the objective function which are better than some value, this can be assigned to `MIPABSCUTOFF`. (double)

This allows the Optimizer to ignore solving any nodes which may yield worse objective values, saving solution time. When a MIP solution is found a new cut off value is calculated and the value can be obtained from the CURRMIPCUTOFF attribute. The value of CURRMIPCUTOFF is calculated using the `MIPRELCUTOFF` and `MIPADDCUTOFF` controls.

Default value: `1.0E+40` (for minimization problems); `-1.0E+40` (for maximization problems).

Domain: [-INF,+INF]
"""
global const XPRS_MIPABSCUTOFF = Int32(7013)
export XPRS_MIPABSCUTOFF

"""
    XPRS_MIPABSGAPNOTIFY
Branch and bound: if the `gapnotify` callback has been set using XPRSaddcbgapnotify, then this callback will be triggered during the tree search when the absolute gap reaches or passes the value you set of the `MIPRELGAPNOTIFY` control. (double)

Default value: `-1.0`

Domain: -1,[0.0,+INF]
"""
global const XPRS_MIPABSGAPNOTIFY = Int32(7064)
export XPRS_MIPABSGAPNOTIFY

"""
    XPRS_MIPABSGAPNOTIFYBOUND
Branch and bound: if the `gapnotify` callback has been set using XPRSaddcbgapnotify, then this callback will be triggered during the tree search when the best bound reaches or passes the value you set of the `MIPRELGAPNOTIFYBOUND` control. (double)

Default value: `1.0E+20` (for minimization problems); `-1.0E+20` (for maximization problems)

Domain: [-1E+40,+1E+40]
"""
global const XPRS_MIPABSGAPNOTIFYBOUND = Int32(7109)
export XPRS_MIPABSGAPNOTIFYBOUND

"""
    XPRS_MIPABSGAPNOTIFYOBJ
Branch and bound: if the `gapnotify` callback has been set using XPRSaddcbgapnotify, then this callback will be triggered during the tree search when the best solution value reaches or passes the value you set of the `MIPRELGAPNOTIFYOBJ` control. (double)

Default value: `-1.0E+20` (for minimization problems); `1.0E+20` (for maximization problems)

Domain: [-1E+40,+1E+40]
"""
global const XPRS_MIPABSGAPNOTIFYOBJ = Int32(7108)
export XPRS_MIPABSGAPNOTIFYOBJ

"""
    XPRS_MIPABSSTOP
Branch and Bound: The absolute tolerance determining whether the tree search will continue or not. (double)

It will terminate if |`MIPOBJVAL - BESTBOUND`| `<=` `MIPABSSTOP` where MIPOBJVAL is the value of the best solution's objective function, and BESTBOUND is the current best solution bound. For example, to stop the tree search when a MIP solution has been found and the Optimizer can guarantee it is within 100 of the optimal solution, set `MIPABSSTOP` to 100.

Default value: `0.0`

Domain: [-INF,+INF]
"""
global const XPRS_MIPABSSTOP = Int32(7019)
export XPRS_MIPABSSTOP

"""
    XPRS_MIPADDCUTOFF
Branch and Bound: The amount to add to the objective function of the best integer solution found to give the new CURRMIPCUTOFF. (double)

Once an integer solution has been found whose objective function is equal to or better than CURRMIPCUTOFF, improvements on this value may not be interesting unless they are better by at least a certain amount. If `MIPADDCUTOFF` is nonzero, it will be added to CURRMIPCUTOFF each time an integer solution is found which is better than this new value. This cuts off sections of the tree whose solutions would not represent substantial improvements in the objective function, saving processor time. The control MIPABSSTOP provides a similar function but works in a different way.

Default value: `-1.0E-05`

Domain: [-INF,+INF]
"""
global const XPRS_MIPADDCUTOFF = Int32(7012)
export XPRS_MIPADDCUTOFF

"""
    XPRS_MIPCOMPONENTS
Determines whether disconnected components in a MIP should be solved as separate MIPs. (integer)

There can be significant performence benefits from solving disconnected components individual instead of being part of the main branch-and-bound search.

Default value: `-1`

Values:
-1
: Automatic - let the solver decide.
0
: Disable solving disconnected components separately.
1
: Solve disconnected components separately.
"""
global const XPRS_MIPCOMPONENTS = Int32(8421)
export XPRS_MIPCOMPONENTS

"""
    XPRS_MIPCONCURRENTNODES
Sets the node limit for when a winning solve is selected when concurrent MIP solves are enabled. (integer)

When multiple MIP solves are started, they each run up to the `MIPCONCURRENTNODES` node limit and only one winning solve is selected for contuinuing the search with.

Default value: `-1`

Values:
-1
: Automatic - let the solver decide on a node limit.
>0
: Number of nodes each concurrent solve should complete before a winner is selected.
"""
global const XPRS_MIPCONCURRENTNODES = Int32(8422)
export XPRS_MIPCONCURRENTNODES

"""
    XPRS_MIPCONCURRENTSOLVES
Selects the number of concurrent solves to start for a MIP. (integer)

Each solve will use a unique random seed for its random number generator, but will otherwise apply the same user controls. The first concurrent solve to complete will have solved the MIP and all the concurrent solves will be terminated at this point. Using concurrent solves can be advantageous when a MIP displays a high level of performance variability.

Default value: `0`

Values:
-1
: Enabled. The number of concurrent solves depends on MIPTHREADS.
0, 1
: Disabled
n>1
: Enabled. The number of concurrent solves to start is given by `n`.
"""
global const XPRS_MIPCONCURRENTSOLVES = Int32(8423)
export XPRS_MIPCONCURRENTSOLVES

"""
    XPRS_MIPDUALREDUCTIONS
Branch and Bound: Limits operations that can reduce the MIP solution space. (integer)

Default value: `1`

Values:
2
: Allow dual reductions on continuous variables only.
1
: Allow all dual reductions.
0
: Prevent all dual reductions.
"""
global const XPRS_MIPDUALREDUCTIONS = Int32(8392)
export XPRS_MIPDUALREDUCTIONS

"""
    XPRS_MIPFRACREDUCE
Branch and Bound: Specifies how often the optimizer should run a heuristic to reduce the number of fractional integer variables in the node LP solutions. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disabled.
1
: Run before and after cutting on the root node.
2
: Run also during root cutting.
3
: Run also during the tree search.
"""
global const XPRS_MIPFRACREDUCE = Int32(8270)
export XPRS_MIPFRACREDUCE

"""
    XPRS_MIPKAPPAFREQ
Branch and Bound: Specifies how frequently the basis condition number (also known as kappa) should be calculated during the branch-and-bound search. (integer)

Default value: `0`

Values:
0
: Do not calculate condition numbers.
1
: Calculate conditions numbers on every node, including after each round of root cutting.
n>1
: Calculate a condition number once per node of every n'th level of the branch-and-bound tree.
"""
global const XPRS_MIPKAPPAFREQ = Int32(8386)
export XPRS_MIPKAPPAFREQ

"""
    XPRS_MIPLOG
MIP log print control. (integer)

Default value: `-100`

Values:
-n
: Print out summary log at each nth node.
0
: No printout during MIP tree search.
1
: Only print out summary statement at the end.
2
: Print out detailed log at all solutions found.
3
: Print out detailed log at each node.
"""
global const XPRS_MIPLOG = Int32(8028)
export XPRS_MIPLOG

"""
    XPRS_MIPPRESOLVE
Branch and Bound: Type of integer processing to be performed. (integer)

If set to `0`, no processing will be performed.

Default value: -1

Values are a bitset:
bit 0
: Reduced cost fixing will be performed at each node. This can simplify the node before it is solved, by deducing that certain variables' values can be fixed based on additional bounds imposed on other variables at this node.
bit 1
: Primal reductions will be performed at each node. Uses constraints of the node to tighten the range of variables, often resulting in fixing their values. This greatly simplifies the problem and may even determine optimality or infeasibility of the node before the simplex method commences.
bit 2
: [Unused] This bit is no longer used to control probing. Refer to the integer control PREPROBING for setting probing level during presolve.
bit 3
: If node preprocessing is allowed to change bounds on continuous columns.
bit 4
: Dual reductions will be performed at each node.
bit 5
: Allow global (non-bound) tightening of the problem during the tree search.
bit 6
: The objective function will be used to find reductions at each node.
bit 7
: [Unused] This bit is no longer used to control restarts. Refer to the integer control MIPRESTART for disabling tree restarts.
bit 8
: Allow that symmetry is used to presolve the node problem.
"""
global const XPRS_MIPPRESOLVE = Int32(8078)
export XPRS_MIPPRESOLVE

"""
    XPRS_MIPRAMPUP
Controls the strategy used by the parallel MIP solver during the ramp-up phase of a branch-and-bound tree search. (integer)

Default value: -1

Values:
-1
: Automatically determined.
0
: No special treatment during the ramp-up phase. Always run with the maximal number of tasks.
1
: Limit the number of tasks until the initial dives have completed.
"""
global const XPRS_MIPRAMPUP = Int32(8255)
export XPRS_MIPRAMPUP

"""
    XPRS_MIPREFINEITERLIMIT
This defines an effort limit expressed as simplex iterations for the MIP solution refiner. (integer)

The limit is per reoptimizations in the MIP refiner.

Default value: `-1` determined automatically.``

Domain: -1~+INF
"""
global const XPRS_MIPREFINEITERLIMIT = Int32(8095)
export XPRS_MIPREFINEITERLIMIT

"""
    XPRS_MIPRELCUTOFF
Branch and Bound: Percentage of the incumbent value to be added to the value of the objective function when an integer solution is found, to give the new value of CURRMIPCUTOFF. (double)

The effect is to cut off the search in parts of the tree whose best possible objective function would not be substantially better than the current solution. The control `MIPRELSTOP` provides a similar functionality but works in a different way.

Default value: `1.0E-04`

Domain: [-INF,+INF]
"""
global const XPRS_MIPRELCUTOFF = Int32(7014)
export XPRS_MIPRELCUTOFF

"""
    XPRS_MIPRELGAPNOTIFY
Branch and bound: if the `gapnotify` callback has been set using XPRSaddcbgapnotify, then this callback will be triggered during the branch and bound tree search when the relative gap reaches or passes the value you set of the `MIPRELGAPNOTIFY` control. (double)

Default value: `-1.0`

Domain: -1,[0.0,+INF]
"""
global const XPRS_MIPRELGAPNOTIFY = Int32(7065)
export XPRS_MIPRELGAPNOTIFY

"""
    XPRS_MIPRELSTOP
Branch and Bound: This determines when the branch and bound tree search will terminate. (double)

Branch and bound tree search will stop if: |`MIPOBJVAL - BESTBOUND`| `<=` `MIPRELSTOP` x max(|`BESTBOUND`|,|`MIPOBJVAL`|) where MIPOBJVAL is the value of the best solution's objective function and BESTBOUND is the current best solution bound. For example, to stop the tree search when a MIP solution has been found and the Optimizer can guarantee it is within 5 of the optimal solution, set `MIPRELSTOP` to 0.05.

Default value: `0.0001`

Domain: [-INF,+INF]
"""
global const XPRS_MIPRELSTOP = Int32(7020)
export XPRS_MIPRELSTOP

"""
    XPRS_MIPRESTART
Branch and Bound: controls strategy for in-tree restarts. (integer)

Default value: `-1`

Values:
-1
: Determined automatically (`XPRS_MIPRESTART_DEFAULT`).
0
: Disable in-tree restarts (`XPRS_MIPRESTART_OFF`).
1
: Allow in-tree restarts at normal aggressiveness (`XPRS_MIPRESTART_MODERATE`).
2
: Allow in-tree restarts at higher aggressiveness (more likely to trigger a restart) (`XPRS_MIPRESTART_AGGRESSIVE`).
"""
global const XPRS_MIPRESTART = Int32(8290)
export XPRS_MIPRESTART

"""
    XPRS_MIPRESTARTFACTOR
Branch and Bound: Fine tune initial conditions to trigger an in-tree restart. (double)

Use a value > 1 to increase the aggressiveness with which the Optimizer restarts. Use a value < 1 to relax the aggressiveness with which the Optimizer restarts. Note that this control does not affect the initial condition on the gap, which must be set separately.

Default value: `1.0`

Domain: (0,+INF]
"""
global const XPRS_MIPRESTARTFACTOR = Int32(7145)
export XPRS_MIPRESTARTFACTOR

"""
    XPRS_MIPRESTARTGAPTHRESHOLD
Branch and Bound: Initial gap threshold to delay in-tree restart. (double)

The restart is delayed initially if the gap, given as a fraction between 0 and 1, is below this threshold. The optimizer adjusts the threshold every time a restart is delayed. Note that there are other criteria that can delay or prevent a restart.

Default value: `0.02`

Domain: [0.0, 1.0]
"""
global const XPRS_MIPRESTARTGAPTHRESHOLD = Int32(7140)
export XPRS_MIPRESTARTGAPTHRESHOLD

"""
    XPRS_MIPTERMINATIONMETHOD
Branch and Bound: How a MIP solve should be stopped on early termination when there are still active tasks in the system. (integer)

This can happen when, for example, a time or node limit is reached.

Default value: `0`

Values:
0
: Terminate tasks at the earliest opportunity. This can result in some unfinished node solves being discarded, although never integer solutions.
1
: Allow tasks to complete their current work but prevent new tasks from being started.
"""
global const XPRS_MIPTERMINATIONMETHOD = Int32(8348)
export XPRS_MIPTERMINATIONMETHOD

"""
    XPRS_MIPTHREADS
If set to a positive integer it determines the number of threads implemented to run the parallel MIP code. (integer)

If `MIPTHREADS` is set to the default value (`-1`), the THREADS control will determine the number of threads used.

Default value: `-1` (determined by the `THREADS` control)

Domain: -1~+INF
"""
global const XPRS_MIPTHREADS = Int32(8079)
export XPRS_MIPTHREADS

"""
    XPRS_MIPTOL
Branch and Bound: This is the tolerance within which a decision variable's value is considered to be integral. (double)

Default value: `5.0E-06`

Domain: (0,+INF]
"""
global const XPRS_MIPTOL = Int32(7009)
export XPRS_MIPTOL

"""
    XPRS_MIPTOLTARGET
Target MIPTOL value used by the automatic MIP solution refiner as defined by REFINEOPS. (double)

Negative and zero values are ignored.

Default value: `0.0`

Domain: (0,+INF]
"""
global const XPRS_MIPTOLTARGET = Int32(7010)
export XPRS_MIPTOLTARGET

"""
    XPRS_MIQCPALG
This control determines which algorithm is to be used to solve mixed integer quadratic constrained and mixed integer second order cone problems. (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: Use the barrier algorithm in the branch and bound algorithm.
1
: Use outer approximations in the branch and bound algorithm.
"""
global const XPRS_MIQCPALG = Int32(8125)
export XPRS_MIQCPALG

"""
    XPRS_MPS18COMPATIBLE
Provides compatibility of MPS file output for older MPS readers. (integer)

Default value: `0`

Values:
Bit 0
: Do not write objective sense (OBJSENSE section).
Bit 1
: Fixed binaries are written as fixed only (unless used as a base variable for an indicator constraint).
"""
global const XPRS_MPS18COMPATIBLE = Int32(8223)
export XPRS_MPS18COMPATIBLE

"""
    XPRS_MPSBOUNDNAME
When reading an MPS file, this control determines which entries from the `BOUNDS` section will be read. (string)

As with all string controls, this is of length 64 characters plus a null terminator, `0`.

Default value: 64 blanks

Domain: ?
"""
global const XPRS_MPSBOUNDNAME = Int32(6004)
export XPRS_MPSBOUNDNAME

"""
    XPRS_MPSECHO
Determines whether comments in MPS matrix files are to be printed out during matrix input. (integer)

Default value: `0`

Values:
0
: MPS comments are not to be echoed.
1
: MPS comments are to be echoed.
"""
global const XPRS_MPSECHO = Int32(8032)
export XPRS_MPSECHO

"""
    XPRS_MPSFORMAT
Specifies the format of MPS files. (integer)

Default value: `1`

Values:
-1
: To determine the file type automatically.
0
: For fixed format.
1
: If MPS files are assumed to be in free format by input.
"""
global const XPRS_MPSFORMAT = Int32(8137)
export XPRS_MPSFORMAT

global const XPRS_MPSNAMELENGTH = Int32(8071)
export XPRS_MPSNAMELENGTH

"""
    XPRS_MPSOBJNAME
When reading an MPS file, this control determines which neutral row will be read as the objective function. (string)

If this control is set when reading a multi-objective MPS file, only the named objective will be read; all other objectives will be ignored. As with all string controls, this is of length 64 characters plus a null terminator, `0`.

Default value: 64 blanks

Domain: ?
"""
global const XPRS_MPSOBJNAME = Int32(6002)
export XPRS_MPSOBJNAME

"""
    XPRS_MPSRANGENAME
When reading an MPS file, this control determines which entries from the `RANGES` section will be read. (string)

As with all string controls, this is of length 64 characters plus a null terminator, `0`.

Default value: 64 blanks

Domain: ?
"""
global const XPRS_MPSRANGENAME = Int32(6003)
export XPRS_MPSRANGENAME

"""
    XPRS_MPSRHSNAME
When reading an MPS file, this control determines which entries from the `RHS` section will be read. (string)

As with all string controls, this is of length 64 characters plus a null terminator, `0`.

Default value: 64 blanks

Domain: ?
"""
global const XPRS_MPSRHSNAME = Int32(6001)
export XPRS_MPSRHSNAME

global const XPRS_MSMAXBOUNDRANGE = Int32(12204)
export XPRS_MSMAXBOUNDRANGE

"""
    XPRS_MULTIOBJLOG
Log level for multi-objective optimization. (integer)

Default value: `2`

Values:
0
: No logging.
1
: Print a summary of each problem that is solved as part of the multi-objective optimization.
2
: In addition to summaries, print messages produced by each solve at the level determined by OUTPUTLOG.
"""
global const XPRS_MULTIOBJLOG = Int32(8458)
export XPRS_MULTIOBJLOG

"""
    XPRS_MULTIOBJOPS
Modifies the behaviour of the optimizer when solving multi-objective problems. (integer)

Default value: `7` (all bits are set)

Values are a bitset:
bit 0
: `XPRS_MULTIOBJOPS_ENABLED`Multi-objective enabled. If this bit is not set, multi-objective problems will treated as single-objective problems, and only objective `0` will be optimized.
bit 1
: `XPRS_MULTIOBJOPS_PRESOLVE`Apply multi-objective modifications during presolve. If this bit is not set, the original problem will be modified when solving each subsequent objective, and these modifications will remain in the problem after the solve has completed.
bit 2
: `XPRS_MULTIOBJOPS_RCFIXING`Reduced cost fixing. If this bit is set, optimality of earlier objectives will be preserved by fixing all non-basic variables with non-zero reduced costs to their bounds. If not set, optimality of earlier objectives will be preserved by adding constraints to the problem.
"""
global const XPRS_MULTIOBJOPS = Int32(8457)
export XPRS_MULTIOBJOPS

global const XPRS_MULTISTART = Int32(12362)
export XPRS_MULTISTART

global const XPRS_MULTISTART_LOG = Int32(12395)
export XPRS_MULTISTART_LOG

global const XPRS_MULTISTART_MAXSOLVES = Int32(12364)
export XPRS_MULTISTART_MAXSOLVES

global const XPRS_MULTISTART_MAXTIME = Int32(12365)
export XPRS_MULTISTART_MAXTIME

global const XPRS_MULTISTART_POOLSIZE = Int32(12397)
export XPRS_MULTISTART_POOLSIZE

global const XPRS_MULTISTART_SEED = Int32(12396)
export XPRS_MULTISTART_SEED

global const XPRS_MULTISTART_THREADS = Int32(12363)
export XPRS_MULTISTART_THREADS

"""
    XPRS_MUTEXCALLBACKS
Branch and Bound: This determines whether the callback routines are mutexed from within the optimizer. (integer)

Default value: 1

Values:
0
: Callbacks are not mutexed.
1
: Callbacks are mutexed.
"""
global const XPRS_MUTEXCALLBACKS = Int32(8210)
export XPRS_MUTEXCALLBACKS

global const XPRS_NETCUTS = Int32(8382)
export XPRS_NETCUTS

"""
    XPRS_NETSTALLLIMIT
Limit the number of degenerate pivots of the network simplex algorithm, before switching to either primal or dual simplex, depending on `ALGAFTERNETWORK`. (integer)

Default value: -1

Values:
-1
: Automatically determined limit
0
: No limit.
n>0
: Limit to n network simplex iterations.
"""
global const XPRS_NETSTALLLIMIT = Int32(8412)
export XPRS_NETSTALLLIMIT

global const XPRS_NLPCALCTHREADS = Int32(12405)
export XPRS_NLPCALCTHREADS

global const XPRS_NLPDEFAULTIV = Int32(12145)
export XPRS_NLPDEFAULTIV

global const XPRS_NLPDERIVATIVES = Int32(12373)
export XPRS_NLPDERIVATIVES

global const XPRS_NLPDETERMINISTIC = Int32(12399)
export XPRS_NLPDETERMINISTIC

global const XPRS_NLPEVALUATE = Int32(12334)
export XPRS_NLPEVALUATE

global const XPRS_NLPFINDIV = Int32(12413)
export XPRS_NLPFINDIV

global const XPRS_NLPFUNCEVAL = Int32(12312)
export XPRS_NLPFUNCEVAL

global const XPRS_NLPHESSIAN = Int32(12361)
export XPRS_NLPHESSIAN

global const XPRS_NLPINFINITY = Int32(12119)
export XPRS_NLPINFINITY

global const XPRS_NLPJACOBIAN = Int32(12360)
export XPRS_NLPJACOBIAN

global const XPRS_NLPLINQUADBR = Int32(12414)
export XPRS_NLPLINQUADBR

global const XPRS_NLPLOG = Int32(12316)
export XPRS_NLPLOG

global const XPRS_NLPMAXTIME = Int32(12366)
export XPRS_NLPMAXTIME

global const XPRS_NLPMERITLAMBDA = Int32(12197)
export XPRS_NLPMERITLAMBDA

global const XPRS_NLPPOSTSOLVE = Int32(12398)
export XPRS_NLPPOSTSOLVE

global const XPRS_NLPPRESOLVE = Int32(12344)
export XPRS_NLPPRESOLVE

global const XPRS_NLPPRESOLVELEVEL = Int32(12402)
export XPRS_NLPPRESOLVELEVEL

global const XPRS_NLPPRESOLVEOPS = Int32(12393)
export XPRS_NLPPRESOLVEOPS

global const XPRS_NLPPRESOLVEZERO = Int32(12193)
export XPRS_NLPPRESOLVEZERO

global const XPRS_NLPPRESOLVE_ELIMTOL = Int32(12206)
export XPRS_NLPPRESOLVE_ELIMTOL

global const XPRS_NLPPRIMALINTEGRALALPHA = Int32(12176)
export XPRS_NLPPRIMALINTEGRALALPHA

global const XPRS_NLPPRIMALINTEGRALREF = Int32(12175)
export XPRS_NLPPRIMALINTEGRALREF

global const XPRS_NLPPROBING = Int32(12403)
export XPRS_NLPPROBING

global const XPRS_NLPREFORMULATE = Int32(12392)
export XPRS_NLPREFORMULATE

global const XPRS_NLPSOLVER = Int32(12417)
export XPRS_NLPSOLVER

global const XPRS_NLPSTOPOUTOFRANGE = Int32(12354)
export XPRS_NLPSTOPOUTOFRANGE

global const XPRS_NLPTHREADS = Int32(12406)
export XPRS_NLPTHREADS

global const XPRS_NLPTHREADSAFEUSERFUNC = Int32(12359)
export XPRS_NLPTHREADSAFEUSERFUNC

global const XPRS_NLPVALIDATIONFACTOR = Int32(12211)
export XPRS_NLPVALIDATIONFACTOR

global const XPRS_NLPVALIDATIONTARGET_K = Int32(12210)
export XPRS_NLPVALIDATIONTARGET_K

global const XPRS_NLPVALIDATIONTARGET_R = Int32(12209)
export XPRS_NLPVALIDATIONTARGET_R

global const XPRS_NLPVALIDATIONTOL_A = Int32(12165)
export XPRS_NLPVALIDATIONTOL_A

global const XPRS_NLPVALIDATIONTOL_K = Int32(12205)
export XPRS_NLPVALIDATIONTOL_K

global const XPRS_NLPVALIDATIONTOL_R = Int32(12166)
export XPRS_NLPVALIDATIONTOL_R

global const XPRS_NLPZERO = Int32(12123)
export XPRS_NLPZERO

"""
    XPRS_NODEPROBINGEFFORT
Adjusts the overall level of node probing. (double)

Default value: `1.0`

Domain: [0,+INF]
"""
global const XPRS_NODEPROBINGEFFORT = Int32(7141)
export XPRS_NODEPROBINGEFFORT

"""
    XPRS_NODESELECTION
Branch and Bound: This determines which nodes will be considered for solution once the current node has been solved. (integer)

Default value: Dependent on the matrix characteristics.

Values:
1
: Local first: Choose between descendant and sibling nodes if available; choose from all outstanding nodes otherwise.
2
: Best first: Choose from all outstanding nodes.
3
: Local depth first: Choose between descendant and sibling nodes if available; choose from the deepest nodes otherwise.
4
: Best first, then local first: Best first is used for the first BREADTHFIRST nodes, after which local first is used.
5
: Pure depth first: Choose from the deepest outstanding nodes.
"""
global const XPRS_NODESELECTION = Int32(8026)
export XPRS_NODESELECTION

"""
    XPRS_NUMERICALEMPHASIS
How much emphasis to place on numerical stability instead of solve speed. (integer)

Default value: -1

Values:
-1
: Automatic. The emphasis might be influenced by the setting of other controls.
0
: Emphasize speed.
1
: Mild emphasis on numerical stability.
2
: Medium emphasis on numerical stability.
3
: Strong emphasis on numerical stability.
"""
global const XPRS_NUMERICALEMPHASIS = Int32(8416)
export XPRS_NUMERICALEMPHASIS

"""
    XPRS_OBJSCALEFACTOR
Custom objective scaling factor, expressed as a power of 2. (double)

When set, it overwrites the automatic objective scaling factor. A value of 0 means no objective scaling. This control is applied for the full solve, and is independent of any extra scaling that may occur specifically for the barrier or simplex solvers. As it is a power of 2, to scale by 16, set the value of the control to 4.

Default value: `0`

Domain: (-64, +64]
"""
global const XPRS_OBJSCALEFACTOR = Int32(8387)
export XPRS_OBJSCALEFACTOR

"""
    XPRS_OPTIMALITYTOL
Simplex: This is the zero tolerance for reduced costs. (double)

On each iteration, the simplex method searches for a variable to enter the basis which has a negative reduced cost. The candidates are only those variables which have reduced costs less than the negative value of `OPTIMALITYTOL`.

Default value: `1.0E-06`

Domain: (0,+INF]
"""
global const XPRS_OPTIMALITYTOL = Int32(7006)
export XPRS_OPTIMALITYTOL

"""
    XPRS_OPTIMALITYTOLTARGET
This specifies the target optimality tolerance for the solution refiner. (double)

Default value: `0` use the value specified by OPTIMALITYTOL.``

Domain: (0,+INF]
"""
global const XPRS_OPTIMALITYTOLTARGET = Int32(7122)
export XPRS_OPTIMALITYTOLTARGET

"""
    XPRS_OUTPUTCONTROLS
This control toggles the printing of all control settings at the beginning of the search. (integer)

This includes the printing of controls that have been explicitly assigned to their default value. All unset controls are omitted as they keep their default value.

Default value: `1`

Values:
0
: Turn off printing of user-specified control settings.
1
: Print controls.
"""
global const XPRS_OUTPUTCONTROLS = Int32(8424)
export XPRS_OUTPUTCONTROLS

"""
    XPRS_OUTPUTLOG
This controls the level of output produced by the Optimizer during optimization. (integer)

In the Console Optimizer, `OUTPUTLOG` controls which messages are sent to the screen (`stdout`). When using the Optimizer library, no output is sent to the screen. If the user wishes output to be displayed, they must define a callback function and print messages to the screen themselves. In this case, `OUTPUTLOG` controls which messages are sent to the user output callback.

Default value: `1`

Values:
0
: Turn all output off. Use `XPRS_OUTPUTLOG_NO_OUTPUT` from `xprs.h`.
1
: Print all messages. Use `XPRS_OUTPUTLOG_FULL_OUTPUT` from `xprs.h`.
3
: Print error and warning messages. Use `XPRS_OUTPUTLOG_ERRORS_AND_WARNINGS` from `xprs.h`.
4
: Print error messages only. Use `XPRS_OUTPUTLOG_ERRORS` from `xprs.h`.
"""
global const XPRS_OUTPUTLOG = Int32(8035)
export XPRS_OUTPUTLOG

"""
    XPRS_OUTPUTMASK
Mask to restrict the row and column names written to file. (string)

As with all string controls, this is of length 64 characters plus a null terminator, `0`.

Default value: 64 '?'s

Domain: ?
"""
global const XPRS_OUTPUTMASK = Int32(6005)
export XPRS_OUTPUTMASK

"""
    XPRS_OUTPUTTOL
Zero tolerance on print values. (double)

Default value: `1.0E-05`

Domain: [0,+INF]
"""
global const XPRS_OUTPUTTOL = Int32(7004)
export XPRS_OUTPUTTOL

"""
    XPRS_PENALTY
Minimum absolute penalty variable coefficient. (double)

BIGM and `PENALTY` are set by the input routine (XPRSreadprob (READPROB)) but may be reset by the user prior to XPRSlpoptimize (LPOPTIMIZE).

Default value: Dependent on the matrix characteristics.

Domain: [-INF,+INF]
"""
global const XPRS_PENALTY = Int32(7016)
export XPRS_PENALTY

"""
    XPRS_PIVOTTOL
Simplex: The zero tolerance for matrix elements. (double)

On each iteration, the simplex method seeks a nonzero matrix element to pivot on. Any element with absolute value less than `PIVOTTOL` is treated as zero for this purpose.

Default value: `1.0E-09`

Domain: (0,+INF]
"""
global const XPRS_PIVOTTOL = Int32(7002)
export XPRS_PIVOTTOL

"""
    XPRS_PPFACTOR
The partial pricing candidate list sizing parameter. (double)

Default value: `1.0`

Domain: [-INF,+INF]
"""
global const XPRS_PPFACTOR = Int32(7069)
export XPRS_PPFACTOR

"""
    XPRS_PREANALYTICCENTER
Determines if analytic centers should be computed and used for variable fixing and the generation of alternative reduced costs (-1: Auto 0: Off, 1: Fixing, 2: Redcost, 3: Both) (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disable analytic center presolving.
1
: Use analytic center for variable fixing only.
2
: Use analytic center for reduced cost computation only.
3
: Use analytic centers for both, variable fixing and reduced cost computation.
"""
global const XPRS_PREANALYTICCENTER = Int32(8374)
export XPRS_PREANALYTICCENTER

"""
    XPRS_PREBASISRED
Determines if a lattice basis reduction algorithm should be attempted as part of presolve (integer)

Default value: `0`

Values:
-1
: Automatic.
0
: Disable basis reduction.
1
: Enable basis reduction.
"""
global const XPRS_PREBASISRED = Int32(8106)
export XPRS_PREBASISRED

"""
    XPRS_PREBNDREDCONE
Determines if second order cone constraints should be used for inferring bound reductions on variables when solving a MIP. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disable bound reductions from second order cone constraints.
1
: Enable bound reductions from second order cone constraints.
"""
global const XPRS_PREBNDREDCONE = Int32(8338)
export XPRS_PREBNDREDCONE

"""
    XPRS_PREBNDREDQUAD
Determines if convex quadratic constraints should be used for inferring bound reductions on variables when solving a MIP. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Disable bound reductions from quadratic constraints.
1
: Enable bound reductions from quadratic constraints.
"""
global const XPRS_PREBNDREDQUAD = Int32(8337)
export XPRS_PREBNDREDQUAD

"""
    XPRS_PRECLIQUESTRATEGY
Determines how much effort to spend on clique covers in presolve. (integer)

Default value: `-1`

Domain: -1,0~+INF
"""
global const XPRS_PRECLIQUESTRATEGY = Int32(8247)
export XPRS_PRECLIQUESTRATEGY

"""
    XPRS_PRECOEFELIM
Presolve: Specifies whether the optimizer should attempt to recombine constraints in order to reduce the number of non zero coefficients when presolving a mixed integer problem. (integer)

Default value: `2`

Values:
0
: Disabled.
1
: Remove as many coefficients as possible.
2
: Cautious eliminations. Will not perform a reduction if it might destroy problem structure useful to e.g. heuristics or cutting.
"""
global const XPRS_PRECOEFELIM = Int32(8194)
export XPRS_PRECOEFELIM

"""
    XPRS_PRECOMPONENTS
Presolve: determines whether small independent components should be detected and solved as individual subproblems during root node processing. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable detection of independent components.
1
: Enable detection of independent components.
"""
global const XPRS_PRECOMPONENTS = Int32(8339)
export XPRS_PRECOMPONENTS

"""
    XPRS_PRECOMPONENTSEFFORT
Presolve: adjusts the overall effort for the independent component presolver. (double)

This control affects working limits for the subproblem solving as well as thresholds when it is called. Increase to put more emphasis on component presolving.

Default value: 1.0

Domain: [0,+INF)
"""
global const XPRS_PRECOMPONENTSEFFORT = Int32(7124)
export XPRS_PRECOMPONENTSEFFORT

"""
    XPRS_PRECONEDECOMP
Presolve: decompose regular and rotated cones with more than two elements and apply Outer Approximation on the resulting components. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable cone decomposition.
1
: Enable cone decomposition by replacing large cones with small ones in the presolved problem.
2
: Similar to 1, plus decomposition is enabled even if the cone variable is fixed.
3
: Cones are decomposed within the Outer Approximation domain only, i.e., the problem maintains the original cones.
"""
global const XPRS_PRECONEDECOMP = Int32(8349)
export XPRS_PRECONEDECOMP

"""
    XPRS_PRECONFIGURATION
MIP Presolve: determines whether binary rows with only few repeating coefficients should be reformulated. (integer)

The reformulation enumerates the extremal feasible configurations of a row and introduces new columns and rows to model the choice between these extremal configurations. This presolve operation can be disabled as part of the (advanced) IP reductions PRESOLVEOPS.

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable configuration presolving.
"""
global const XPRS_PRECONFIGURATION = Int32(8470)
export XPRS_PRECONFIGURATION

"""
    XPRS_PRECONVERTOBJTOCONS
Presolve: convert a linear or quadratic objective function into an objective transfer constraint (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable reformulation.
1
: Move only the quadratic part of the objective into a constraint.
2
: Move both the linear and quadratic parts of the objective into a constraint.
"""
global const XPRS_PRECONVERTOBJTOCONS = Int32(8260)
export XPRS_PRECONVERTOBJTOCONS

"""
    XPRS_PRECONVERTSEPARABLE
Presolve: reformulate problems with a non-diagonal quadratic objective and/or constraints as diagonal quadratic or second-order conic constraints. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable reformulation.
1
: Enable reformulation to diagonal quadratic constraints.
2
: Enable reformulation to diagonal quadratic constraints and reduction to second-order cones.
"""
global const XPRS_PRECONVERTSEPARABLE = Int32(8128)
export XPRS_PRECONVERTSEPARABLE

"""
    XPRS_PREDOMCOL
Presolve: Determines the level of dominated column removal reductions to perform when presolving a mixed integer problem. (integer)

Only binary columns will be checked.

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disabled.
1
: Cautious strategy.
2
: All candidate binaries will be checked for domination.
"""
global const XPRS_PREDOMCOL = Int32(8195)
export XPRS_PREDOMCOL

"""
    XPRS_PREDOMROW
Presolve: Determines the level of dominated row removal reductions to perform when presolving a problem. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disabled.
1
: Cautious strategy.
2
: Medium strategy.
3
: Aggressive strategy. All candidate row combinations will be considered.
"""
global const XPRS_PREDOMROW = Int32(8281)
export XPRS_PREDOMROW

"""
    XPRS_PREDUPROW
Presolve: Determines the type of duplicate rows to look for and eliminate when presolving a problem. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Do not eliminate duplicate rows.
1
: Eliminate only rows that are identical in all variables.
2
: Same as option 1 plus eliminate duplicate rows with simple penalty variable expressions. (MIP only).
3
: Same as option 2 plus eliminate duplicate rows with more complex penalty variable expressions. (MIP only).
"""
global const XPRS_PREDUPROW = Int32(8307)
export XPRS_PREDUPROW

"""
    XPRS_PREELIMQUAD
Presolve: Allows for elimination of quadratic variables via doubleton rows. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Do not eliminate duplicate rows.
1
: Eliminate at least one quadratic variable for each doubleton row.
"""
global const XPRS_PREELIMQUAD = Int32(8353)
export XPRS_PREELIMQUAD

"""
    XPRS_PREFOLDING
Presolve: Determines if a folding procedure should be used to aggregate continuous columns in an equitable partition. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disabled.
1
: Enabled.
"""
global const XPRS_PREFOLDING = Int32(8410)
export XPRS_PREFOLDING

"""
    XPRS_PREIMPLICATIONS
Presolve: Determines whether to use implication structures to remove redundant rows. (integer)

If implication sequences are detected, they might also be used in probing.

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Do not use implications for sparsification.
1
: Use implications to remove reduandant rows.
"""
global const XPRS_PREIMPLICATIONS = Int32(8356)
export XPRS_PREIMPLICATIONS

"""
    XPRS_PRELINDEP
Presolve: Determines whether to check for and remove linearly dependent equality constraints when presolving a problem. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Do not check for linearly dependent equality constraints.
1
: Check for and remove linearly dependent equality constraints.
"""
global const XPRS_PRELINDEP = Int32(8333)
export XPRS_PRELINDEP

"""
    XPRS_PREOBJCUTDETECT
Presolve: Determines whether to check for constraints that are parallel or near parallel to a linear objective function, and which can safely be removed. (integer)

This reduction applies to MIPs only.

Default value: `1`

Values:
0
: Disable check and reductions.
1
: Enable check and reductions.
"""
global const XPRS_PREOBJCUTDETECT = Int32(8336)
export XPRS_PREOBJCUTDETECT

"""
    XPRS_PREPERMUTE
This bit vector control specifies whether to randomly permute rows, columns and MIP entities when starting the presolve. (integer)

With the default value `0`, no permutation will take place.

Default value: `0`

Values are a bitset:
bit 0
: Permute rows.
bit 1
: Permute columns.
bit 2
: Permute MIP entities. This bit only affects MIP problems.
"""
global const XPRS_PREPERMUTE = Int32(8108)
export XPRS_PREPERMUTE

"""
    XPRS_PREPERMUTESEED
This control sets the seed for the pseudo-random number generator for permuting the problem when starting the presolve. (integer)

This control only has effects when `PREPERMUTE` is enabled.

Default value: `1`

Domain: 1~+INF
"""
global const XPRS_PREPERMUTESEED = Int32(8109)
export XPRS_PREPERMUTESEED

"""
    XPRS_PREPROBING
Presolve: Amount of probing to perform on binary variables during presolve. (integer)

This is done by fixing a binary to each of its values in turn and analyzing the implications.

Default value: `-1`

Values:
-1
: Let the optimizer decide on the amount of probing.
0
: Disabled.
+1
: Light probing only few implications will be examined.
+2
: Full probing all implications for all binaries will be examined.
+3
: Full probing and repeat as long as the problem is significantly reduced.
"""
global const XPRS_PREPROBING = Int32(8238)
export XPRS_PREPROBING

"""
    XPRS_PREPROTECTDUAL
Presolve: specifies whether the presolver should protect a given dual solution by maintaining the same level of dual feasibility. (integer)

Enabling this control often results in a worse presolved model. This control only expected to be optionally enabled before calling `XPRScrossoverlpsol`.

Default value: `0`

Values:
0
: Disabled.
1
: Enabled. Protect the dual solution during presolve.
"""
global const XPRS_PREPROTECTDUAL = Int32(8293)
export XPRS_PREPROTECTDUAL

"""
    XPRS_PRESOLVE
This control determines whether presolving should be performed prior to starting the main algorithm. (integer)

Presolve attempts to simplify the problem by detecting and removing redundant constraints, tightening variable bounds, etc. In some cases, infeasibility may even be determined at this stage, or the optimal solution found.

Default value: `1`

Values:
-1
: Presolve applied, but a problem will not be declared infeasible if primal infeasibilities are detected. The problem will be solved by the LP optimization algorithm, returning an infeasible solution, which can sometimes be helpful.
0
: Presolve not applied.
1
: Presolve applied.
2
: Presolve applied, but redundant bounds are not removed. This can sometimes increase the efficiency of the barrier algorithm.
3
: Presolve is applied, and bounds detected to be redundant are always removed.
"""
global const XPRS_PRESOLVE = Int32(8011)
export XPRS_PRESOLVE

"""
    XPRS_PRESOLVEMAXGROW
Limit on how much the number of non-zero coefficients is allowed to grow during presolve, specified as a ratio of the number of non-zero coefficients in the original problem. (double)

Default value: 0.1

Domain: 0~+INF
"""
global const XPRS_PRESOLVEMAXGROW = Int32(7110)
export XPRS_PRESOLVEMAXGROW

"""
    XPRS_PRESOLVEOPS
This bit vector control specifies the operations which are performed during the presolve. (integer)

Default value: `511` (bits `0` `8` incl. are set)

Values are a bitset:
bit 0
: Singleton column removal.
bit 1
: Singleton row removal.
bit 2
: Forcing row removal.
bit 3
: Dual reductions.
bit 4
: Redundant row removal.
bit 5
: Duplicate column removal.
bit 6
: Duplicate row removal.
bit 7
: Strong dual reductions.
bit 8
: Variable eliminations.
bit 9
: No IP reductions.
bit 10
: No domain changes for MIP entities (e.g., semi-continuous detection or shifting integers).
bit 11
: No advanced IP reductions.
bit 12
: No eliminations on integers.
bit 13
: No reductions based on solution enumeration.
bit 14
: Linearly dependant row removal.
bit 15
: No integer variable and SOS detection.
bit 16
: No implied bounds.
bit 17
: No clique presolve.
bit 18
: No mod2 presolve.
"""
global const XPRS_PRESOLVEOPS = Int32(8077)
export XPRS_PRESOLVEOPS

"""
    XPRS_PRESOLVEPASSES
Number of reduction rounds to be performed in presolve (integer)

Default value: `1`

Domain: 1~+INF
"""
global const XPRS_PRESOLVEPASSES = Int32(8183)
export XPRS_PRESOLVEPASSES

"""
    XPRS_PRESORT
This bit vector control specifies whether to sort rows, columns and MIP entities by their names when starting the presolve. (integer)

With the default value `0`, no sorting will take place.

Default value: `0`

Values are a bitset:
bit 0
: Sort rows.
bit 1
: Sort columns.
bit 2
: Sort MIP entities. This bit only affects MIP problems.
"""
global const XPRS_PRESORT = Int32(8107)
export XPRS_PRESORT

"""
    XPRS_PRICINGALG
Simplex: This determines the primal simplex pricing method. (integer)

It is used to select which variable enters the basis on each iteration. In general Devex pricing requires more time on each iteration, but may reduce the total number of iterations, whereas partial pricing saves time on each iteration, but may result in more iterations.

Default value: `0`

Values:
-1
: Partial pricing.
0
: Determined automatically.
1
: Devex pricing.
2
: Steepest edge.
3
: Steepest edge with unit initial weights.
"""
global const XPRS_PRICINGALG = Int32(8013)
export XPRS_PRICINGALG

"""
    XPRS_PRIMALOPS
Primal simplex: allows fine tuning the variable selection in the primal simplex solver. (integer)

Default value: `-1`

Values are a bitset:
bit 0
: Use aggressive dj scaling.
bit 1
: Conventional dj scaling.
bit 2
: Use reluctant switching back to partial pricing.
bit 3
: Use dynamic switching between cheap and expensive pricing strategies.
bit 4
: Keep solving even after potential cycling is detected.
"""
global const XPRS_PRIMALOPS = Int32(8231)
export XPRS_PRIMALOPS

"""
    XPRS_PRIMALPERTURB
The factor by which the problem will be perturbed prior to optimization by primal simplex. (double)

A value of `0.0` results in no perturbation prior to optimization. Note the interconnection to the AUTOPERTURB control. If AUTOPERTURB is set to `1`, the decision whether to perturb or not is left to the Optimizer. When the problem is automatically perturbed in primal simplex, however, the value of PRIMALPERTURB will be used for perturbation.

Default value: `-1` determined automatically.

Domain: -1,[0,+INF]
"""
global const XPRS_PRIMALPERTURB = Int32(7024)
export XPRS_PRIMALPERTURB

"""
    XPRS_PRIMALUNSHIFT
Determines whether primal is allowed to call dual to unshift. (integer)

Default value: `0`

Values:
0
: Allow the dual algorithm to be used to unshift.
1
: Don't allow the dual algorithm to be used to unshift.
"""
global const XPRS_PRIMALUNSHIFT = Int32(8252)
export XPRS_PRIMALUNSHIFT

"""
    XPRS_PSEUDOCOST
Branch and Bound: The default pseudo cost used in estimation of the degradation associated with an unexplored node in the tree search. (double)

A pseudo cost is associated with each integer decision variable and is an estimate of the amount by which the objective function will be worse if that variable is forced to an integral value.

Default value: `0.01`

Domain: [-INF,+INF]
"""
global const XPRS_PSEUDOCOST = Int32(7015)
export XPRS_PSEUDOCOST

"""
    XPRS_PWLDUALREDUCTIONS
This parameter specifies whether dual reductions should be applied to reduce the number of columns, rows and SOS-constraints added when transforming piecewise linear objectives and constraints to MIP structs. (integer)

Default value: `1`

Values:
0
: Disabled. No dual reductions, add all columns, rows and SOS-constraints.
1
: Enabled. Only add neccessary columns, rows and sets, drop those implied by the objective sense.
"""
global const XPRS_PWLDUALREDUCTIONS = Int32(8396)
export XPRS_PWLDUALREDUCTIONS

"""
    XPRS_PWLNONCONVEXTRANSFORMATION
This control specifies the reformulation method for piecewise linear constraints at the beginning of the search. (integer)

Note that the chosen formulation will only be used if MIP entities are necessary but not if presolve detected that a convex reformulation is possible. Furthermore, the binary formulation will only be applied to piecewise linear constraints with bounded input variable, otherwise the SOS2-formulation will be used.

Default value: `-1`

Values:
-1
: Automatic.
0
: Use a formulation based on SOS2-constraints.
1
: Use a formulation based on binary variables.
"""
global const XPRS_PWLNONCONVEXTRANSFORMATION = Int32(8420)
export XPRS_PWLNONCONVEXTRANSFORMATION

"""
    XPRS_QCCUTS
Branch and Bound: Limit on the number of rounds of outer approximation cuts generated for the root node, when solving a mixed integer quadratic constrained or mixed integer second order conic problem with outer approximation. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_QCCUTS = Int32(8126)
export XPRS_QCCUTS

"""
    XPRS_QCROOTALG
This control determines which algorithm is to be used to solve the root of a mixed integer quadratic constrained or mixed integer second order cone problem, when outer approximation is used. (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: Use the barrier algorithm.
1
: Use the dual simplex on a relaxation of the problem constructed using outer approximation.
"""
global const XPRS_QCROOTALG = Int32(8127)
export XPRS_QCROOTALG

"""
    XPRS_QSIMPLEXOPS
Controls the behavior of the quadratic simplex solvers. (integer)

Default value: `0`

Values are a bitset:
bit 0
: Force traditional primal first phase.
bit 1
: Force BigM primal first phase.
bit 2
: Force traditional dual first phase.
bit 3
: Force BigM dual first phase.
bit 4
: Always use artificial bounds in dual.
bit 5
: Use original problem basis only when warmstarting the KKT.
bit 6
: Skip the primal bound flips for ranged primals (might cause more trouble than good if the bounds are very large).
bit 7
: Also do the single pivot crash.
bit 8
: Do not apply aggressive perturbation in dual.
bit 9
: Applies standard scaling to the KKT system.
bit 10
: Do not fall back to using Barrier in case of numerical difficulties with quadratic simplex during a MIP solve.
bit 11
: Use primal simplex to solve the phase 1 feasibility problem before applying quadratic primal simplex.
bit 12
: Use dual simplex to solve the phase 1 feasibility problem before applying quadratic primal simplex.
bit 13
: Use barrier algorithm to solve the phase 1 feasibility problem before applying quadratic primal simplex.
bit 14
: Use partial pricing.
bit 15
: Use full pricing.
bit 16
: Perform cleanup if a superbasic solution is provided for warm-start.
"""
global const XPRS_QSIMPLEXOPS = Int32(8288)
export XPRS_QSIMPLEXOPS

"""
    XPRS_QUADRATICUNSHIFT
Determines whether an extra solution purification step is called after a solution found by the quadratic simplex (either primal or dual). (integer)

Default value: `-1`

Values:
-1
: Determined automatically.
0
: No purification step.
1
: Always do the purification step.
"""
global const XPRS_QUADRATICUNSHIFT = Int32(8284)
export XPRS_QUADRATICUNSHIFT

"""
    XPRS_RANDOMSEED
Sets the initial seed to use for the pseudo-random number generator in the Optimizer. (integer)

The sequence of random numbers is always reset using the seed when starting a new optimization run.

Default value: `1`

Domain: 1~+INF
"""
global const XPRS_RANDOMSEED = Int32(8328)
export XPRS_RANDOMSEED

"""
    XPRS_REFACTOR
Indicates whether the optimization should restart using the current representation of the factorization in memory. (integer)

Default value: `-1`

Values:
-1
: Automatic.
0
: Do not refactor on reoptimizing.
1
: Refactor on reoptimizing.
"""
global const XPRS_REFACTOR = Int32(8052)
export XPRS_REFACTOR

"""
    XPRS_REFINEOPS
This specifies when the solution refiner should be executed to reduce solution infeasibilities. (integer)

The refiner will attempt to satisfy the target tolerances for all original linear constraints before presolve or scaling has been applied.

Default value: `19` (bits `0`, `1` and `4` are set)

Values are a bitset:
bit 0
: Run the solution refiner on an optimal solution of a continuous problem.
bit 1
: Run the solution refiner when a new solution is found during a tree search. The refiner will be applied to the presolved solution before any post-solve operations are applied.
bit 3
: Run the solution refiner on each node of the MIP search.
bit 4
: Run the solution refiner on an optimal solution before postsolve on a continuous problem.
bit 5
: Apply the iterative refiner to refine the solution.
bit 6
: Use higher precision in the iterative refinement.
bit 7
: If set, the iterative refiner will use the primal simplex algorithm.
bit 8
: If set, the iterative refiner will use the dual simplex algorithm.
bit 9
: Refine MIP solutions such that rounding them keeps the problem feasible when reoptimized.
bit 10
: Attempt to refine MIP solutions such that rounding them keeps the problem feasible when reoptimized, but accept integers solutions even if refinement fails.
"""
global const XPRS_REFINEOPS = Int32(8093)
export XPRS_REFINEOPS

"""
    XPRS_RELAXTREEMEMORYLIMIT
When the memory used by the branch and bound search tree exceeds the target specified by the TREEMEMORYLIMIT control, the optimizer will try to reduce this by writing nodes to the tree file. (double)

In rare cases, usually where the solve has many millions of very small nodes, the tree structural data (which cannot be written to the tree file) will grow large enough to approach or exceed the tree's memory target. When this happens, optimizer performance can degrade greatly as the solver makes heavy use of the tree file in preference to memory. To prevent this, the solver will automatically relax the tree memory limit when it detects this case; the `RELAXTREEMEMORYLIMIT` control specifies the proportion of the previous memory limit by which to relax it. Set `RELAXTREEMEMORYLIMIT` to `0.0` to force the Xpress Optimizer to never relax the tree memory limit in this way.

Default value: `0.1`

Domain: [0.0,+1.0]
"""
global const XPRS_RELAXTREEMEMORYLIMIT = Int32(7105)
export XPRS_RELAXTREEMEMORYLIMIT

"""
    XPRS_RELPIVOTTOL
Simplex: At each iteration a pivot element is chosen within a given column of the matrix. (double)

The relative pivot tolerance, `RELPIVOTTOL`, is the size of the element chosen relative to the largest possible pivot element in the same column.

Default value: `1.0E-06`

Domain: (0,+INF]
"""
global const XPRS_RELPIVOTTOL = Int32(7008)
export XPRS_RELPIVOTTOL

"""
    XPRS_REPAIRINDEFINITEQ
Controls if the optimizer should make indefinite quadratic matrices positive definite when it is possible. (integer)

Default value: `1`

Values:
0
: Repair if possible.
1
: Do not repair.
"""
global const XPRS_REPAIRINDEFINITEQ = Int32(8254)
export XPRS_REPAIRINDEFINITEQ

global const XPRS_REPAIRINDEFINITEQMAX = Int32(7071)
export XPRS_REPAIRINDEFINITEQMAX

"""
    XPRS_REPAIRINFEASMAXTIME
**Deprecated**Overall time limit for the repairinfeas tool (integer)

Default value: `0`

Values:
0
: No time limit.
n>0
: If an integer solution has been found, stop MIP search after n seconds, otherwise continue until an integer solution is finally found.
n<0
: Stop in LP or MIP search after n seconds.
"""
global const XPRS_REPAIRINFEASMAXTIME = Int32(8250)
export XPRS_REPAIRINFEASMAXTIME

"""
    XPRS_REPAIRINFEASTIMELIMIT
Overall time limit for the repairinfeas tool (double)

Default value: `1e+20`

Values:
>0
: Stop repairinfeas search after the given number of seconds.
"""
global const XPRS_REPAIRINFEASTIMELIMIT = Int32(7160)
export XPRS_REPAIRINFEASTIMELIMIT

"""
    XPRS_RESOURCESTRATEGY
Controls whether the optimizer is allowed to make nondeterministic decisions if memory is running low in an effort to preserve memory and finish the solve. (integer)

Available memory (or container limits) are automatically detected but can also be changed by MAXMEMORYSOFT and MAXMEMORYHARD

Default value: `0`

Values:
1
: Allow the optimizer to change the solve path if necessary to preserve memory when getting close to one of the memory limits.
"""
global const XPRS_RESOURCESTRATEGY = Int32(8297)
export XPRS_RESOURCESTRATEGY

"""
    XPRS_RLTCUTS
Determines whether RLT cuts should be separated in the Xpress Global Solver. (integer)

Default value: `-1`

Values:
-1
: The solver decides if RLT cuts are beneficial or not. This is the default setting.
0
: RLT cuts are disabled.
1
: RLT cuts are separated.
"""
global const XPRS_RLTCUTS = Int32(8476)
export XPRS_RLTCUTS

"""
    XPRS_ROOTPRESOLVE
Determines if presolving should be performed on the problem after the tree search has finished with root cutting and heuristics. (integer)

Default value: `-1`

Values:
-1
: Let the optimizer decide if the problem should be presolved again.
0
: Disabled.
+1
: Always presolve the root problem.
"""
global const XPRS_ROOTPRESOLVE = Int32(8224)
export XPRS_ROOTPRESOLVE

"""
    XPRS_SBBEST
Number of infeasible MIP entities to initialize pseudo costs for on each node. (integer)

Default value: `-1`

Values:
-1
: determined automatically.
0
: disable strong branching.
n>0
: perform strong branching on up to n entities at each node.
"""
global const XPRS_SBBEST = Int32(8147)
export XPRS_SBBEST

"""
    XPRS_SBEFFORT
Adjusts the overall amount of effort when using strong branching to select an infeasible MIP entity to branch on. (double)

Default value: `1.0`

Domain: 0~+INF
"""
global const XPRS_SBEFFORT = Int32(7086)
export XPRS_SBEFFORT

"""
    XPRS_SBESTIMATE
Branch and Bound: How to calculate pseudo costs from the local node when selecting an infeasible MIP entity to branch on. (integer)

These pseudo costs are used in combination with local strong branching and history costs to select the branch candidate.

Default value: `-1`

Values:
-1
: Automatically determined.
1-6
: Different variants of local pseudo costs.
"""
global const XPRS_SBESTIMATE = Int32(8198)
export XPRS_SBESTIMATE

"""
    XPRS_SBITERLIMIT
Number of dual iterations to perform the strong branching for each entity. (integer)

Default value: `-1` determined automatically.``

Domain: -1~+INF
"""
global const XPRS_SBITERLIMIT = Int32(8146)
export XPRS_SBITERLIMIT

"""
    XPRS_SBSELECT
The size of the candidate list of MIP entities for strong branching. (integer)

Default value: `-2`

Values:
-2
: Automatic (low effort).
-1
: Automatic (high effort).
n>=0
: Include n entities in the candidate list (but always at least `SBBEST` candidates).
"""
global const XPRS_SBSELECT = Int32(8164)
export XPRS_SBSELECT

"""
    XPRS_SCALING
This bit vector control determines how the Optimizer will rescale a model internally before optimization. (integer)

If set to `0`, no scaling will take place.

Default value: `163`, meaning bits 0, 1, 5 and 7 are set

Values are a bitset:
bit 0
: Row scaling.
bit 1
: Column scaling.
bit 2
: Row scaling again.
bit 3
: Maximum.
bit 4
: Curtis-Reid.
bit 5
: 0: scale by geometric mean.1: scale by maximum element.
bit 6
: Treat big-M rows as normal rows.
bit 7
: Scale objective function for the simplex method.
bit 8
: Exclude the quadratic part of constraint when calculating scaling factors.
bit 9
: Scale before presolve.
bit 10
: Do not scale rows up.
bit 11
: Do not scale columns down.
bit 12
: Do not apply automatic objective scaling.
bit 13
: RHS scaling.
bit 14
: Disable aggressive quadratic scaling.
bit 15
: Enable explicit linear slack scaling.
"""
global const XPRS_SCALING = Int32(8010)
export XPRS_SCALING

"""
    XPRS_SERIALIZEPREINTSOL
Setting `SERIALIZEPREINTSOL` to 1 will ensure that the `preintsol` callback is always fired in a deterministic order during a parallel MIP solve. (integer)

This applies only when the control DETERMINISTIC is set to `1`.

Default value: `0`

Values:
0
: The `preintsol` callbacks will be fired asynchronously from different threads.
1
: The `preintsol` callbacks will be fired in a deterministic order.
"""
global const XPRS_SERIALIZEPREINTSOL = Int32(8413)
export XPRS_SERIALIZEPREINTSOL

"""
    XPRS_SIFTING
Determines whether to enable sifting algorithm with the dual simplex method. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Disable sifting.
1
: Enable sifting.
"""
global const XPRS_SIFTING = Int32(8319)
export XPRS_SIFTING

"""
    XPRS_SIFTPASSES
Determines how quickly we allow to grow the worker problems during the sifting algorithm. (integer)

Using larger values can increase the number of columns added to the worker problem which often results in increased solve times for the worker problems but the number of necessary sifting iterations may be reduced. .

Default value: `4`

Domain: 1~INF
"""
global const XPRS_SIFTPASSES = Int32(8022)
export XPRS_SIFTPASSES

"""
    XPRS_SIFTPRESOLVEOPS
Determines the presolve operations for solving the subproblems during the sifting algorithm. (integer)

Default value: `-1`

Values:
-1
: Use the PRESOLVEOPS setting specified for the original problem.
>=0
: Use the value for the PRESOLVEOPS parameter for solving the subproblems during the sifting algorithm.
"""
global const XPRS_SIFTPRESOLVEOPS = Int32(8435)
export XPRS_SIFTPRESOLVEOPS

"""
    XPRS_SIFTSWITCH
Determines which algorithm to use for solving the subproblems during sifting. (integer)

Default value: `-1`

Values:
-1
: Dual simplex.
0
: Barrier.
>0
: Use the barrier algorithm while the number of dual infeasibilities is larger than this value, otherwise use dual simplex.
"""
global const XPRS_SIFTSWITCH = Int32(8425)
export XPRS_SIFTSWITCH

"""
    XPRS_SLEEPONTHREADWAIT
**Deprecated**In previous versions this was used to determine if the threads should be put into a wait state when waiting for work. (integer)

Default value: `-1`

Values:
-1
: Automatically determined depending on the CPU the Optimizer is running on.
0
: Keep the threads busy when waiting for work.
1
: Put the threads into a wait state when waiting for work.
"""
global const XPRS_SLEEPONTHREADWAIT = Int32(8302)
export XPRS_SLEEPONTHREADWAIT

global const XPRS_SLPALGORITHM = Int32(12301)
export XPRS_SLPALGORITHM

global const XPRS_SLPANALYZE = Int32(12332)
export XPRS_SLPANALYZE

global const XPRS_SLPATOL_A = Int32(12125)
export XPRS_SLPATOL_A

global const XPRS_SLPATOL_R = Int32(12126)
export XPRS_SLPATOL_R

global const XPRS_SLPAUGMENTATION = Int32(12302)
export XPRS_SLPAUGMENTATION

global const XPRS_SLPAUTOSAVE = Int32(12330)
export XPRS_SLPAUTOSAVE

global const XPRS_SLPBARCROSSOVERSTART = Int32(12408)
export XPRS_SLPBARCROSSOVERSTART

global const XPRS_SLPBARLIMIT = Int32(12303)
export XPRS_SLPBARLIMIT

global const XPRS_SLPBARSTALLINGLIMIT = Int32(12409)
export XPRS_SLPBARSTALLINGLIMIT

global const XPRS_SLPBARSTALLINGOBJLIMIT = Int32(12410)
export XPRS_SLPBARSTALLINGOBJLIMIT

global const XPRS_SLPBARSTALLINGTOL = Int32(12212)
export XPRS_SLPBARSTALLINGTOL

global const XPRS_SLPBARSTARTOPS = Int32(12411)
export XPRS_SLPBARSTARTOPS

global const XPRS_SLPBOUNDTHRESHOLD = Int32(12214)
export XPRS_SLPBOUNDTHRESHOLD

global const XPRS_SLPCASCADE = Int32(12304)
export XPRS_SLPCASCADE

global const XPRS_SLPCASCADENLIMIT = Int32(12306)
export XPRS_SLPCASCADENLIMIT

global const XPRS_SLPCASCADETOL_PA = Int32(12142)
export XPRS_SLPCASCADETOL_PA

global const XPRS_SLPCASCADETOL_PR = Int32(12143)
export XPRS_SLPCASCADETOL_PR

global const XPRS_SLPCDTOL_A = Int32(12200)
export XPRS_SLPCDTOL_A

global const XPRS_SLPCDTOL_R = Int32(12201)
export XPRS_SLPCDTOL_R

global const XPRS_SLPCLAMPSHRINK = Int32(12188)
export XPRS_SLPCLAMPSHRINK

global const XPRS_SLPCLAMPVALIDATIONTOL_A = Int32(12186)
export XPRS_SLPCLAMPVALIDATIONTOL_A

global const XPRS_SLPCLAMPVALIDATIONTOL_R = Int32(12187)
export XPRS_SLPCLAMPVALIDATIONTOL_R

global const XPRS_SLPCONVERGENCEOPS = Int32(12377)
export XPRS_SLPCONVERGENCEOPS

global const XPRS_SLPCTOL = Int32(12124)
export XPRS_SLPCTOL

global const XPRS_SLPCUTSTRATEGY = Int32(12310)
export XPRS_SLPCUTSTRATEGY

global const XPRS_SLPDAMP = Int32(12103)
export XPRS_SLPDAMP

global const XPRS_SLPDAMPEXPAND = Int32(12104)
export XPRS_SLPDAMPEXPAND

global const XPRS_SLPDAMPMAX = Int32(12137)
export XPRS_SLPDAMPMAX

global const XPRS_SLPDAMPMIN = Int32(12138)
export XPRS_SLPDAMPMIN

global const XPRS_SLPDAMPSHRINK = Int32(12105)
export XPRS_SLPDAMPSHRINK

global const XPRS_SLPDAMPSTART = Int32(12308)
export XPRS_SLPDAMPSTART

global const XPRS_SLPDEFAULTSTEPBOUND = Int32(12136)
export XPRS_SLPDEFAULTSTEPBOUND

global const XPRS_SLPDELAYUPDATEROWS = Int32(12329)
export XPRS_SLPDELAYUPDATEROWS

global const XPRS_SLPDELTACOST = Int32(12109)
export XPRS_SLPDELTACOST

global const XPRS_SLPDELTACOSTFACTOR = Int32(12139)
export XPRS_SLPDELTACOSTFACTOR

global const XPRS_SLPDELTAMAXCOST = Int32(12110)
export XPRS_SLPDELTAMAXCOST

global const XPRS_SLPDELTAOFFSET = Int32(12348)
export XPRS_SLPDELTAOFFSET

global const XPRS_SLPDELTAZLIMIT = Int32(12311)
export XPRS_SLPDELTAZLIMIT

global const XPRS_SLPDELTA_A = Int32(12106)
export XPRS_SLPDELTA_A

global const XPRS_SLPDELTA_INFINITY = Int32(12174)
export XPRS_SLPDELTA_INFINITY

global const XPRS_SLPDELTA_R = Int32(12107)
export XPRS_SLPDELTA_R

global const XPRS_SLPDELTA_X = Int32(12152)
export XPRS_SLPDELTA_X

global const XPRS_SLPDELTA_Z = Int32(12108)
export XPRS_SLPDELTA_Z

global const XPRS_SLPDELTA_ZERO = Int32(12184)
export XPRS_SLPDELTA_ZERO

global const XPRS_SLPDJTOL = Int32(12112)
export XPRS_SLPDJTOL

global const XPRS_SLPDRCOLDJTOL = Int32(12208)
export XPRS_SLPDRCOLDJTOL

global const XPRS_SLPDRCOLTOL = Int32(12196)
export XPRS_SLPDRCOLTOL

global const XPRS_SLPDRFIXRANGE = Int32(12195)
export XPRS_SLPDRFIXRANGE

global const XPRS_SLPECFCHECK = Int32(12369)
export XPRS_SLPECFCHECK

global const XPRS_SLPECFTOL_A = Int32(12189)
export XPRS_SLPECFTOL_A

global const XPRS_SLPECFTOL_R = Int32(12190)
export XPRS_SLPECFTOL_R

global const XPRS_SLPENFORCECOSTSHRINK = Int32(12203)
export XPRS_SLPENFORCECOSTSHRINK

global const XPRS_SLPENFORCEMAXCOST = Int32(12202)
export XPRS_SLPENFORCEMAXCOST

global const XPRS_SLPERRORCOST = Int32(12113)
export XPRS_SLPERRORCOST

global const XPRS_SLPERRORCOSTFACTOR = Int32(12140)
export XPRS_SLPERRORCOSTFACTOR

global const XPRS_SLPERRORMAXCOST = Int32(12114)
export XPRS_SLPERRORMAXCOST

global const XPRS_SLPERROROFFSET = Int32(12350)
export XPRS_SLPERROROFFSET

global const XPRS_SLPERRORTOL_A = Int32(12116)
export XPRS_SLPERRORTOL_A

global const XPRS_SLPERRORTOL_P = Int32(12141)
export XPRS_SLPERRORTOL_P

global const XPRS_SLPESCALATION = Int32(12169)
export XPRS_SLPESCALATION

global const XPRS_SLPETOL_A = Int32(12180)
export XPRS_SLPETOL_A

global const XPRS_SLPETOL_R = Int32(12181)
export XPRS_SLPETOL_R

global const XPRS_SLPEVTOL_A = Int32(12182)
export XPRS_SLPEVTOL_A

global const XPRS_SLPEVTOL_R = Int32(12183)
export XPRS_SLPEVTOL_R

global const XPRS_SLPEXPAND = Int32(12118)
export XPRS_SLPEXPAND

global const XPRS_SLPFEASTOLTARGET = Int32(12172)
export XPRS_SLPFEASTOLTARGET

global const XPRS_SLPFILTER = Int32(12387)
export XPRS_SLPFILTER

global const XPRS_SLPGRANULARITY = Int32(12157)
export XPRS_SLPGRANULARITY

global const XPRS_SLPGRIDHEURSELECT = Int32(12412)
export XPRS_SLPGRIDHEURSELECT

global const XPRS_SLPHEURSTRATEGY = Int32(12400)
export XPRS_SLPHEURSTRATEGY

global const XPRS_SLPINFEASLIMIT = Int32(12314)
export XPRS_SLPINFEASLIMIT

global const XPRS_SLPITERLIMIT = Int32(12315)
export XPRS_SLPITERLIMIT

global const XPRS_SLPITOL_A = Int32(12129)
export XPRS_SLPITOL_A

global const XPRS_SLPITOL_R = Int32(12130)
export XPRS_SLPITOL_R

global const XPRS_SLPLSITERLIMIT = Int32(12382)
export XPRS_SLPLSITERLIMIT

global const XPRS_SLPLSPATTERNLIMIT = Int32(12381)
export XPRS_SLPLSPATTERNLIMIT

global const XPRS_SLPLSSTART = Int32(12383)
export XPRS_SLPLSSTART

global const XPRS_SLPLSZEROLIMIT = Int32(12389)
export XPRS_SLPLSZEROLIMIT

global const XPRS_SLPMATRIXTOL = Int32(12194)
export XPRS_SLPMATRIXTOL

global const XPRS_SLPMAXWEIGHT = Int32(12120)
export XPRS_SLPMAXWEIGHT

global const XPRS_SLPMINSBFACTOR = Int32(12185)
export XPRS_SLPMINSBFACTOR

global const XPRS_SLPMINWEIGHT = Int32(12121)
export XPRS_SLPMINWEIGHT

global const XPRS_SLPMIPALGORITHM = Int32(12336)
export XPRS_SLPMIPALGORITHM

global const XPRS_SLPMIPCUTOFFCOUNT = Int32(12370)
export XPRS_SLPMIPCUTOFFCOUNT

global const XPRS_SLPMIPCUTOFFLIMIT = Int32(12340)
export XPRS_SLPMIPCUTOFFLIMIT

global const XPRS_SLPMIPCUTOFF_A = Int32(12158)
export XPRS_SLPMIPCUTOFF_A

global const XPRS_SLPMIPCUTOFF_R = Int32(12159)
export XPRS_SLPMIPCUTOFF_R

global const XPRS_SLPMIPDEFAULTALGORITHM = Int32(12343)
export XPRS_SLPMIPDEFAULTALGORITHM

global const XPRS_SLPMIPERRORTOL_A = Int32(12198)
export XPRS_SLPMIPERRORTOL_A

global const XPRS_SLPMIPERRORTOL_R = Int32(12199)
export XPRS_SLPMIPERRORTOL_R

global const XPRS_SLPMIPFIXSTEPBOUNDS = Int32(12338)
export XPRS_SLPMIPFIXSTEPBOUNDS

global const XPRS_SLPMIPITERLIMIT = Int32(12339)
export XPRS_SLPMIPITERLIMIT

global const XPRS_SLPMIPLOG = Int32(12347)
export XPRS_SLPMIPLOG

global const XPRS_SLPMIPOCOUNT = Int32(12341)
export XPRS_SLPMIPOCOUNT

global const XPRS_SLPMIPOTOL_A = Int32(12160)
export XPRS_SLPMIPOTOL_A

global const XPRS_SLPMIPOTOL_R = Int32(12161)
export XPRS_SLPMIPOTOL_R

global const XPRS_SLPMIPRELAXSTEPBOUNDS = Int32(12337)
export XPRS_SLPMIPRELAXSTEPBOUNDS

global const XPRS_SLPMTOL_A = Int32(12127)
export XPRS_SLPMTOL_A

global const XPRS_SLPMTOL_R = Int32(12128)
export XPRS_SLPMTOL_R

global const XPRS_SLPMVTOL = Int32(12133)
export XPRS_SLPMVTOL

global const XPRS_SLPOBJTHRESHOLD = Int32(12213)
export XPRS_SLPOBJTHRESHOLD

global const XPRS_SLPOBJTOPENALTYCOST = Int32(12170)
export XPRS_SLPOBJTOPENALTYCOST

global const XPRS_SLPOCOUNT = Int32(12333)
export XPRS_SLPOCOUNT

global const XPRS_SLPOPTIMALITYTOLTARGET = Int32(12173)
export XPRS_SLPOPTIMALITYTOLTARGET

global const XPRS_SLPOTOL_A = Int32(12150)
export XPRS_SLPOTOL_A

global const XPRS_SLPOTOL_R = Int32(12151)
export XPRS_SLPOTOL_R

global const XPRS_SLPPENALTYINFOSTART = Int32(12384)
export XPRS_SLPPENALTYINFOSTART

global const XPRS_SLPSAMECOUNT = Int32(12317)
export XPRS_SLPSAMECOUNT

global const XPRS_SLPSAMEDAMP = Int32(12319)
export XPRS_SLPSAMEDAMP

global const XPRS_SLPSBROWOFFSET = Int32(12351)
export XPRS_SLPSBROWOFFSET

global const XPRS_SLPSBSTART = Int32(12320)
export XPRS_SLPSBSTART

global const XPRS_SLPSHRINK = Int32(12122)
export XPRS_SLPSHRINK

global const XPRS_SLPSHRINKBIAS = Int32(12171)
export XPRS_SLPSHRINKBIAS

global const XPRS_SLPSTOL_A = Int32(12131)
export XPRS_SLPSTOL_A

global const XPRS_SLPSTOL_R = Int32(12132)
export XPRS_SLPSTOL_R

global const XPRS_SLPTRACEMASKOPS = Int32(12388)
export XPRS_SLPTRACEMASKOPS

global const XPRS_SLPUNFINISHEDLIMIT = Int32(12376)
export XPRS_SLPUNFINISHEDLIMIT

global const XPRS_SLPUPDATEOFFSET = Int32(12349)
export XPRS_SLPUPDATEOFFSET

global const XPRS_SLPVCOUNT = Int32(12356)
export XPRS_SLPVCOUNT

global const XPRS_SLPVLIMIT = Int32(12357)
export XPRS_SLPVLIMIT

global const XPRS_SLPVTOL_A = Int32(12177)
export XPRS_SLPVTOL_A

global const XPRS_SLPVTOL_R = Int32(12178)
export XPRS_SLPVTOL_R

global const XPRS_SLPWCOUNT = Int32(12374)
export XPRS_SLPWCOUNT

global const XPRS_SLPWTOL_A = Int32(12191)
export XPRS_SLPWTOL_A

global const XPRS_SLPWTOL_R = Int32(12192)
export XPRS_SLPWTOL_R

global const XPRS_SLPXCOUNT = Int32(12321)
export XPRS_SLPXCOUNT

global const XPRS_SLPXLIMIT = Int32(12322)
export XPRS_SLPXLIMIT

global const XPRS_SLPXTOL_A = Int32(12134)
export XPRS_SLPXTOL_A

global const XPRS_SLPXTOL_R = Int32(12135)
export XPRS_SLPXTOL_R

global const XPRS_SLPZEROCRITERION = Int32(12378)
export XPRS_SLPZEROCRITERION

global const XPRS_SLPZEROCRITERIONCOUNT = Int32(12380)
export XPRS_SLPZEROCRITERIONCOUNT

global const XPRS_SLPZEROCRITERIONSTART = Int32(12379)
export XPRS_SLPZEROCRITERIONSTART

"""
    XPRS_SOLTIMELIMIT
The maximum time in seconds that the Optimizer will run a MIP solve before it terminates, given that a solution has been found. (double)

As long as no solution has been found, this control will have no effect.

Default value: `1e+20`

Values:
>0
: If an integer solution has been found, stop MIP search after the given number of seconds, otherwise continue until an integer solution is finally found.
"""
global const XPRS_SOLTIMELIMIT = Int32(7159)
export XPRS_SOLTIMELIMIT

"""
    XPRS_SOSREFTOL
The minimum relative gap between the ordering values of elements in a special ordered set. (double)

The gap divided by the absolute value of the larger of the two adjacent values must be at least `SOSREFTOL`.

Default value: `1.0E-06`

Domain: (0,+INF]
"""
global const XPRS_SOSREFTOL = Int32(7005)
export XPRS_SOSREFTOL

"""
    XPRS_SYMMETRY
Adjusts the overall amount of effort for symmetry detection. (integer)

Default value: `1`

Values:
0
: No symmetry detection.
1
: Conservative effort.
2
: Intensive symmetry search.
"""
global const XPRS_SYMMETRY = Int32(8118)
export XPRS_SYMMETRY

"""
    XPRS_SYMSELECT
Adjusts the overall amount of effort for symmetry detection. (integer)

Default value: `-1`

Values:
0
: Search the whole matrix (otherwise the `0`, `1` and `-1` coefficients only).
1
: Search all entities (otherwise binaries only).
"""
global const XPRS_SYMSELECT = Int32(8117)
export XPRS_SYMSELECT

"""
    XPRS_THREADS
The default number of threads used during optimization. (integer)

Default value: `-1`

Values:
-1
: Determined automatically based on hardware configuration.
>0
: Number of threads to use.
"""
global const XPRS_THREADS = Int32(8278)
export XPRS_THREADS

"""
    XPRS_TIMELIMIT
The maximum time in seconds that the Optimizer will run before it terminates, including the problem setup time and solution time. (double)

For MIP problems, this is the total time taken to solve all nodes.

Default value: `1e+20`

Values:
>0
: Stop LP or MIP search after the given number of seconds.
"""
global const XPRS_TIMELIMIT = Int32(7158)
export XPRS_TIMELIMIT

"""
    XPRS_TRACE
Display the infeasibility diagnosis during presolve. (integer)

If non-zero, an explanation of the logical deductions made by presolve to deduce infeasibility or unboundedness will be displayed on screen or sent to the message callback function.

Default value: `0`

Domain: -INF~+INF
"""
global const XPRS_TRACE = Int32(8130)
export XPRS_TRACE

"""
    XPRS_TREECOMPRESSION
When writing nodes to the gloal file, the optimizer can try to use data-compression techniques to reduce the size of the tree file on disk. (integer)

The `TREECOMPRESSION` control determines the strength of the data-compression algorithm used; higher values give superior data-compression at the affect of decreasing performance, while lower values compress quicker but not as effectively. Where `TREECOMPRESSION` is set to 0, no data compression will be used on the tree file.

Default value: `2`

Domain: 0,1,2,3,4,5,6,7,8,9
"""
global const XPRS_TREECOMPRESSION = Int32(8243)
export XPRS_TREECOMPRESSION

"""
    XPRS_TREECOVERCUTS
Branch and Bound: The number of rounds of lifted cover inequalities generated at nodes other than the top node in the tree. (integer)

Compare with the description for COVERCUTS. A value of -1 indicates the number of rounds is determined automatically.

Default value: `-1`

Domain: -1~+INF
"""
global const XPRS_TREECOVERCUTS = Int32(8140)
export XPRS_TREECOVERCUTS

"""
    XPRS_TREECUTSELECT
A bit vector providing detailed control of the cuts created during the tree search of a MIP solve. (integer)

Use CUTSELECT to control cuts on the root node.

Default value: `-1`

Values are a bitset:
bit 5
: Clique cuts.
bit 6
: Mixed Integer Rounding (MIR) cuts.
bit 7
: Lifted cover cuts.
bit 8
: Turn on row aggregation for MIR cuts.
bit 11
: Flow path cuts.
bit 12
: Implication cuts.
bit 13
: Turn on automatic Lift and Project cutting strategy.
bit 14
: Disable cutting from cut rows.
bit 15
: Lifted GUB cover cuts.
bit 16
: Zero-half cuts.
bit 17
: Indicator constraint cuts.
bit 18
: Strong Chvatal-Gomory cuts.
bit 20
: Farkas cuts.
"""
global const XPRS_TREECUTSELECT = Int32(8143)
export XPRS_TREECUTSELECT

"""
    XPRS_TREEDIAGNOSTICS
A bit vector providing control over how various tree-management-related messages get printed in the tree log file during the branch-and-bound search. (integer)

Default value: `7`

Values are a bitset:
bit 0
: Output regular summaries of current tree memory usage.
bit 1
: Output messages whenever tree data is being written to tree file.
bit 2
: Output progress messages while tree data is being written to the tree file, at an interval controlled by the TREEFILELOGINTERVAL control.
"""
global const XPRS_TREEDIAGNOSTICS = Int32(8244)
export XPRS_TREEDIAGNOSTICS

"""
    XPRS_TREEFILELOGINTERVAL
This control sets the interval between progress messages output while writing tree data to the tree file, in seconds. (integer)

The solve is slowed greatly while data is being written to the tree file and this output allows the user to see how much progress is being made.

Default value: `60`

Domain: 1~+INF
"""
global const XPRS_TREEFILELOGINTERVAL = Int32(8389)
export XPRS_TREEFILELOGINTERVAL

"""
    XPRS_TREEGOMCUTS
Branch and Bound: The number of rounds of Gomory cuts generated at nodes other than the first node in the tree. (integer)

Compare with the description for GOMCUTS. A value of -1 indicates the number of rounds is determined automatically.

Default value: `-1`

Domain: -1~+INF
"""
global const XPRS_TREEGOMCUTS = Int32(8141)
export XPRS_TREEGOMCUTS

"""
    XPRS_TREEMEMORYLIMIT
A soft limit, in megabytes, for the amount of memory to use in storing the branch and bound search tree. (integer)

This doesn't include memory used for presolve, heuristics, solving the LP relaxation, etc. When set to 0 (the default), the optimizer will calculate a limit automatically based on the amount of free physical memory detected in the machine. When the memory used by the branch and bound tree exceeds this limit, the optimizer will try to reduce the memory usage by writing lower-rated sections of the tree to a file called the "tree file". Though the solve can continue if it cannot bring the tree memory usage below the specified limit, performance will be inhibited and a message will be printed to the log.

Default value: 0 (calculate limit automatically)

Domain: 0~+INF
"""
global const XPRS_TREEMEMORYLIMIT = Int32(8242)
export XPRS_TREEMEMORYLIMIT

"""
    XPRS_TREEMEMORYSAVINGTARGET
When the memory used by the branch-and-bound search tree exceeds the limit specified by the TREEMEMORYLIMIT control, the optimizer will try to save memory by writing lower-rated sections of the tree to the tree file. (double)

The target amount of memory to save will be enough to bring memory usage back below the limit, plus enough extra to give the tree room to grow. The `TREEMEMORYSAVINGTARGET` control specifies the extra proportion of the tree's size to try to save; for example, if the tree memory limit is 1000Mb and `TREEMEMORYSAVINGTARGET` is 0.1, when the tree size exceeds 1000Mb the optimizer will try to reduce the tree size to 900Mb. Reducing the value of `TREEMEMORYSAVINGTARGET` will cause less extra nodes of the tree to be written to the tree file, but will result in the memory saving routine being triggered more often (as the tree will have less room in which to grow), which can reduce performance. Increasing the value of `TREEMEMORYSAVINGTARGET` will cause additional, more highly-rated nodes, of the tree to be written to the tree file, which can cause performance issues if these nodes are required later in the solve.

Default value: 0.4

Domain: [0.01,+1.0]
"""
global const XPRS_TREEMEMORYSAVINGTARGET = Int32(7100)
export XPRS_TREEMEMORYSAVINGTARGET

"""
    XPRS_TREEQCCUTS
Branch and Bound: Limit on the number of rounds of outer approximation cuts generated for nodes other than the root node, when solving a mixed integer quadratic constrained or mixed integer second order conic problem with outer approximation. (integer)

Default value: `-1` determined automatically.

Domain: -1~+INF
"""
global const XPRS_TREEQCCUTS = Int32(8331)
export XPRS_TREEQCCUTS

"""
    XPRS_TUNERHISTORY
Tuner: Whether to reuse and append to previous tuner results of the same problem. (integer)

Default value: `2`

Values:
0
: Discard any previous tuner results.
1
: Append new results to the previous tuner results, but do not reuse them.
2
: Reuse the previous results and append new results to it.
"""
global const XPRS_TUNERHISTORY = Int32(8365)
export XPRS_TUNERHISTORY

"""
    XPRS_TUNERMAXTIME
Tuner: The maximum time in seconds that the tuner will run before it terminates. (double)

Default value: `0`

Values:
0
: No time limit.
>0
: Stop the tuner after the given number of seconds.
"""
global const XPRS_TUNERMAXTIME = Int32(8364)
export XPRS_TUNERMAXTIME

"""
    XPRS_TUNERMETHOD
Tuner: Selects a factory tuner method. (integer)

A tuner method consists of a list of controls with different settings that the tuner will evaluate and try to combine.

Default value: `-1`

Values:
-1
: Automatically determined. The tuner will select the default method based on the problem type.
0
: Select the default LP tuner method.
1
: Select the default MIP tuner method.
2
: Select a more comprehensive MIP tuner method.
3
: Select a root-focus MIP tuner method.
4
: Select a tree-focus MIP tuner method.
5
: Select a simple MIP tuner method.
6
: Select the default SLP tuner method.
7
: Select the default MISLP tuner method.
8
: Select a MIP tuner method focussed on primal heuristics.
9
: Select the default Xpress Global tuner method.
"""
global const XPRS_TUNERMETHOD = Int32(8360)
export XPRS_TUNERMETHOD

"""
    XPRS_TUNERMETHODFILE
Tuner: Defines a file from which the tuner can read user-defined tuner method. (string)

Default value: (empty)

Domain: ?
"""
global const XPRS_TUNERMETHODFILE = Int32(6017)
export XPRS_TUNERMETHODFILE

"""
    XPRS_TUNERMODE
Tuner: Whether to always enable the tuner or disable it. (integer)

Default value: `-1`

Values:
-1
: No effect.
0
: Always disable the tuner. `XPRStune` (`TUNE`) will have no effect.
1
: Always enable the tuner. `XPRSmipoptimize` (`MIPOPTIMIZE`), `XPRSlpoptimize` (`LPOPTIMIZE`), etc. will call the tuner before solving the problem.
"""
global const XPRS_TUNERMODE = Int32(8359)
export XPRS_TUNERMODE

"""
    XPRS_TUNEROUTPUT
Tuner: Whether to output tuner results and logs to the file system. (integer)

Default value: `1`

Values:
0
: Don't output to the file system.
1
: Output results and logs to the file system.
"""
global const XPRS_TUNEROUTPUT = Int32(8372)
export XPRS_TUNEROUTPUT

"""
    XPRS_TUNEROUTPUTPATH
Tuner: Defines a root path to which the tuner writes the result file and logs. (string)

Default value: tuneroutput

Domain: ?
"""
global const XPRS_TUNEROUTPUTPATH = Int32(6018)
export XPRS_TUNEROUTPUTPATH

"""
    XPRS_TUNERPERMUTE
Tuner: Defines the number of permutations to solve for each control setting. (integer)

Default value: `0`

Values:
0
: Solve the original problem only for each setting.
n>0
: Solve the original problem and `n` permuted problems for each setting.
"""
global const XPRS_TUNERPERMUTE = Int32(8366)
export XPRS_TUNERPERMUTE

"""
    XPRS_TUNERSESSIONNAME
Tuner: Defines a session name for the tuner. (string)

Default value: (empty)

Domain: ?
"""
global const XPRS_TUNERSESSIONNAME = Int32(6019)
export XPRS_TUNERSESSIONNAME

"""
    XPRS_TUNERTARGET
Tuner: Defines the tuner target -- what should be evaluated when comparing two runs with different control settings. (integer)

Default value: `-1`

Values:
-1
: Automatically determined. The tuner will choose the default target based on problem type.
0
: Solution time then gap. (MIP/MISLP default)
1
: Solution time then best bound.
2
: Solution time then best integer solution.
3
: The primal dual integral.
4
: Time only. (LP/SLP default)
5
: SLP objective only. (SLP/MISLP choice)
6
: SLP validation number only. (SLP/MISLP choice)
7
: Gap only.
8
: Best bound only.
9
: Best integer solution only.
10
: Best primal integral. (Only for individual instances, not for problem sets)
"""
global const XPRS_TUNERTARGET = Int32(8362)
export XPRS_TUNERTARGET

"""
    XPRS_TUNERTHREADS
Tuner: the number of threads used by the tuner. (integer)

Default value: `1`

Values:
-1
: Choose automaticlly.
1
: The tuner will run in sequential.
n>1
: The tuner will run in parallel with `n` threads.
"""
global const XPRS_TUNERTHREADS = Int32(8363)
export XPRS_TUNERTHREADS

"""
    XPRS_TUNERVERBOSE
Tuner: whether the tuner should prints detailed information for each run. (integer)

Default value: `1`

Values:
1
: Print extra information.
0
: Print less information.
"""
global const XPRS_TUNERVERBOSE = Int32(8370)
export XPRS_TUNERVERBOSE

"""
    XPRS_USERSOLHEURISTIC
Determines how much effort to put into running a local search heuristic to find a feasible integer solution from a partial or infeasible user solution. (integer)

Default value: `-1`

Values:
-1
: Automatically determined.
0
: Search heuristic disabled.
1
: Light effort.
2
: Moderate effort.
3
: High effort.
"""
global const XPRS_USERSOLHEURISTIC = Int32(8258)
export XPRS_USERSOLHEURISTIC

"""
    XPRS_VARSELECTION
Branch and Bound: This determines the formula used to calculate the estimate of each integer variable, and thus which integer variable is selected to be branched on at a given node. (integer)

The variable selected to be branched on is the one with the maximum estimate.

Default value: `-1`

Values:
-1
: Determined automatically.
1
: The minimum of the 'up' and 'down' pseudo costs.
2
: The 'up' pseudo cost plus the 'down' pseudo cost.
3
: The maximum of the 'up' and 'down' pseudo costs, plus twice the minimum of the 'up' and 'down' pseudo costs.
4
: The maximum of the 'up' and 'down' pseudo costs.
5
: The 'down' pseudo cost.
6
: The 'up' pseudo cost.
7
: A weighted combination of the 'up' and 'down' pseudo costs, where the weights depend on how fractional the variable is.
8
: The product of the 'up' and 'down' pseudo costs.
"""
global const XPRS_VARSELECTION = Int32(8025)
export XPRS_VARSELECTION

"""
    XPRS_VERSION
The Optimizer version number, e.g. `1301` meaning release 13.01. (integer)

Default value: Software version dependent

Domain: 0~+INF
"""
global const XPRS_VERSION = Int32(8061)
export XPRS_VERSION

@enum XPRSSolStatus XPRS_SOLSTATUS_NOTFOUND=0 XPRS_SOLSTATUS_OPTIMAL=1 XPRS_SOLSTATUS_FEASIBLE=2 XPRS_SOLSTATUS_INFEASIBLE=3 XPRS_SOLSTATUS_UNBOUNDED=4
export XPRSSolStatus
export XPRS_SOLSTATUS_NOTFOUND
export XPRS_SOLSTATUS_OPTIMAL
export XPRS_SOLSTATUS_FEASIBLE
export XPRS_SOLSTATUS_INFEASIBLE
export XPRS_SOLSTATUS_UNBOUNDED
Base.:(==)(x::XPRSSolStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSSolStatus) = Int(x) == i
Base.:(!=)(x::XPRSSolStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSSolStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSSolStatus) where {T<:Int32} = T(a)
@enum XPRSSolveStatus XPRS_SOLVESTATUS_UNSTARTED=0 XPRS_SOLVESTATUS_STOPPED=1 XPRS_SOLVESTATUS_FAILED=2 XPRS_SOLVESTATUS_COMPLETED=3
export XPRSSolveStatus
export XPRS_SOLVESTATUS_UNSTARTED
export XPRS_SOLVESTATUS_STOPPED
export XPRS_SOLVESTATUS_FAILED
export XPRS_SOLVESTATUS_COMPLETED
Base.:(==)(x::XPRSSolveStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSSolveStatus) = Int(x) == i
Base.:(!=)(x::XPRSSolveStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSSolveStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSSolveStatus) where {T<:Int32} = T(a)
@enum XPRSLPStatus XPRS_LP_UNSTARTED=0 XPRS_LP_OPTIMAL=1 XPRS_LP_INFEAS=2 XPRS_LP_CUTOFF=3 XPRS_LP_UNFINISHED=4 XPRS_LP_UNBOUNDED=5 XPRS_LP_CUTOFF_IN_DUAL=6 XPRS_LP_UNSOLVED=7 XPRS_LP_NONCONVEX=8
export XPRSLPStatus
export XPRS_LP_UNSTARTED
export XPRS_LP_OPTIMAL
export XPRS_LP_INFEAS
export XPRS_LP_CUTOFF
export XPRS_LP_UNFINISHED
export XPRS_LP_UNBOUNDED
export XPRS_LP_CUTOFF_IN_DUAL
export XPRS_LP_UNSOLVED
export XPRS_LP_NONCONVEX
Base.:(==)(x::XPRSLPStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSLPStatus) = Int(x) == i
Base.:(!=)(x::XPRSLPStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSLPStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSLPStatus) where {T<:Int32} = T(a)
@enum XPRSMIPStatus XPRS_MIP_NOT_LOADED=0 XPRS_MIP_LP_NOT_OPTIMAL=1 XPRS_MIP_LP_OPTIMAL=2 XPRS_MIP_NO_SOL_FOUND=3 XPRS_MIP_SOLUTION=4 XPRS_MIP_INFEAS=5 XPRS_MIP_OPTIMAL=6 XPRS_MIP_UNBOUNDED=7
export XPRSMIPStatus
export XPRS_MIP_NOT_LOADED
export XPRS_MIP_LP_NOT_OPTIMAL
export XPRS_MIP_LP_OPTIMAL
export XPRS_MIP_NO_SOL_FOUND
export XPRS_MIP_SOLUTION
export XPRS_MIP_INFEAS
export XPRS_MIP_OPTIMAL
export XPRS_MIP_UNBOUNDED
Base.:(==)(x::XPRSMIPStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSMIPStatus) = Int(x) == i
Base.:(!=)(x::XPRSMIPStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSMIPStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSMIPStatus) where {T<:Int32} = T(a)
@enum XPRSIISSolStatus XPRS_IIS_UNSTARTED=0 XPRS_IIS_FEASIBLE=1 XPRS_IIS_COMPLETED=2 XPRS_IIS_UNFINISHED=3
export XPRSIISSolStatus
export XPRS_IIS_UNSTARTED
export XPRS_IIS_FEASIBLE
export XPRS_IIS_COMPLETED
export XPRS_IIS_UNFINISHED
Base.:(==)(x::XPRSIISSolStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSIISSolStatus) = Int(x) == i
Base.:(!=)(x::XPRSIISSolStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSIISSolStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSIISSolStatus) where {T<:Int32} = T(a)
@enum XPRSOptimizeType XPRS_OPTIMIZETYPE_NONE=-1 XPRS_OPTIMIZETYPE_LP=0 XPRS_OPTIMIZETYPE_MIP=1 XPRS_OPTIMIZETYPE_LOCAL=2 XPRS_OPTIMIZETYPE_GLOBAL=3
export XPRSOptimizeType
export XPRS_OPTIMIZETYPE_NONE
export XPRS_OPTIMIZETYPE_LP
export XPRS_OPTIMIZETYPE_MIP
export XPRS_OPTIMIZETYPE_LOCAL
export XPRS_OPTIMIZETYPE_GLOBAL
Base.:(==)(x::XPRSOptimizeType, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSOptimizeType) = Int(x) == i
Base.:(!=)(x::XPRSOptimizeType, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSOptimizeType) = Int(x) != i
Base.convert(::Type{T}, a::XPRSOptimizeType) where {T<:Int32} = T(a)
@enum XPRSBarOrder XPRS_BAR_DEFAULT=0 XPRS_BAR_MIN_DEGREE=1 XPRS_BAR_MIN_LOCAL_FILL=2 XPRS_BAR_NESTED_DISSECTION=3
export XPRSBarOrder
export XPRS_BAR_DEFAULT
export XPRS_BAR_MIN_DEGREE
export XPRS_BAR_MIN_LOCAL_FILL
export XPRS_BAR_NESTED_DISSECTION
Base.:(==)(x::XPRSBarOrder, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSBarOrder) = Int(x) == i
Base.:(!=)(x::XPRSBarOrder, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSBarOrder) = Int(x) != i
Base.convert(::Type{T}, a::XPRSBarOrder) where {T<:Int32} = T(a)
@enum XPRSDefaultAlg XPRS_ALG_DEFAULT=1 XPRS_ALG_DUAL=2 XPRS_ALG_PRIMAL=3 XPRS_ALG_BARRIER=4 XPRS_ALG_NETWORK=5
export XPRSDefaultAlg
export XPRS_ALG_DEFAULT
export XPRS_ALG_DUAL
export XPRS_ALG_PRIMAL
export XPRS_ALG_BARRIER
export XPRS_ALG_NETWORK
Base.:(==)(x::XPRSDefaultAlg, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSDefaultAlg) = Int(x) == i
Base.:(!=)(x::XPRSDefaultAlg, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSDefaultAlg) = Int(x) != i
Base.convert(::Type{T}, a::XPRSDefaultAlg) where {T<:Int32} = T(a)
@enum XPRSStopType XPRS_STOP_NONE=0 XPRS_STOP_TIMELIMIT=1 XPRS_STOP_CTRLC=2 XPRS_STOP_NODELIMIT=3 XPRS_STOP_ITERLIMIT=4 XPRS_STOP_MIPGAP=5 XPRS_STOP_SOLLIMIT=6 XPRS_STOP_GENERICERROR=7 XPRS_STOP_MEMORYERROR=8 XPRS_STOP_USER=9 XPRS_STOP_SOLVECOMPLETE=10 XPRS_STOP_LICENSELOST=11 XPRS_STOP_TICKLIMIT=12 XPRS_STOP_NUMERICALERROR=13
export XPRSStopType
export XPRS_STOP_NONE
export XPRS_STOP_TIMELIMIT
export XPRS_STOP_CTRLC
export XPRS_STOP_NODELIMIT
export XPRS_STOP_ITERLIMIT
export XPRS_STOP_MIPGAP
export XPRS_STOP_SOLLIMIT
export XPRS_STOP_GENERICERROR
export XPRS_STOP_MEMORYERROR
export XPRS_STOP_USER
export XPRS_STOP_SOLVECOMPLETE
export XPRS_STOP_LICENSELOST
export XPRS_STOP_NUMERICALERROR
Base.:(==)(x::XPRSStopType, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSStopType) = Int(x) == i
Base.:(!=)(x::XPRSStopType, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSStopType) = Int(x) != i
Base.convert(::Type{T}, a::XPRSStopType) where {T<:Int32} = T(a)
@enum XPRSAlwaysNeverAutomatic XPRS_ANA_AUTOMATIC=-1 XPRS_ANA_NEVER=0 XPRS_ANA_ALWAYS=1
export XPRSAlwaysNeverAutomatic
export XPRS_ANA_AUTOMATIC
export XPRS_ANA_NEVER
export XPRS_ANA_ALWAYS
Base.:(==)(x::XPRSAlwaysNeverAutomatic, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSAlwaysNeverAutomatic) = Int(x) == i
Base.:(!=)(x::XPRSAlwaysNeverAutomatic, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSAlwaysNeverAutomatic) = Int(x) != i
Base.convert(::Type{T}, a::XPRSAlwaysNeverAutomatic) where {T<:Int32} = T(a)
@enum XPRSOnOff XPRS_BOOL_OFF=0 XPRS_BOOL_ON=1
export XPRSOnOff
export XPRS_BOOL_OFF
export XPRS_BOOL_ON
Base.:(==)(x::XPRSOnOff, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSOnOff) = Int(x) == i
Base.:(!=)(x::XPRSOnOff, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSOnOff) = Int(x) != i
Base.convert(::Type{T}, a::XPRSOnOff) where {T<:Int32} = T(a)
@enum XPRSBacktrackAlg XPRS_BACKTRACKALG_BEST_ESTIMATE=2 XPRS_BACKTRACKALG_BEST_BOUND=3 XPRS_BACKTRACKALG_DEEPEST_NODE=4 XPRS_BACKTRACKALG_HIGHEST_NODE=5 XPRS_BACKTRACKALG_EARLIEST_NODE=6 XPRS_BACKTRACKALG_LATEST_NODE=7 XPRS_BACKTRACKALG_RANDOM=8 XPRS_BACKTRACKALG_MIN_INFEAS=9 XPRS_BACKTRACKALG_BEST_ESTIMATE_MIN_INFEAS=10 XPRS_BACKTRACKALG_DEEPEST_BEST_ESTIMATE=11
export XPRSBacktrackAlg
export XPRS_BACKTRACKALG_BEST_ESTIMATE
export XPRS_BACKTRACKALG_BEST_BOUND
export XPRS_BACKTRACKALG_DEEPEST_NODE
export XPRS_BACKTRACKALG_HIGHEST_NODE
export XPRS_BACKTRACKALG_EARLIEST_NODE
export XPRS_BACKTRACKALG_LATEST_NODE
export XPRS_BACKTRACKALG_RANDOM
export XPRS_BACKTRACKALG_MIN_INFEAS
export XPRS_BACKTRACKALG_BEST_ESTIMATE_MIN_INFEAS
export XPRS_BACKTRACKALG_DEEPEST_BEST_ESTIMATE
Base.:(==)(x::XPRSBacktrackAlg, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSBacktrackAlg) = Int(x) == i
Base.:(!=)(x::XPRSBacktrackAlg, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSBacktrackAlg) = Int(x) != i
Base.convert(::Type{T}, a::XPRSBacktrackAlg) where {T<:Int32} = T(a)
@enum XPRSBranchChoice XPRS_BRANCH_MIN_EST_FIRST=0 XPRS_BRANCH_MAX_EST_FIRST=1
export XPRSBranchChoice
export XPRS_BRANCH_MIN_EST_FIRST
export XPRS_BRANCH_MAX_EST_FIRST
Base.:(==)(x::XPRSBranchChoice, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSBranchChoice) = Int(x) == i
Base.:(!=)(x::XPRSBranchChoice, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSBranchChoice) = Int(x) != i
Base.convert(::Type{T}, a::XPRSBranchChoice) where {T<:Int32} = T(a)
@enum XPRSCholeskyAlgorithm XPRS_ALG_PULL_CHOLESKY=0 XPRS_ALG_PUSH_CHOLESKY=1
export XPRSCholeskyAlgorithm
export XPRS_ALG_PULL_CHOLESKY
export XPRS_ALG_PUSH_CHOLESKY
Base.:(==)(x::XPRSCholeskyAlgorithm, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSCholeskyAlgorithm) = Int(x) == i
Base.:(!=)(x::XPRSCholeskyAlgorithm, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSCholeskyAlgorithm) = Int(x) != i
Base.convert(::Type{T}, a::XPRSCholeskyAlgorithm) where {T<:Int32} = T(a)
@enum XPRSCrossoverDynamicReduction XPRS_XDRPBEFORE_CROSSOVER=1 XPRS_XDRPINSIDE_CROSSOVER=2 XPRS_XDRPAGGRESSIVE_BEFORE_CROSSOVER=4
export XPRSCrossoverDynamicReduction
export XPRS_XDRPBEFORE_CROSSOVER
export XPRS_XDRPINSIDE_CROSSOVER
export XPRS_XDRPAGGRESSIVE_BEFORE_CROSSOVER
Base.:(==)(x::XPRSCrossoverDynamicReduction, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSCrossoverDynamicReduction) = Int(x) == i
Base.:(!=)(x::XPRSCrossoverDynamicReduction, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSCrossoverDynamicReduction) = Int(x) != i
Base.convert(::Type{T}, a::XPRSCrossoverDynamicReduction) where {T<:Int32} = T(a)
@enum XPRSDualGradient XPRS_DUALGRADIENT_AUTOMATIC=-1 XPRS_DUALGRADIENT_DEVEX=0 XPRS_DUALGRADIENT_STEEPESTEDGE=1
export XPRSDualGradient
export XPRS_DUALGRADIENT_AUTOMATIC
export XPRS_DUALGRADIENT_DEVEX
export XPRS_DUALGRADIENT_STEEPESTEDGE
Base.:(==)(x::XPRSDualGradient, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSDualGradient) = Int(x) == i
Base.:(!=)(x::XPRSDualGradient, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSDualGradient) = Int(x) != i
Base.convert(::Type{T}, a::XPRSDualGradient) where {T<:Int32} = T(a)
@enum XPRSDualStrategy XPRS_DUALSTRATEGY_REMOVE_INFEAS_WITH_PRIMAL=0 XPRS_DUALSTRATEGY_REMOVE_INFEAS_WITH_DUAL=1
export XPRSDualStrategy
export XPRS_DUALSTRATEGY_REMOVE_INFEAS_WITH_PRIMAL
export XPRS_DUALSTRATEGY_REMOVE_INFEAS_WITH_DUAL
Base.:(==)(x::XPRSDualStrategy, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSDualStrategy) = Int(x) == i
Base.:(!=)(x::XPRSDualStrategy, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSDualStrategy) = Int(x) != i
Base.convert(::Type{T}, a::XPRSDualStrategy) where {T<:Int32} = T(a)
@enum XPRSFeasibilityPump XPRS_FEASIBILITYPUMP_AUTOMATIC=-1 XPRS_FEASIBILITYPUMP_NEVER=0 XPRS_FEASIBILITYPUMP_ALWAYS=1 XPRS_FEASIBILITYPUMP_LASTRESORT=2
export XPRSFeasibilityPump
export XPRS_FEASIBILITYPUMP_AUTOMATIC
export XPRS_FEASIBILITYPUMP_NEVER
export XPRS_FEASIBILITYPUMP_ALWAYS
export XPRS_FEASIBILITYPUMP_LASTRESORT
Base.:(==)(x::XPRSFeasibilityPump, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSFeasibilityPump) = Int(x) == i
Base.:(!=)(x::XPRSFeasibilityPump, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSFeasibilityPump) = Int(x) != i
Base.convert(::Type{T}, a::XPRSFeasibilityPump) where {T<:Int32} = T(a)
@enum XPRSHeuristicSearchSelect XPRS_HEURSEARCH_LOCAL_SEARCH_LARGE_NEIGHBOURHOOD=0 XPRS_HEURSEARCH_LOCAL_SEARCH_NODE_NEIGHBOURHOOD=1 XPRS_HEURSEARCH_LOCAL_SEARCH_SOLUTION_NEIGHBOURHOOD=2
export XPRSHeuristicSearchSelect
export XPRS_HEURSEARCH_LOCAL_SEARCH_LARGE_NEIGHBOURHOOD
export XPRS_HEURSEARCH_LOCAL_SEARCH_NODE_NEIGHBOURHOOD
export XPRS_HEURSEARCH_LOCAL_SEARCH_SOLUTION_NEIGHBOURHOOD
Base.:(==)(x::XPRSHeuristicSearchSelect, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSHeuristicSearchSelect) = Int(x) == i
Base.:(!=)(x::XPRSHeuristicSearchSelect, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSHeuristicSearchSelect) = Int(x) != i
Base.convert(::Type{T}, a::XPRSHeuristicSearchSelect) where {T<:Int32} = T(a)
@enum XPRSHeuristicStrategy XPRS_HEURSTRATEGY_AUTOMATIC=-1 XPRS_HEURSTRATEGY_NONE=0 XPRS_HEURSTRATEGY_BASIC=1 XPRS_HEURSTRATEGY_ENHANCED=2 XPRS_HEURSTRATEGY_EXTENSIVE=3
export XPRSHeuristicStrategy
export XPRS_HEURSTRATEGY_AUTOMATIC
export XPRS_HEURSTRATEGY_NONE
export XPRS_HEURSTRATEGY_BASIC
export XPRS_HEURSTRATEGY_ENHANCED
export XPRS_HEURSTRATEGY_EXTENSIVE
Base.:(==)(x::XPRSHeuristicStrategy, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSHeuristicStrategy) = Int(x) == i
Base.:(!=)(x::XPRSHeuristicStrategy, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSHeuristicStrategy) = Int(x) != i
Base.convert(::Type{T}, a::XPRSHeuristicStrategy) where {T<:Int32} = T(a)
@enum XPRSNodeSelectionCriteria XPRS_NODESELECTION_LOCAL_FIRST=1 XPRS_NODESELECTION_BEST_FIRST=2 XPRS_NODESELECTION_LOCAL_DEPTH_FIRST=3 XPRS_NODESELECTION_BEST_FIRST_THEN_LOCAL_FIRST=4 XPRS_NODESELECTION_DEPTH_FIRST=5
export XPRSNodeSelectionCriteria
export XPRS_NODESELECTION_LOCAL_FIRST
export XPRS_NODESELECTION_BEST_FIRST
export XPRS_NODESELECTION_LOCAL_DEPTH_FIRST
export XPRS_NODESELECTION_BEST_FIRST_THEN_LOCAL_FIRST
export XPRS_NODESELECTION_DEPTH_FIRST
Base.:(==)(x::XPRSNodeSelectionCriteria, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSNodeSelectionCriteria) = Int(x) == i
Base.:(!=)(x::XPRSNodeSelectionCriteria, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSNodeSelectionCriteria) = Int(x) != i
Base.convert(::Type{T}, a::XPRSNodeSelectionCriteria) where {T<:Int32} = T(a)
@enum XPRSOutputDetail XPRS_OUTPUTLOG_NO_OUTPUT=0 XPRS_OUTPUTLOG_FULL_OUTPUT=1 XPRS_OUTPUTLOG_ERRORS_AND_WARNINGS=3 XPRS_OUTPUTLOG_ERRORS=4
export XPRSOutputDetail
export XPRS_OUTPUTLOG_NO_OUTPUT
export XPRS_OUTPUTLOG_FULL_OUTPUT
export XPRS_OUTPUTLOG_ERRORS_AND_WARNINGS
export XPRS_OUTPUTLOG_ERRORS
Base.:(==)(x::XPRSOutputDetail, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSOutputDetail) = Int(x) == i
Base.:(!=)(x::XPRSOutputDetail, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSOutputDetail) = Int(x) != i
Base.convert(::Type{T}, a::XPRSOutputDetail) where {T<:Int32} = T(a)
@enum XPRSPreProbing XPRS_PREPROBING_AUTOMATIC=-1 XPRS_PREPROBING_DISABLED=0 XPRS_PREPROBING_LIGHT=1 XPRS_PREPROBING_FULL=2 XPRS_PREPROBING_FULL_AND_REPEAT=3
export XPRSPreProbing
export XPRS_PREPROBING_AUTOMATIC
export XPRS_PREPROBING_DISABLED
export XPRS_PREPROBING_LIGHT
export XPRS_PREPROBING_FULL
export XPRS_PREPROBING_FULL_AND_REPEAT
Base.:(==)(x::XPRSPreProbing, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPreProbing) = Int(x) == i
Base.:(!=)(x::XPRSPreProbing, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPreProbing) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPreProbing) where {T<:Int32} = T(a)
@enum XPRSPresolveOperations XPRS_PRESOLVEOPS_SINGLETONCOLUMNREMOVAL=1 XPRS_PRESOLVEOPS_SINGLETONROWREMOVAL=2 XPRS_PRESOLVEOPS_FORCINGROWREMOVAL=4 XPRS_PRESOLVEOPS_DUALREDUCTIONS=8 XPRS_PRESOLVEOPS_REDUNDANTROWREMOVAL=16 XPRS_PRESOLVEOPS_DUPLICATECOLUMNREMOVAL=32 XPRS_PRESOLVEOPS_DUPLICATEROWREMOVAL=64 XPRS_PRESOLVEOPS_STRONGDUALREDUCTIONS=128 XPRS_PRESOLVEOPS_VARIABLEELIMINATIONS=256 XPRS_PRESOLVEOPS_NOIPREDUCTIONS=512 XPRS_PRESOLVEOPS_NOGLOBALDOMAINCHANGE=1024 XPRS_PRESOLVEOPS_NOADVANCEDIPREDUCTIONS=2048 XPRS_PRESOLVEOPS_NOINTEGERELIMINATIONS=4096 XPRS_PRESOLVEOPS_NOSOLUTIONENUMERATION=8192 XPRS_PRESOLVEOPS_LINEARLYDEPENDANTROWREMOVAL=16384 XPRS_PRESOLVEOPS_NOINTEGERVARIABLEANDSOSDETECTION=32768 XPRS_PRESOLVEOPS_NOIMPLIEDBOUNDS=65536 XPRS_PRESOLVEOPS_NOCLIQUEPRESOLVE=131072 XPRS_PRESOLVEOPS_NOMOD2REDUCTIONS=262144 XPRS_PRESOLVEOPS_NODUALREDONGLOBALS=536870912
export XPRSPresolveOperations
export XPRS_PRESOLVEOPS_SINGLETONCOLUMNREMOVAL
export XPRS_PRESOLVEOPS_SINGLETONROWREMOVAL
export XPRS_PRESOLVEOPS_FORCINGROWREMOVAL
export XPRS_PRESOLVEOPS_DUALREDUCTIONS
export XPRS_PRESOLVEOPS_REDUNDANTROWREMOVAL
export XPRS_PRESOLVEOPS_DUPLICATECOLUMNREMOVAL
export XPRS_PRESOLVEOPS_DUPLICATEROWREMOVAL
export XPRS_PRESOLVEOPS_STRONGDUALREDUCTIONS
export XPRS_PRESOLVEOPS_VARIABLEELIMINATIONS
export XPRS_PRESOLVEOPS_NOIPREDUCTIONS
export XPRS_PRESOLVEOPS_NOGLOBALDOMAINCHANGE
export XPRS_PRESOLVEOPS_NOADVANCEDIPREDUCTIONS
export XPRS_PRESOLVEOPS_NOINTEGERELIMINATIONS
export XPRS_PRESOLVEOPS_NOSOLUTIONENUMERATION
export XPRS_PRESOLVEOPS_LINEARLYDEPENDANTROWREMOVAL
export XPRS_PRESOLVEOPS_NOINTEGERVARIABLEANDSOSDETECTION
export XPRS_PRESOLVEOPS_NOIMPLIEDBOUNDS
export XPRS_PRESOLVEOPS_NOCLIQUEPRESOLVE
export XPRS_PRESOLVEOPS_NOMOD2REDUCTIONS
export XPRS_PRESOLVEOPS_NODUALREDONGLOBALS
Base.:(==)(x::XPRSPresolveOperations, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolveOperations) = Int(x) == i
Base.:(!=)(x::XPRSPresolveOperations, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolveOperations) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolveOperations) where {T<:Int32} = T(a)
@enum XPRSPresolveState XPRS_PRESOLVESTATE_PROBLEMLOADED=1 XPRS_PRESOLVESTATE_PROBLEMLPPRESOLVED=2 XPRS_PRESOLVESTATE_PROBLEMMIPPRESOLVED=4 XPRS_PRESOLVESTATE_SOLUTIONVALID=128
export XPRSPresolveState
export XPRS_PRESOLVESTATE_PROBLEMLOADED
export XPRS_PRESOLVESTATE_PROBLEMLPPRESOLVED
export XPRS_PRESOLVESTATE_PROBLEMMIPPRESOLVED
export XPRS_PRESOLVESTATE_SOLUTIONVALID
Base.:(==)(x::XPRSPresolveState, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolveState) = Int(x) == i
Base.:(!=)(x::XPRSPresolveState, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolveState) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolveState) where {T<:Int32} = T(a)
@enum XPRSMipPresolve XPRS_MIPPRESOLVE_REDUCED_COST_FIXING=1 XPRS_MIPPRESOLVE_LOGIC_PREPROCESSING=2 XPRS_MIPPRESOLVE_ALLOW_CHANGE_BOUNDS=8 XPRS_MIPPRESOLVE_DUAL_REDUCTIONS=16 XPRS_MIPPRESOLVE_GLOBAL_COEFFICIENT_TIGHTENING=32 XPRS_MIPPRESOLVE_OBJECTIVE_BASED_REDUCTIONS=64 XPRS_MIPPRESOLVE_ALLOW_TREE_RESTART=128 XPRS_MIPPRESOLVE_SYMMETRY_REDUCTIONS=256
export XPRSMipPresolve
export XPRS_MIPPRESOLVE_REDUCED_COST_FIXING
export XPRS_MIPPRESOLVE_LOGIC_PREPROCESSING
export XPRS_MIPPRESOLVE_ALLOW_CHANGE_BOUNDS
export XPRS_MIPPRESOLVE_DUAL_REDUCTIONS
export XPRS_MIPPRESOLVE_GLOBAL_COEFFICIENT_TIGHTENING
export XPRS_MIPPRESOLVE_OBJECTIVE_BASED_REDUCTIONS
export XPRS_MIPPRESOLVE_ALLOW_TREE_RESTART
export XPRS_MIPPRESOLVE_SYMMETRY_REDUCTIONS
Base.:(==)(x::XPRSMipPresolve, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSMipPresolve) = Int(x) == i
Base.:(!=)(x::XPRSMipPresolve, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSMipPresolve) = Int(x) != i
Base.convert(::Type{T}, a::XPRSMipPresolve) where {T<:Int32} = T(a)
@enum XPRSPresolve XPRS_PRESOLVE_NOPRIMALINFEASIBILITY=-1 XPRS_PRESOLVE_NONE=0 XPRS_PRESOLVE_DEFAULT=1 XPRS_PRESOLVE_KEEPREDUNDANTBOUNDS=2
export XPRSPresolve
export XPRS_PRESOLVE_NOPRIMALINFEASIBILITY
export XPRS_PRESOLVE_NONE
export XPRS_PRESOLVE_DEFAULT
export XPRS_PRESOLVE_KEEPREDUNDANTBOUNDS
Base.:(==)(x::XPRSPresolve, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolve) = Int(x) == i
Base.:(!=)(x::XPRSPresolve, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolve) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolve) where {T<:Int32} = T(a)
@enum XPRSPricing XPRS_PRICING_PARTIAL=-1 XPRS_PRICING_DEFAULT=0 XPRS_PRICING_DEVEX=1
export XPRSPricing
export XPRS_PRICING_PARTIAL
export XPRS_PRICING_DEFAULT
export XPRS_PRICING_DEVEX
Base.:(==)(x::XPRSPricing, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPricing) = Int(x) == i
Base.:(!=)(x::XPRSPricing, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPricing) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPricing) where {T<:Int32} = T(a)
@enum XPRSCutStrategy XPRS_CUTSTRATEGY_DEFAULT=-1 XPRS_CUTSTRATEGY_NONE=0 XPRS_CUTSTRATEGY_CONSERVATIVE=1 XPRS_CUTSTRATEGY_MODERATE=2 XPRS_CUTSTRATEGY_AGGRESSIVE=3
export XPRSCutStrategy
export XPRS_CUTSTRATEGY_DEFAULT
export XPRS_CUTSTRATEGY_NONE
export XPRS_CUTSTRATEGY_CONSERVATIVE
export XPRS_CUTSTRATEGY_MODERATE
export XPRS_CUTSTRATEGY_AGGRESSIVE
Base.:(==)(x::XPRSCutStrategy, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSCutStrategy) = Int(x) == i
Base.:(!=)(x::XPRSCutStrategy, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSCutStrategy) = Int(x) != i
Base.convert(::Type{T}, a::XPRSCutStrategy) where {T<:Int32} = T(a)
@enum XPRSVariableSelection XPRS_VARSELECTION_AUTOMATIC=-1 XPRS_VARSELECTION_MIN_UPDOWN_PSEUDO_COSTS=1 XPRS_VARSELECTION_SUM_UPDOWN_PSEUDO_COSTS=2 XPRS_VARSELECTION_MAX_UPDOWN_PSEUDO_COSTS_PLUS_TWICE_MIN=3 XPRS_VARSELECTION_MAX_UPDOWN_PSEUDO_COSTS=4 XPRS_VARSELECTION_DOWN_PSEUDO_COST=5 XPRS_VARSELECTION_UP_PSEUDO_COST=6
export XPRSVariableSelection
export XPRS_VARSELECTION_AUTOMATIC
export XPRS_VARSELECTION_MIN_UPDOWN_PSEUDO_COSTS
export XPRS_VARSELECTION_SUM_UPDOWN_PSEUDO_COSTS
export XPRS_VARSELECTION_MAX_UPDOWN_PSEUDO_COSTS_PLUS_TWICE_MIN
export XPRS_VARSELECTION_MAX_UPDOWN_PSEUDO_COSTS
export XPRS_VARSELECTION_DOWN_PSEUDO_COST
export XPRS_VARSELECTION_UP_PSEUDO_COST
Base.:(==)(x::XPRSVariableSelection, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSVariableSelection) = Int(x) == i
Base.:(!=)(x::XPRSVariableSelection, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSVariableSelection) = Int(x) != i
Base.convert(::Type{T}, a::XPRSVariableSelection) where {T<:Int32} = T(a)
@enum XPRSScaling XPRS_SCALING_ROW_SCALING=1 XPRS_SCALING_COLUMN_SCALING=2 XPRS_SCALING_ROW_SCALING_AGAIN=4 XPRS_SCALING_MAXIMUM=8 XPRS_SCALING_CURTIS_REID=16 XPRS_SCALING_BY_MAX_ELEM_NOT_GEO_MEAN=32 XPRS_SCALING_BIGM=64 XPRS_SCALING_SIMPLEX_OBJECTIVE_SCALING=128 XPRS_SCALING_IGNORE_QUADRATIC_ROW_PART=256 XPRS_SCALING_BEFORE_PRESOLVE=512 XPRS_SCALING_NO_SCALING_ROWS_UP=1024 XPRS_SCALING_NO_SCALING_COLUMNS_DOWN=2048 XPRS_SCALING_DISABLE_GLOBAL_OBJECTIVE_SCALING=4096 XPRS_SCALING_RHS_SCALING=8192 XPRS_SCALING_NO_AGGRESSIVE_Q_SCALING=16384 XPRS_SCALING_SLACK_SCALING=32768 XPRS_SCALING_RUIZ=65536 XPRS_SCALING_DOGLEG=131072 XPRS_SCALING_BEFORE_AND_AFTER_PRESOLVE=262144
export XPRSScaling
export XPRS_SCALING_ROW_SCALING
export XPRS_SCALING_COLUMN_SCALING
export XPRS_SCALING_ROW_SCALING_AGAIN
export XPRS_SCALING_MAXIMUM
export XPRS_SCALING_CURTIS_REID
export XPRS_SCALING_BY_MAX_ELEM_NOT_GEO_MEAN
export XPRS_SCALING_BIGM
export XPRS_SCALING_SIMPLEX_OBJECTIVE_SCALING
export XPRS_SCALING_IGNORE_QUADRATIC_ROW_PART
export XPRS_SCALING_BEFORE_PRESOLVE
export XPRS_SCALING_NO_SCALING_ROWS_UP
export XPRS_SCALING_NO_SCALING_COLUMNS_DOWN
export XPRS_SCALING_DISABLE_GLOBAL_OBJECTIVE_SCALING
export XPRS_SCALING_RHS_SCALING
export XPRS_SCALING_NO_AGGRESSIVE_Q_SCALING
export XPRS_SCALING_SLACK_SCALING
export XPRS_SCALING_RUIZ
export XPRS_SCALING_DOGLEG
export XPRS_SCALING_BEFORE_AND_AFTER_PRESOLVE
Base.:(==)(x::XPRSScaling, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSScaling) = Int(x) == i
Base.:(!=)(x::XPRSScaling, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSScaling) = Int(x) != i
Base.convert(::Type{T}, a::XPRSScaling) where {T<:Int32} = T(a)
@enum XPRSCutSelect XPRS_CUTSELECT_CLIQUE=1855 XPRS_CUTSELECT_MIR=1887 XPRS_CUTSELECT_COVER=1951 XPRS_CUTSELECT_FLOWPATH=3871 XPRS_CUTSELECT_IMPLICATION=5919 XPRS_CUTSELECT_LIFT_AND_PROJECT=10015 XPRS_CUTSELECT_DISABLE_CUT_ROWS=18207 XPRS_CUTSELECT_GUB_COVER=34591 XPRS_CUTSELECT_DEFAULT=-1
export XPRSCutSelect
export XPRS_CUTSELECT_CLIQUE
export XPRS_CUTSELECT_MIR
export XPRS_CUTSELECT_COVER
export XPRS_CUTSELECT_FLOWPATH
export XPRS_CUTSELECT_IMPLICATION
export XPRS_CUTSELECT_LIFT_AND_PROJECT
export XPRS_CUTSELECT_DISABLE_CUT_ROWS
export XPRS_CUTSELECT_GUB_COVER
export XPRS_CUTSELECT_DEFAULT
Base.:(==)(x::XPRSCutSelect, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSCutSelect) = Int(x) == i
Base.:(!=)(x::XPRSCutSelect, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSCutSelect) = Int(x) != i
Base.convert(::Type{T}, a::XPRSCutSelect) where {T<:Int32} = T(a)
@enum XPRSRefineOps XPRS_REFINEOPS_LPOPTIMAL=1 XPRS_REFINEOPS_MIPSOLUTION=2 XPRS_REFINEOPS_MIPOPTIMAL=4 XPRS_REFINEOPS_MIPNODELP=8 XPRS_REFINEOPS_LPPRESOLVE=16 XPRS_REFINEOPS_ITERATIVEREFINER=32 XPRS_REFINEOPS_REFINERPRECISION=64 XPRS_REFINEOPS_REFINERUSEPRIMAL=128 XPRS_REFINEOPS_REFINERUSEDUAL=256 XPRS_REFINEOPS_MIPFIXGLOBALS=512 XPRS_REFINEOPS_MIPFIXGLOBALSTARGET=1024
export XPRSRefineOps
export XPRS_REFINEOPS_LPOPTIMAL
export XPRS_REFINEOPS_MIPSOLUTION
export XPRS_REFINEOPS_MIPOPTIMAL
export XPRS_REFINEOPS_MIPNODELP
export XPRS_REFINEOPS_LPPRESOLVE
export XPRS_REFINEOPS_ITERATIVEREFINER
export XPRS_REFINEOPS_REFINERPRECISION
export XPRS_REFINEOPS_REFINERUSEPRIMAL
export XPRS_REFINEOPS_REFINERUSEDUAL
export XPRS_REFINEOPS_MIPFIXGLOBALS
export XPRS_REFINEOPS_MIPFIXGLOBALSTARGET
Base.:(==)(x::XPRSRefineOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSRefineOps) = Int(x) == i
Base.:(!=)(x::XPRSRefineOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSRefineOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSRefineOps) where {T<:Int32} = T(a)
@enum XPRSDualizeOps XPRS_DUALIZEOPS_SWITCHALGORITHM=1
export XPRSDualizeOps
export XPRS_DUALIZEOPS_SWITCHALGORITHM
Base.:(==)(x::XPRSDualizeOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSDualizeOps) = Int(x) == i
Base.:(!=)(x::XPRSDualizeOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSDualizeOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSDualizeOps) where {T<:Int32} = T(a)
@enum XPRSTreeDiagnostics XPRS_TREEDIAGNOSTICS_MEMORY_USAGE_SUMMARIES=1 XPRS_TREEDIAGNOSTICS_MEMORY_SAVED_REPORTS=2
export XPRSTreeDiagnostics
export XPRS_TREEDIAGNOSTICS_MEMORY_USAGE_SUMMARIES
export XPRS_TREEDIAGNOSTICS_MEMORY_SAVED_REPORTS
Base.:(==)(x::XPRSTreeDiagnostics, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTreeDiagnostics) = Int(x) == i
Base.:(!=)(x::XPRSTreeDiagnostics, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTreeDiagnostics) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTreeDiagnostics) where {T<:Int32} = T(a)
@enum XPRSBarPresolveOps XPRS_BARPRESOLVEOPS_STANDARD_PRESOLVE=0 XPRS_BARPRESOLVEOPS_EXTRA_BARRIER_PRESOLVE=1
export XPRSBarPresolveOps
export XPRS_BARPRESOLVEOPS_STANDARD_PRESOLVE
export XPRS_BARPRESOLVEOPS_EXTRA_BARRIER_PRESOLVE
Base.:(==)(x::XPRSBarPresolveOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSBarPresolveOps) = Int(x) == i
Base.:(!=)(x::XPRSBarPresolveOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSBarPresolveOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSBarPresolveOps) where {T<:Int32} = T(a)
@enum XPRSMipRestart XPRS_MIPRESTART_DEFAULT=-1 XPRS_MIPRESTART_OFF=0 XPRS_MIPRESTART_MODERATE=1 XPRS_MIPRESTART_AGGRESSIVE=2
export XPRSMipRestart
export XPRS_MIPRESTART_DEFAULT
export XPRS_MIPRESTART_OFF
export XPRS_MIPRESTART_MODERATE
export XPRS_MIPRESTART_AGGRESSIVE
Base.:(==)(x::XPRSMipRestart, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSMipRestart) = Int(x) == i
Base.:(!=)(x::XPRSMipRestart, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSMipRestart) = Int(x) != i
Base.convert(::Type{T}, a::XPRSMipRestart) where {T<:Int32} = T(a)
@enum XPRSPresolveCoefElim XPRS_PRECOEFELIM_DISABLED=0 XPRS_PRECOEFELIM_AGGRESSIVE=1 XPRS_PRECOEFELIM_CAUTIOUS=2
export XPRSPresolveCoefElim
export XPRS_PRECOEFELIM_DISABLED
export XPRS_PRECOEFELIM_AGGRESSIVE
export XPRS_PRECOEFELIM_CAUTIOUS
Base.:(==)(x::XPRSPresolveCoefElim, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolveCoefElim) = Int(x) == i
Base.:(!=)(x::XPRSPresolveCoefElim, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolveCoefElim) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolveCoefElim) where {T<:Int32} = T(a)
@enum XPRSPresolveDomRow XPRS_PREDOMROW_AUTOMATIC=-1 XPRS_PREDOMROW_DISABLED=0 XPRS_PREDOMROW_CAUTIOUS=1 XPRS_PREDOMROW_MEDIUM=2 XPRS_PREDOMROW_AGGRESSIVE=3
export XPRSPresolveDomRow
export XPRS_PREDOMROW_AUTOMATIC
export XPRS_PREDOMROW_DISABLED
export XPRS_PREDOMROW_CAUTIOUS
export XPRS_PREDOMROW_MEDIUM
export XPRS_PREDOMROW_AGGRESSIVE
Base.:(==)(x::XPRSPresolveDomRow, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolveDomRow) = Int(x) == i
Base.:(!=)(x::XPRSPresolveDomRow, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolveDomRow) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolveDomRow) where {T<:Int32} = T(a)
@enum XPRSPresolveDomColumn XPRS_PREDOMCOL_AUTOMATIC=-1 XPRS_PREDOMCOL_DISABLED=0 XPRS_PREDOMCOL_CAUTIOUS=1 XPRS_PREDOMCOL_AGGRESSIVE=2
export XPRSPresolveDomColumn
export XPRS_PREDOMCOL_AUTOMATIC
export XPRS_PREDOMCOL_DISABLED
export XPRS_PREDOMCOL_CAUTIOUS
export XPRS_PREDOMCOL_AGGRESSIVE
Base.:(==)(x::XPRSPresolveDomColumn, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPresolveDomColumn) = Int(x) == i
Base.:(!=)(x::XPRSPresolveDomColumn, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPresolveDomColumn) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPresolveDomColumn) where {T<:Int32} = T(a)
@enum XPRSPrimalUnshift XPRS_PRIMALUNSHIFT_ALLOW_DUAL_UNSHIFT=0 XPRS_PRIMALUNSHIFT_NO_DUAL_UNSHIFT=1
export XPRSPrimalUnshift
export XPRS_PRIMALUNSHIFT_ALLOW_DUAL_UNSHIFT
export XPRS_PRIMALUNSHIFT_NO_DUAL_UNSHIFT
Base.:(==)(x::XPRSPrimalUnshift, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSPrimalUnshift) = Int(x) == i
Base.:(!=)(x::XPRSPrimalUnshift, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSPrimalUnshift) = Int(x) != i
Base.convert(::Type{T}, a::XPRSPrimalUnshift) where {T<:Int32} = T(a)
@enum XPRSRepairIndefiniteQuadratic XPRS_REPAIRINDEFINITEQ_REPAIR_IF_POSSIBLE=0 XPRS_REPAIRINDEFINITEQ_NO_REPAIR=1
export XPRSRepairIndefiniteQuadratic
export XPRS_REPAIRINDEFINITEQ_REPAIR_IF_POSSIBLE
export XPRS_REPAIRINDEFINITEQ_NO_REPAIR
Base.:(==)(x::XPRSRepairIndefiniteQuadratic, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSRepairIndefiniteQuadratic) = Int(x) == i
Base.:(!=)(x::XPRSRepairIndefiniteQuadratic, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSRepairIndefiniteQuadratic) = Int(x) != i
Base.convert(::Type{T}, a::XPRSRepairIndefiniteQuadratic) where {T<:Int32} = T(a)
@enum XPRSObjSense XPRS_OBJ_MINIMIZE=1 XPRS_OBJ_MAXIMIZE=-1
export XPRSObjSense
export XPRS_OBJ_MINIMIZE
export XPRS_OBJ_MAXIMIZE
Base.:(==)(x::XPRSObjSense, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSObjSense) = Int(x) == i
Base.:(!=)(x::XPRSObjSense, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSObjSense) = Int(x) != i
Base.convert(::Type{T}, a::XPRSObjSense) where {T<:Int32} = T(a)
@enum XPRSParameterType XPRS_TYPE_NOTDEFINED=0 XPRS_TYPE_INT=1 XPRS_TYPE_INT64=2 XPRS_TYPE_DOUBLE=3 XPRS_TYPE_STRING=4
export XPRSParameterType
export XPRS_TYPE_NOTDEFINED
export XPRS_TYPE_INT
export XPRS_TYPE_INT64
export XPRS_TYPE_DOUBLE
export XPRS_TYPE_STRING
Base.:(==)(x::XPRSParameterType, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSParameterType) = Int(x) == i
Base.:(!=)(x::XPRSParameterType, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSParameterType) = Int(x) != i
Base.convert(::Type{T}, a::XPRSParameterType) where {T<:Int32} = T(a)
@enum XPRSQConvexity XPRS_QCONVEXITY_UNKNOWN=-1 XPRS_QCONVEXITY_NONCONVEX=0 XPRS_QCONVEXITY_CONVEX=1 XPRS_QCONVEXITY_REPAIRABLE=2 XPRS_QCONVEXITY_CONVEXCONE=3 XPRS_QCONVEXITY_CONECONVERTABLE=4
export XPRSQConvexity
export XPRS_QCONVEXITY_UNKNOWN
export XPRS_QCONVEXITY_NONCONVEX
export XPRS_QCONVEXITY_CONVEX
export XPRS_QCONVEXITY_REPAIRABLE
export XPRS_QCONVEXITY_CONVEXCONE
export XPRS_QCONVEXITY_CONECONVERTABLE
Base.:(==)(x::XPRSQConvexity, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSQConvexity) = Int(x) == i
Base.:(!=)(x::XPRSQConvexity, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSQConvexity) = Int(x) != i
Base.convert(::Type{T}, a::XPRSQConvexity) where {T<:Int32} = T(a)
@enum XPRSSolInfo XPRS_SOLINFO_ABSPRIMALINFEAS=0 XPRS_SOLINFO_RELPRIMALINFEAS=1 XPRS_SOLINFO_ABSDUALINFEAS=2 XPRS_SOLINFO_RELDUALINFEAS=3 XPRS_SOLINFO_MAXMIPFRACTIONAL=4 XPRS_SOLINFO_ABSMIPINFEAS=5 XPRS_SOLINFO_RELMIPINFEAS=6
export XPRSSolInfo
export XPRS_SOLINFO_ABSPRIMALINFEAS
export XPRS_SOLINFO_RELPRIMALINFEAS
export XPRS_SOLINFO_ABSDUALINFEAS
export XPRS_SOLINFO_RELDUALINFEAS
export XPRS_SOLINFO_MAXMIPFRACTIONAL
export XPRS_SOLINFO_ABSMIPINFEAS
export XPRS_SOLINFO_RELMIPINFEAS
Base.:(==)(x::XPRSSolInfo, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSSolInfo) = Int(x) == i
Base.:(!=)(x::XPRSSolInfo, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSSolInfo) = Int(x) != i
Base.convert(::Type{T}, a::XPRSSolInfo) where {T<:Int32} = T(a)
@enum XPRSTunerMode XPRS_TUNERMODE_AUTOMATIC=-1 XPRS_TUNERMODE_OFF=0 XPRS_TUNERMODE_ON=1
export XPRSTunerMode
export XPRS_TUNERMODE_AUTOMATIC
export XPRS_TUNERMODE_OFF
export XPRS_TUNERMODE_ON
Base.:(==)(x::XPRSTunerMode, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTunerMode) = Int(x) == i
Base.:(!=)(x::XPRSTunerMode, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTunerMode) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTunerMode) where {T<:Int32} = T(a)
@enum XPRSTunerMethod XPRS_TUNERMETHOD_AUTOMATIC=-1 XPRS_TUNERMETHOD_LPQUICK=0 XPRS_TUNERMETHOD_MIPQUICK=1 XPRS_TUNERMETHOD_MIPCOMPREHENSIVE=2 XPRS_TUNERMETHOD_MIPROOTFOCUS=3 XPRS_TUNERMETHOD_MIPTREEFOCUS=4 XPRS_TUNERMETHOD_MIPSIMPLE=5 XPRS_TUNERMETHOD_SLPQUICK=6 XPRS_TUNERMETHOD_MISLPQUICK=7 XPRS_TUNERMETHOD_MIPHEURISTICS=8 XPRS_TUNERMETHOD_GLOBALQUICK=9 XPRS_TUNERMETHOD_LPNUMERICS=10
export XPRSTunerMethod
export XPRS_TUNERMETHOD_AUTOMATIC
export XPRS_TUNERMETHOD_LPQUICK
export XPRS_TUNERMETHOD_MIPQUICK
export XPRS_TUNERMETHOD_MIPCOMPREHENSIVE
export XPRS_TUNERMETHOD_MIPROOTFOCUS
export XPRS_TUNERMETHOD_MIPTREEFOCUS
export XPRS_TUNERMETHOD_MIPSIMPLE
export XPRS_TUNERMETHOD_SLPQUICK
export XPRS_TUNERMETHOD_MISLPQUICK
export XPRS_TUNERMETHOD_MIPHEURISTICS
export XPRS_TUNERMETHOD_GLOBALQUICK
export XPRS_TUNERMETHOD_LPNUMERICS
Base.:(==)(x::XPRSTunerMethod, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTunerMethod) = Int(x) == i
Base.:(!=)(x::XPRSTunerMethod, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTunerMethod) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTunerMethod) where {T<:Int32} = T(a)
@enum XPRSTunerTarget XPRS_TUNERTARGET_AUTOMATIC=-1 XPRS_TUNERTARGET_TIMEGAP=0 XPRS_TUNERTARGET_TIMEBOUND=1 XPRS_TUNERTARGET_TIMEOBJVAL=2 XPRS_TUNERTARGET_INTEGRAL=3 XPRS_TUNERTARGET_SLPTIME=4 XPRS_TUNERTARGET_SLPOBJVAL=5 XPRS_TUNERTARGET_SLPVALIDATION=6 XPRS_TUNERTARGET_GAP=7 XPRS_TUNERTARGET_BOUND=8 XPRS_TUNERTARGET_OBJVAL=9 XPRS_TUNERTARGET_PRIMALINTEGRAL=10
export XPRSTunerTarget
export XPRS_TUNERTARGET_AUTOMATIC
export XPRS_TUNERTARGET_TIMEGAP
export XPRS_TUNERTARGET_TIMEBOUND
export XPRS_TUNERTARGET_TIMEOBJVAL
export XPRS_TUNERTARGET_INTEGRAL
export XPRS_TUNERTARGET_SLPTIME
export XPRS_TUNERTARGET_SLPOBJVAL
export XPRS_TUNERTARGET_SLPVALIDATION
export XPRS_TUNERTARGET_GAP
export XPRS_TUNERTARGET_BOUND
export XPRS_TUNERTARGET_OBJVAL
export XPRS_TUNERTARGET_PRIMALINTEGRAL
Base.:(==)(x::XPRSTunerTarget, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTunerTarget) = Int(x) == i
Base.:(!=)(x::XPRSTunerTarget, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTunerTarget) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTunerTarget) where {T<:Int32} = T(a)
@enum XPRSTunerHistory XPRS_TUNERHISTORY_IGNORE=0 XPRS_TUNERHISTORY_APPEND=1 XPRS_TUNERHISTORY_REUSE=2
export XPRSTunerHistory
export XPRS_TUNERHISTORY_IGNORE
export XPRS_TUNERHISTORY_APPEND
export XPRS_TUNERHISTORY_REUSE
Base.:(==)(x::XPRSTunerHistory, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTunerHistory) = Int(x) == i
Base.:(!=)(x::XPRSTunerHistory, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTunerHistory) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTunerHistory) where {T<:Int32} = T(a)
@enum XPRSTunerRootAlg XPRS_TUNERROOTALG_DUAL=1 XPRS_TUNERROOTALG_PRIMAL=2 XPRS_TUNERROOTALG_BARRIER=4 XPRS_TUNERROOTALG_NETWORK=8
export XPRSTunerRootAlg
export XPRS_TUNERROOTALG_DUAL
export XPRS_TUNERROOTALG_PRIMAL
export XPRS_TUNERROOTALG_BARRIER
export XPRS_TUNERROOTALG_NETWORK
Base.:(==)(x::XPRSTunerRootAlg, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSTunerRootAlg) = Int(x) == i
Base.:(!=)(x::XPRSTunerRootAlg, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSTunerRootAlg) = Int(x) != i
Base.convert(::Type{T}, a::XPRSTunerRootAlg) where {T<:Int32} = T(a)
@enum XPRSLPFlags XPRS_LPFLAGS_DUAL=1 XPRS_LPFLAGS_PRIMAL=2 XPRS_LPFLAGS_BARRIER=4 XPRS_LPFLAGS_NETWORK=8
export XPRSLPFlags
export XPRS_LPFLAGS_DUAL
export XPRS_LPFLAGS_PRIMAL
export XPRS_LPFLAGS_BARRIER
export XPRS_LPFLAGS_NETWORK
Base.:(==)(x::XPRSLPFlags, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSLPFlags) = Int(x) == i
Base.:(!=)(x::XPRSLPFlags, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSLPFlags) = Int(x) != i
Base.convert(::Type{T}, a::XPRSLPFlags) where {T<:Int32} = T(a)
@enum XPRSGenConsType XPRS_GENCONS_MAX=0 XPRS_GENCONS_MIN=1 XPRS_GENCONS_AND=2 XPRS_GENCONS_OR=3 XPRS_GENCONS_ABS=4
export XPRSGenConsType
export XPRS_GENCONS_MAX
export XPRS_GENCONS_MIN
export XPRS_GENCONS_AND
export XPRS_GENCONS_OR
export XPRS_GENCONS_ABS
Base.:(==)(x::XPRSGenConsType, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSGenConsType) = Int(x) == i
Base.:(!=)(x::XPRSGenConsType, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSGenConsType) = Int(x) != i
Base.convert(::Type{T}, a::XPRSGenConsType) where {T<:Int32} = T(a)
@enum XPRSClamping XPRS_CLAMPING_PRIMAL=1 XPRS_CLAMPING_DUAL=2 XPRS_CLAMPING_SLACKS=4 XPRS_CLAMPING_RDJ=8
export XPRSClamping
export XPRS_CLAMPING_PRIMAL
export XPRS_CLAMPING_DUAL
export XPRS_CLAMPING_SLACKS
export XPRS_CLAMPING_RDJ
Base.:(==)(x::XPRSClamping, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSClamping) = Int(x) == i
Base.:(!=)(x::XPRSClamping, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSClamping) = Int(x) != i
Base.convert(::Type{T}, a::XPRSClamping) where {T<:Int32} = T(a)
@enum XPRSRowFlag XPRS_ROWFLAG_QUADRATIC=1 XPRS_ROWFLAG_DELAYED=2 XPRS_ROWFLAG_MODELCUT=4 XPRS_ROWFLAG_INDICATOR=8 XPRS_ROWFLAG_NONLINEAR=16
export XPRSRowFlag
export XPRS_ROWFLAG_QUADRATIC
export XPRS_ROWFLAG_DELAYED
export XPRS_ROWFLAG_MODELCUT
export XPRS_ROWFLAG_INDICATOR
export XPRS_ROWFLAG_NONLINEAR
Base.:(==)(x::XPRSRowFlag, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSRowFlag) = Int(x) == i
Base.:(!=)(x::XPRSRowFlag, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSRowFlag) = Int(x) != i
Base.convert(::Type{T}, a::XPRSRowFlag) where {T<:Int32} = T(a)
@enum XPRSObjControl XPRS_OBJECTIVE_PRIORITY=20001 XPRS_OBJECTIVE_WEIGHT=20002 XPRS_OBJECTIVE_ABSTOL=20003 XPRS_OBJECTIVE_RELTOL=20004 XPRS_OBJECTIVE_RHS=20005
export XPRSObjControl
export XPRS_OBJECTIVE_PRIORITY
export XPRS_OBJECTIVE_WEIGHT
export XPRS_OBJECTIVE_ABSTOL
export XPRS_OBJECTIVE_RELTOL
export XPRS_OBJECTIVE_RHS
Base.:(==)(x::XPRSObjControl, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSObjControl) = Int(x) == i
Base.:(!=)(x::XPRSObjControl, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSObjControl) = Int(x) != i
Base.convert(::Type{T}, a::XPRSObjControl) where {T<:Int32} = T(a)
@enum XPRSAllowCompute XPRS_ALLOW_COMPUTE_ALWAYS=1 XPRS_ALLOW_COMPUTE_NEVER=0 XPRS_ALLOW_COMPUTE_DEFAULT=-1
export XPRSAllowCompute
export XPRS_ALLOW_COMPUTE_ALWAYS
export XPRS_ALLOW_COMPUTE_NEVER
export XPRS_ALLOW_COMPUTE_DEFAULT
Base.:(==)(x::XPRSAllowCompute, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSAllowCompute) = Int(x) == i
Base.:(!=)(x::XPRSAllowCompute, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSAllowCompute) = Int(x) != i
Base.convert(::Type{T}, a::XPRSAllowCompute) where {T<:Int32} = T(a)
@enum XPRSComputeLog XPRS_COMPUTELOG_NEVER=0 XPRS_COMPUTELOG_REALTIME=1 XPRS_COMPUTELOG_ONCOMPLETION=2 XPRS_COMPUTELOG_ONERROR=3
export XPRSComputeLog
export XPRS_COMPUTELOG_NEVER
export XPRS_COMPUTELOG_REALTIME
export XPRS_COMPUTELOG_ONCOMPLETION
export XPRS_COMPUTELOG_ONERROR
Base.:(==)(x::XPRSComputeLog, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSComputeLog) = Int(x) == i
Base.:(!=)(x::XPRSComputeLog, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSComputeLog) = Int(x) != i
Base.convert(::Type{T}, a::XPRSComputeLog) where {T<:Int32} = T(a)
@enum XPRSNamespaces XPRS_NAMES_ROW=1 XPRS_NAMES_COLUMN=2 XPRS_NAMES_SET=3 XPRS_NAMES_PWLCONS=4 XPRS_NAMES_GENCONS=5 XPRS_NAMES_OBJECTIVE=6 XPRS_NAMES_USERFUNC=7 XPRS_NAMES_INTERNALFUNC=8 XPRS_NAMES_USERFUNCNOCASE=9 XPRS_NAMES_INTERNALFUNCNOCASE=10
export XPRSNamespaces
export XPRS_NAMES_ROW
export XPRS_NAMES_COLUMN
export XPRS_NAMES_SET
export XPRS_NAMES_PWLCONS
export XPRS_NAMES_GENCONS
export XPRS_NAMES_OBJECTIVE
export XPRS_NAMES_USERFUNC
export XPRS_NAMES_INTERNALFUNC
export XPRS_NAMES_USERFUNCNOCASE
export XPRS_NAMES_INTERNALFUNCNOCASE
Base.:(==)(x::XPRSNamespaces, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSNamespaces) = Int(x) == i
Base.:(!=)(x::XPRSNamespaces, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSNamespaces) = Int(x) != i
Base.convert(::Type{T}, a::XPRSNamespaces) where {T<:Int32} = T(a)
@enum XPRSGlobalboundingbox XPRS_GLOBALBOUNDINGBOX_NOT_APPLIED=0 XPRS_GLOBALBOUNDINGBOX_ORIGINAL=1 XPRS_GLOBALBOUNDINGBOX_AUXILIARY=2
export XPRSGlobalboundingbox
export XPRS_GLOBALBOUNDINGBOX_NOT_APPLIED
export XPRS_GLOBALBOUNDINGBOX_ORIGINAL
export XPRS_GLOBALBOUNDINGBOX_AUXILIARY
Base.:(==)(x::XPRSGlobalboundingbox, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSGlobalboundingbox) = Int(x) == i
Base.:(!=)(x::XPRSGlobalboundingbox, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSGlobalboundingbox) = Int(x) != i
Base.convert(::Type{T}, a::XPRSGlobalboundingbox) where {T<:Int32} = T(a)
@enum XPRSMultiObjOps XPRS_MULTIOBJOPS_ENABLED=1 XPRS_MULTIOBJOPS_PRESOLVE=2 XPRS_MULTIOBJOPS_RCFIXING=4
export XPRSMultiObjOps
export XPRS_MULTIOBJOPS_ENABLED
export XPRS_MULTIOBJOPS_PRESOLVE
export XPRS_MULTIOBJOPS_RCFIXING
Base.:(==)(x::XPRSMultiObjOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSMultiObjOps) = Int(x) == i
Base.:(!=)(x::XPRSMultiObjOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSMultiObjOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSMultiObjOps) where {T<:Int32} = T(a)
@enum XPRSIISOps XPRS_IISOPS_BINARY=1 XPRS_IISOPS_ZEROLOWER=2 XPRS_IISOPS_FIXEDVAR=4 XPRS_IISOPS_BOUND=8 XPRS_IISOPS_GENINTEGRALITY=16 XPRS_IISOPS_INTEGRALITY=17 XPRS_IISOPS_VARIABLE=25 XPRS_IISOPS_EQUALITY=32 XPRS_IISOPS_GENERAL=64 XPRS_IISOPS_PWL=128 XPRS_IISOPS_SET=256 XPRS_IISOPS_INDICATOR=512 XPRS_IISOPS_DELAYED=1024 XPRS_IISOPS_CONSTRAINT=2048
export XPRSIISOps
export XPRS_IISOPS_BINARY
export XPRS_IISOPS_ZEROLOWER
export XPRS_IISOPS_FIXEDVAR
export XPRS_IISOPS_BOUND
export XPRS_IISOPS_GENINTEGRALITY
export XPRS_IISOPS_INTEGRALITY
export XPRS_IISOPS_VARIABLE
export XPRS_IISOPS_EQUALITY
export XPRS_IISOPS_GENERAL
export XPRS_IISOPS_PWL
export XPRS_IISOPS_SET
export XPRS_IISOPS_INDICATOR
export XPRS_IISOPS_DELAYED
export XPRS_IISOPS_CONSTRAINT
Base.:(==)(x::XPRSIISOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSIISOps) = Int(x) == i
Base.:(!=)(x::XPRSIISOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSIISOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSIISOps) where {T<:Int32} = T(a)
@enum XPRSUserSolStatus XPRS_USERSOLSTATUS_NOT_CHECKED=0 XPRS_USERSOLSTATUS_ACCEPTED_FEASIBLE=1 XPRS_USERSOLSTATUS_ACCEPTED_OPTIMIZED=2 XPRS_USERSOLSTATUS_SEARCHED_SOL=3 XPRS_USERSOLSTATUS_SEARCHED_NOSOL=4 XPRS_USERSOLSTATUS_REJECTED_INFEAS_NOSEARCH=5 XPRS_USERSOLSTATUS_REJECTED_PARTIAL_NOSEARCH=6 XPRS_USERSOLSTATUS_REJECTED_FAILED_OPTIMIZE=7 XPRS_USERSOLSTATUS_DROPPED=8 XPRS_USERSOLSTATUS_REJECTED_CUTOFF=9 XPRS_USERSOLSTATUS_ERROR=1000
export XPRSUserSolStatus
export XPRS_USERSOLSTATUS_NOT_CHECKED
export XPRS_USERSOLSTATUS_ACCEPTED_FEASIBLE
export XPRS_USERSOLSTATUS_ACCEPTED_OPTIMIZED
export XPRS_USERSOLSTATUS_SEARCHED_SOL
export XPRS_USERSOLSTATUS_SEARCHED_NOSOL
export XPRS_USERSOLSTATUS_REJECTED_INFEAS_NOSEARCH
export XPRS_USERSOLSTATUS_REJECTED_PARTIAL_NOSEARCH
export XPRS_USERSOLSTATUS_REJECTED_FAILED_OPTIMIZE
export XPRS_USERSOLSTATUS_DROPPED
export XPRS_USERSOLSTATUS_REJECTED_CUTOFF
Base.:(==)(x::XPRSUserSolStatus, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSUserSolStatus) = Int(x) == i
Base.:(!=)(x::XPRSUserSolStatus, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSUserSolStatus) = Int(x) != i
Base.convert(::Type{T}, a::XPRSUserSolStatus) where {T<:Int32} = T(a)
@enum XPRSGlobalLSHEURStrategy XPRS_GLOBALLSHEURSTRATEGY_DEFAULT=-1 XPRS_GLOBALLSHEURSTRATEGY_NONE=0 XPRS_GLOBALLSHEURSTRATEGY_CONSERVATIVE=1 XPRS_GLOBALLSHEURSTRATEGY_MODERATE=2 XPRS_GLOBALLSHEURSTRATEGY_AGGRESSIVE=3
export XPRSGlobalLSHEURStrategy
export XPRS_GLOBALLSHEURSTRATEGY_DEFAULT
export XPRS_GLOBALLSHEURSTRATEGY_NONE
export XPRS_GLOBALLSHEURSTRATEGY_CONSERVATIVE
export XPRS_GLOBALLSHEURSTRATEGY_MODERATE
export XPRS_GLOBALLSHEURSTRATEGY_AGGRESSIVE
Base.:(==)(x::XPRSGlobalLSHEURStrategy, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSGlobalLSHEURStrategy) = Int(x) == i
Base.:(!=)(x::XPRSGlobalLSHEURStrategy, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSGlobalLSHEURStrategy) = Int(x) != i
Base.convert(::Type{T}, a::XPRSGlobalLSHEURStrategy) where {T<:Int32} = T(a)
@enum XPRSBARHGOps XPRS_BARHGOPS_ASYM_AVG=1 XPRS_BARHGOPS_START_L1=2 XPRS_BARHGOPS_START_L2=4 XPRS_BARHGOPS_START_LINF=8 XPRS_BARHGOPS_SQRT_OMEGA=16 XPRS_BARHGOPS_OMEGA_CONTRACT=32 XPRS_BARHGOPS_OMEGA_INF=64
export XPRSBARHGOps
export XPRS_BARHGOPS_ASYM_AVG
export XPRS_BARHGOPS_START_L1
export XPRS_BARHGOPS_START_L2
export XPRS_BARHGOPS_START_LINF
export XPRS_BARHGOPS_SQRT_OMEGA
export XPRS_BARHGOPS_OMEGA_CONTRACT
export XPRS_BARHGOPS_OMEGA_INF
Base.:(==)(x::XPRSBARHGOps, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSBARHGOps) = Int(x) == i
Base.:(!=)(x::XPRSBARHGOps, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSBARHGOps) = Int(x) != i
Base.convert(::Type{T}, a::XPRSBARHGOps) where {T<:Int32} = T(a)
@enum XPRSWriteDAG XPRS_WRITEDAG_REFORMULATION=1 XPRS_WRITEDAG_PRESOLVE=2
export XPRSWriteDAG
Base.:(==)(x::XPRSWriteDAG, i::Integer) = Int(x) == i
Base.:(==)(i::Integer, x::XPRSWriteDAG) = Int(x) == i
Base.:(!=)(x::XPRSWriteDAG, i::Integer) = Int(x) != i
Base.:(!=)(i::Integer, x::XPRSWriteDAG) = Int(x) != i
Base.convert(::Type{T}, a::XPRSWriteDAG) where {T<:Int32} = T(a)
"""
Wraps callable C library function XPRSendlicensing:
"""
function XPRSendlicensing()::Nothing
withLibrary() do
  faddr = getFunctionAddress("XPRSendlicensing")
  retcode = ccall(faddr, Cint, (), )
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRSendlicensing

"""
Wraps callable C library function XPRSlicense:
"""
function XPRSlicense(p_i::Int32, p_c::AbstractString)::Tuple{Int32,AbstractString}
withLibrary() do
  p_i_dummy = Ref{Int32}(0)
  p_c_buffer = Vector{Cchar}(undef, 260)
  faddr = getFunctionAddress("XPRSlicense")
  retcode = ccall(faddr, Cint, (Ref{Cint},Ptr{Cchar}), p_i_dummy, p_c_buffer)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_i = p_i_dummy[]
  p_c = unsafe_string(pointer(p_c_buffer))
  p_i, p_c
end # withLibrary()
end
export XPRSlicense

"""
Wraps callable C library function XPRSbeginlicensing:
"""
function XPRSbeginlicensing()::Int32
withLibrary() do
  p_notyet_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSbeginlicensing")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_notyet_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_notyet = p_notyet_dummy[]
  p_notyet
end # withLibrary()
end
export XPRSbeginlicensing

"""
    XPRSsetcheckedmode(checkedmode)::Nothing

You can use this function to disable some of the checking and validation of function calls and function call parameters for calls to the Xpress Optimizer API.

This checking is relatively lightweight but disabling it can improve performance in cases where non-intensive Xpress Optimizer functions are called repeatedly in a short space of time. Please note: after disabling function call checking and validation, invalid usage of Xpress Optimizer functions may not be detected and may cause the Xpress Optimizer process to behave unexpectedly or crash. It is not recommended that you disable function call checking and validation during application development.

# Arguments
- `checkedmode::Integer`: Pass as 0 to disable much of the validation for all Xpress function calls from the current process.

See also the documentation of the correponding function [XPRSsetcheckedmode](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetcheckedmode.html) in the C API.
"""
function XPRSsetcheckedmode(checkedmode)::Nothing
withLibrary() do
  checkedmodexx = Int32(checkedmode)
  faddr = getFunctionAddress("XPRSsetcheckedmode")
  retcode = ccall(faddr, Cint, (Cint,), checkedmodexx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRSsetcheckedmode

"""
    XPRSgetcheckedmode()::checkedmode

You can use this function to interrogate whether checking and validation of all Optimizer function calls is enabled for the current process.

Checking and validation is enabled by default but can be disabled by XPRSsetcheckedmode.

# Return value
- `checkedmode::Int32`: Variable that is set to 0 if checking and validation of Optimizer function calls is disabled for the current process, non-zero otherwise.

See also the documentation of the correponding function [XPRSgetcheckedmode](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcheckedmode.html) in the C API.
"""
function XPRSgetcheckedmode()::Int32
withLibrary() do
  p_checkedmode_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetcheckedmode")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_checkedmode_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_checkedmode = p_checkedmode_dummy[]
  p_checkedmode
end # withLibrary()
end
export XPRSgetcheckedmode

"""
    XPRSgetbanner()::banner

Returns the banner and copyright message.

# Return value
- `banner::AbstractString`: A buffer of at least `XPRS_MAXBANNERLENGTH` characters in which the null terminated banner string will be returned.

See also the documentation of the correponding function [XPRSgetbanner](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetbanner.html) in the C API.
"""
function XPRSgetbanner()::AbstractString
withLibrary() do
  banner_buffer = Vector{Cchar}(undef, 512)
  faddr = getFunctionAddress("XPRSgetbanner")
  retcode = ccall(faddr, Cint, (Ptr{Cchar},), banner_buffer)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  banner = unsafe_string(pointer(banner_buffer))
  banner
end # withLibrary()
end
export XPRSgetbanner

"""
    XPRSgetversion()::version

Returns the full Optimizer version number in the form 15.10.03, where 15 is the major release, 10 is the minor release, and 03 is the build number.

# Return value
- `version::AbstractString`: Buffer long enough to hold the version string (plus a null terminator).

See also the documentation of the correponding function [XPRSgetversion](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetversion.html) in the C API.
"""
function XPRSgetversion()::AbstractString
withLibrary() do
  version_buffer = Vector{Cchar}(undef, 16)
  faddr = getFunctionAddress("XPRSgetversion")
  retcode = ccall(faddr, Cint, (Ptr{Cchar},), version_buffer)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  version = unsafe_string(pointer(version_buffer))
  version
end # withLibrary()
end
export XPRSgetversion

"""
    XPRSgetversionnumbers()::major, minor, build

Returns the Optimizer version numbers split into major, minor, and build number.

# Return values
- `major::Int32`: Pointer to integer to receive the major version number.
- `minor::Int32`: Pointer to integer to receive the minor version number.
- `build::Int32`: Pointer to integer to receive the build number.

See also the documentation of the correponding function [XPRSgetversionnumbers](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetversionnumbers.html) in the C API.
"""
function XPRSgetversionnumbers()::Tuple{Int32,Int32,Int32}
withLibrary() do
  p_major_dummy = Ref{Int32}(0)
  p_minor_dummy = Ref{Int32}(0)
  p_build_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetversionnumbers")
  retcode = ccall(faddr, Cint, (Ref{Cint},Ref{Cint},Ref{Cint}), p_major_dummy, p_minor_dummy, p_build_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_major = p_major_dummy[]
  p_minor = p_minor_dummy[]
  p_build = p_build_dummy[]
  p_major, p_minor, p_build
end # withLibrary()
end
export XPRSgetversionnumbers

"""
    XPRSgetdaysleft()::daysleft

Returns the number of days left until the license expires.

# Return value
- `daysleft::Int32`: Pointer to an integer where the number of days is to be returned.

See also the documentation of the correponding function [XPRSgetdaysleft](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetdaysleft.html) in the C API.
"""
function XPRSgetdaysleft()::Int32
withLibrary() do
  p_daysleft_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetdaysleft")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_daysleft_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_daysleft = p_daysleft_dummy[]
  p_daysleft
end # withLibrary()
end
export XPRSgetdaysleft

"""
    XPRSfeaturequery(feature)::status

Checks if the provided feature is available in the current license used by the optimizer.

# Arguments
- `feature::Union{Nothing,AbstractString}`: The feature string to be checked in the license.
# Return value
- `status::Int32`: Return status of the check, a value of 1 indicates the feature is available.

See also the documentation of the correponding function [XPRSfeaturequery](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSfeaturequery.html) in the C API.
"""
function XPRSfeaturequery(feature::Union{Nothing,AbstractString})::Int32
withLibrary() do
  if isnothing(feature)
    feature_pass = C_NULL
  else
    feature_pass = feature
  end
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSfeaturequery")
  retcode = ccall(faddr, Cint, (Cstring,Ref{Cint}), feature_pass, p_status_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_status = p_status_dummy[]
  p_status
end # withLibrary()
end
export XPRSfeaturequery

"""
    XPRS_ge_setarchconsistency(consistent)::Nothing

Sets whether to force the same execution path on various CPU architecture extensions, in particular (pre-)AVX and AVX2.

# Arguments
- `consistent::Integer`: Whether to force the same execution path: 0Do not force the same execution path (default behavior); 1Force the same execution path.

See also the documentation of the correponding function [XPRS_ge_setarchconsistency](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_ge_setarchconsistency.html) in the C API.
"""
function XPRS_ge_setarchconsistency(consistent)::Nothing
withLibrary() do
  consistentxx = Int32(consistent)
  faddr = getFunctionAddress("XPRS_ge_setarchconsistency")
  retcode = ccall(faddr, Cint, (Cint,), consistentxx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRS_ge_setarchconsistency

"""
Wraps callable C library function XPRS_ge_setsafemode:
"""
function XPRS_ge_setsafemode(safemode)::Nothing
withLibrary() do
  safemodexx = Int32(safemode)
  faddr = getFunctionAddress("XPRS_ge_setsafemode")
  retcode = ccall(faddr, Cint, (Cint,), safemodexx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRS_ge_setsafemode

"""
Wraps callable C library function XPRS_ge_getsafemode:
"""
function XPRS_ge_getsafemode()::Int32
withLibrary() do
  p_safemode_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_ge_getsafemode")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_safemode_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_safemode = p_safemode_dummy[]
  p_safemode
end # withLibrary()
end
export XPRS_ge_getsafemode

"""
Wraps callable C library function XPRS_ge_setdebugmode:
"""
function XPRS_ge_setdebugmode(debugmode)::Nothing
withLibrary() do
  debugmodexx = Int32(debugmode)
  faddr = getFunctionAddress("XPRS_ge_setdebugmode")
  retcode = ccall(faddr, Cint, (Cint,), debugmodexx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRS_ge_setdebugmode

"""
Wraps callable C library function XPRS_ge_getdebugmode:
"""
function XPRS_ge_getdebugmode()::Int32
withLibrary() do
  p_debugmode_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_ge_getdebugmode")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_debugmode_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_debugmode = p_debugmode_dummy[]
  p_debugmode
end # withLibrary()
end
export XPRS_ge_getdebugmode

"""
    XPRS_ge_getlasterror(maxbytes)::msgcode, msg, nbytes

Returns the last error encountered during a call to the Xpress global environment.

# Arguments
- `maxbytes::Integer`: The size of the character buffer `msg`.
# Return values
- `msgcode::Int32`: Memory location in which the error code will be returned.
- `msg::AbstractString`: A character buffer of size `maxbytes` in which the last error message relating to the global environment will be returned.
- `nbytes::Int32`: Memory location in which the minimum required size of the buffer to hold the full error string will be returned.

See also the documentation of the correponding function [XPRS_ge_getlasterror](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_ge_getlasterror.html) in the C API.
"""
function XPRS_ge_getlasterror(maxbytes)::Tuple{Int32,AbstractString,Int32}
withLibrary() do
  p_msgcode_dummy = Ref{Int32}(0)
  msg_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_ge_getlasterror")
  retcode = ccall(faddr, Cint, (Ref{Cint},Ptr{Cchar},Cint,Ref{Cint}), p_msgcode_dummy, msg_buffer, maxbytesxx, p_nbytes_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_msgcode = p_msgcode_dummy[]
  msg = unsafe_string(pointer(msg_buffer))
  p_nbytes = p_nbytes_dummy[]
  p_msgcode, msg, p_nbytes
end # withLibrary()
end
export XPRS_ge_getlasterror

"""
    XPRS_ge_setcomputeallowed(allow)::Nothing

Set whether the current application is allowed to use the Insight Compute interface.

# Arguments
- `allow::XPRSAllowCompute`: Whether the Insight Compute interface may be used; must be one of the following constants: XPRS_ALLOW_COMPUTE_ALWAYSAlways allow solves to be sent to Compute.

See also the documentation of the correponding function [XPRS_ge_setcomputeallowed](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_ge_setcomputeallowed.html) in the C API.
"""
function XPRS_ge_setcomputeallowed(allow)::Nothing
withLibrary() do
  faddr = getFunctionAddress("XPRS_ge_setcomputeallowed")
  retcode = ccall(faddr, Cint, (Cint,), Int32(allow))
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end # withLibrary()
end
export XPRS_ge_setcomputeallowed

"""
    XPRS_ge_getcomputeallowed()::allow

Query whether the current application is allowed to use the Insight Compute interface.

# Return value
- `allow::XPRSAllowCompute`: Memory location in which the value will be returned.

See also the documentation of the correponding function [XPRS_ge_getcomputeallowed](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_ge_getcomputeallowed.html) in the C API.
"""
function XPRS_ge_getcomputeallowed()::XPRSAllowCompute
withLibrary() do
  p_allow_dummy = Ref{Cint}(0)
  faddr = getFunctionAddress("XPRS_ge_getcomputeallowed")
  retcode = ccall(faddr, Cint, (Ref{Cint},), p_allow_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_allow = XPRSAllowCompute(p_allow_dummy[])
  p_allow
end # withLibrary()
end
export XPRS_ge_getcomputeallowed

"""
    XPRSsetprobname(prob, probname)::prob

Sets the current default problem name.

This command is rarely used.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the problem name.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetprobname](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetprobname.html) in the C API.
"""
function XPRSsetprobname(prob::XPRSprob, probname::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  faddr = getFunctionAddress("XPRSsetprobname")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, probname_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetprobname

"""
    XPRSsetlogfile(prob, filename)::prob

This directs all Optimizer output to a log file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which all logging output should be written.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetlogfile](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetlogfile.html) in the C API.
"""
function XPRSsetlogfile(prob::XPRSprob, filename::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  faddr = getFunctionAddress("XPRSsetlogfile")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, filename_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetlogfile

"""
    XPRSsetdefaultcontrol(prob, control)::prob

Sets a single control to its default value.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Integer, double or string control parameter whose default value is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetdefaultcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetdefaultcontrol.html) in the C API.
"""
function XPRSsetdefaultcontrol(prob::XPRSprob, control)::XPRSprob
  controlxx = Int32(control)
  faddr = getFunctionAddress("XPRSsetdefaultcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, controlxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetdefaultcontrol

"""
    XPRSsetdefaults(prob)::prob

Sets all controls to their default values.

Must be called before the problem is read or loaded by XPRSreadprob, XPRSloadmip, XPRSloadlp, XPRSloadmiqp, XPRSloadqp.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetdefaults](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetdefaults.html) in the C API.
"""
function XPRSsetdefaults(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSsetdefaults")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetdefaults

"""
    XPRSreadprob(prob, filename, flags)::prob

Reads an (X)MPS or LP format matrix from file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: The path and file name from which the problem is to be read.
- `flags::Union{Nothing,AbstractString}`: Flags to be passed: lonly `filename.lp` is searched for; vuse the provided filename verbatim, without appending the `.mps`, `.mat` or `.lp` extension; zread a compressed input file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSreadprob](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSreadprob.html) in the C API.
"""
function XPRSreadprob(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSreadprob")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSreadprob

"""
    XPRSloadlp(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub)::prob

Enables the user to pass a matrix directly to the Optimizer, rather than reading the matrix from a file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a names for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadlp](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadlp.html) in the C API.
"""
function XPRSloadlp(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  faddr = getFunctionAddress("XPRSloadlp")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadlp

"""
    XPRSloadlp64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub)::prob

Enables the user to pass a matrix directly to the Optimizer, rather than reading the matrix from a file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a names for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadlp64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadlp64.html) in the C API.
"""
function XPRSloadlp64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  faddr = getFunctionAddress("XPRSloadlp64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadlp64

"""
    XPRSloadqp(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef)::prob

Used to load a quadratic problem into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function, although not in its constraints.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a names for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadqp](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadqp.html) in the C API.
"""
function XPRSloadqp(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int32(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  faddr = getFunctionAddress("XPRSloadqp")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadqp

"""
    XPRSloadqp64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef)::prob

Used to load a quadratic problem into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function, although not in its constraints.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a names for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadqp64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadqp64.html) in the C API.
"""
function XPRSloadqp64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int64(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  faddr = getFunctionAddress("XPRSloadqp64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadqp64

"""
    XPRSloadmiqp(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a MIQP problem, hence a MIP with quadratic objective coefficients, into the Optimizer data structures.

Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row type: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer arrays containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integers.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmiqp](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmiqp.html) in the C API.
"""
function XPRSloadmiqp(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int32(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int32})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int32}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmiqp")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmiqp

"""
    XPRSloadmiqp64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a MIQP problem, hence a MIP with quadratic objective coefficients, into the Optimizer data structures.

Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row type: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer arrays containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integers.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmiqp64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmiqp64.html) in the C API.
"""
function XPRSloadmiqp64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int64(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int64})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int64}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmiqp64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmiqp64

"""
    XPRSfixmipentities(prob, options)::prob

Fixes all the MIP entities to the values of the last found MIP solution.

This is useful for finding the reduced costs for the continuous variables after the integer variables have been fixed to their optimal values.

# Arguments
- `prob::XPRSprob`: The current problem.
- `options::Integer`: Options how to fix the MIP entities. 0If all MIP entities should be rounded to the nearest discrete value in the solution before being fixed. 1If piecewise linear and general constraints should be kept in the problem with only the non-convex decisions (i.e. which part of a non-convex piecewise linear function or which variable attains a maximum) fixed.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSfixmipentities](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSfixmipentities.html) in the C API.
"""
function XPRSfixmipentities(prob::XPRSprob, options)::XPRSprob
  optionsxx = Int32(options)
  faddr = getFunctionAddress("XPRSfixmipentities")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, optionsxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSfixmipentities

"""
    XPRSloadmodelcuts(prob, nrows, rowind)::prob

Specifies that a set of rows in the matrix will be treated as model cuts.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: The number of model cuts.
- `rowind::AbstractVector{Integer}`: An array of row indices to be treated as cuts.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmodelcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmodelcuts.html) in the C API.
"""
function XPRSloadmodelcuts(prob::XPRSprob, nrows, rowind)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSloadmodelcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmodelcuts

"""
    XPRSloaddelayedrows(prob, nrows, rowind)::prob

Specifies that a set of rows in the matrix will be treated as delayed rows during a tree search.

These are rows that must be satisfied for any integer solution, but will not be loaded into the active set of constraints until required.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: The number of delayed rows.
- `rowind::AbstractVector{Integer}`: An array of row indices to treat as delayed rows.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloaddelayedrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloaddelayedrows.html) in the C API.
"""
function XPRSloaddelayedrows(prob::XPRSprob, nrows, rowind)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSloaddelayedrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloaddelayedrows

"""
    XPRSloaddirs(prob, ndirs, colind, priority, dir, uppseudo, downpseudo)::prob

Loads directives into the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ndirs::Integer`: Number of directives.
- `colind::AbstractVector{Integer}`: Integer array of length `ndirs` containing the column numbers.
- `priority::AbstractVector{Integer}`: Integer array of length `ndirs` containing the priorities for the columns or sets.
- `dir::AbstractVector{Cchar}`: Character array of length `ndirs` specifying the branching direction for each column or set: Uthe entity is to be forced up; Dthe entity is to be forced down; Nnot specified.May be `nothing` if not required.
- `uppseudo::AbstractVector{Number}`: Double array of length `ndirs` containing the up pseudo costs for the columns or sets.
- `downpseudo::AbstractVector{Number}`: Double array of length `ndirs` containing the down pseudo costs for the columns or sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloaddirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloaddirs.html) in the C API.
"""
function XPRSloaddirs(prob::XPRSprob, ndirs, colind, priority, dir, uppseudo, downpseudo)::XPRSprob
  ndirsxx = Int32(ndirs)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(priority) || length(priority) == 0
    c_priority = nothing
  elseif isa(priority, AbstractVector{Int32})
    c_priority = priority
  else
    c_priority = convert(Vector{Int32}, priority)
  end
  if isnothing(dir) || length(dir) == 0
    c_dir = nothing
  elseif isa(dir, AbstractVector{Cchar})
    c_dir = dir
  else
    c_dir = convert(Vector{Cchar}, dir)
  end
  if isnothing(uppseudo) || length(uppseudo) == 0
    c_uppseudo = nothing
  elseif isa(uppseudo, AbstractVector{Float64})
    c_uppseudo = uppseudo
  else
    c_uppseudo = convert(Vector{Float64}, uppseudo)
  end
  if isnothing(downpseudo) || length(downpseudo) == 0
    c_downpseudo = nothing
  elseif isa(downpseudo, AbstractVector{Float64})
    c_downpseudo = downpseudo
  else
    c_downpseudo = convert(Vector{Float64}, downpseudo)
  end
  faddr = getFunctionAddress("XPRSloaddirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ndirsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_priority) ? C_NULL : c_priority, isnothing(c_dir) ? C_NULL : c_dir, isnothing(c_uppseudo) ? C_NULL : c_uppseudo, isnothing(c_downpseudo) ? C_NULL : c_downpseudo)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloaddirs

"""
    XPRSloadbranchdirs(prob, ncols, colind, dir)::prob

Loads directives into the current problem to specify which MIP entities the Optimizer should continue to branch on when a node solution is integer feasible.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of directives.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the column numbers.
- `dir::AbstractVector{Integer}`: Integer array of length `ncols` containing either 0 or 1 for the entities given in `colind`.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadbranchdirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadbranchdirs.html) in the C API.
"""
function XPRSloadbranchdirs(prob::XPRSprob, ncols, colind, dir)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(dir) || length(dir) == 0
    c_dir = nothing
  elseif isa(dir, AbstractVector{Int32})
    c_dir = dir
  else
    c_dir = convert(Vector{Int32}, dir)
  end
  faddr = getFunctionAddress("XPRSloadbranchdirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_dir) ? C_NULL : c_dir)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadbranchdirs

"""
    XPRSloadpresolvedirs(prob, ndirs, colind, priority, dir, uppseudo, downpseudo)::prob

Loads directives into the presolved matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ndirs::Integer`: Number of directives.
- `colind::AbstractVector{Integer}`: Integer array of length `ndirs` containing the column numbers.
- `priority::AbstractVector{Integer}`: Integer array of length `ndirs` containing the priorities for the columns or sets.
- `dir::AbstractVector{Cchar}`: Character array of length `ndirs` specifying the branching direction for each column or set: Uthe entity is to be forced up; Dthe entity is to be forced down; Nnot specified.May be `nothing` if not required.
- `uppseudo::AbstractVector{Number}`: Double array of length `ndirs` containing the up pseudo costs for the columns or sets.
- `downpseudo::AbstractVector{Number}`: Double array of length `ndirs` containing the down pseudo costs for the columns or sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadpresolvedirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadpresolvedirs.html) in the C API.
"""
function XPRSloadpresolvedirs(prob::XPRSprob, ndirs, colind, priority, dir, uppseudo, downpseudo)::XPRSprob
  ndirsxx = Int32(ndirs)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(priority) || length(priority) == 0
    c_priority = nothing
  elseif isa(priority, AbstractVector{Int32})
    c_priority = priority
  else
    c_priority = convert(Vector{Int32}, priority)
  end
  if isnothing(dir) || length(dir) == 0
    c_dir = nothing
  elseif isa(dir, AbstractVector{Cchar})
    c_dir = dir
  else
    c_dir = convert(Vector{Cchar}, dir)
  end
  if isnothing(uppseudo) || length(uppseudo) == 0
    c_uppseudo = nothing
  elseif isa(uppseudo, AbstractVector{Float64})
    c_uppseudo = uppseudo
  else
    c_uppseudo = convert(Vector{Float64}, uppseudo)
  end
  if isnothing(downpseudo) || length(downpseudo) == 0
    c_downpseudo = nothing
  elseif isa(downpseudo, AbstractVector{Float64})
    c_downpseudo = downpseudo
  else
    c_downpseudo = convert(Vector{Float64}, downpseudo)
  end
  faddr = getFunctionAddress("XPRSloadpresolvedirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ndirsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_priority) ? C_NULL : c_priority, isnothing(c_dir) ? C_NULL : c_dir, isnothing(c_uppseudo) ? C_NULL : c_uppseudo, isnothing(c_downpseudo) ? C_NULL : c_downpseudo)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadpresolvedirs

"""
    XPRSloadmip(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a MIP problem into the Optimizer data structures.

Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix not (including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer arrays containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integer variables.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing the set types: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmip](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmip.html) in the C API.
"""
function XPRSloadmip(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int32})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int32}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmip")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmip

"""
    XPRSloadmip64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a MIP problem into the Optimizer data structures.

Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix not (including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer arrays containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integer variables.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing the set types: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmip64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmip64.html) in the C API.
"""
function XPRSloadmip64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int64})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int64}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmip64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmip64

"""
    XPRSaddnames(prob, type, names, first, last)::prob

When a model is loaded, the rows, columns, sets, piecewise linear and general constraints of the model may not have names associated with them.

This may not be important as the rows, columns, sets, piecewise linear and general constraints can be referred to by their sequence numbers. However, if you wish row, column, set, piecewise linear and general constraint names to appear in the ASCII solutions files, the names for a range of rows/columns/... can be added with `XPRSaddnames`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `type::Integer`: XPRS_NAMES_ROW`(=1)` for row names; XPRS_NAMES_COLUMN`(=2)` for column names; XPRS_NAMES_SET`(=3)` for set names; XPRS_NAMES_PWLCONS`(=4)` for piecewise linear constraint names; XPRS_NAMES_GENCONS`(=5)` for general constraint names; XPRS_NAMES_OBJECTIVE`(=6)` for objective names.
- `names::AbstractVector{AbstractString}`: Character buffer containing the null-terminated string names.
- `first::Integer`: Start of the range of rows, columns, sets, piecewise linear constraints, general constraints or objectives.
- `last::Integer`: End of the range of rows, columns, sets, piecewise linear constraints, general constraints or objectives.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddnames](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddnames.html) in the C API.
"""
function XPRSaddnames(prob::XPRSprob, type, names::AbstractVector{T0}, first, last)::XPRSprob where {T0<:AbstractString}
  typexx = Int32(type)
  totlen = Csize_t(0)
  for i in eachindex(names)
    totlen += sizeof(names[i]) + 1
  end
  names_flat = Vector{Cchar}(undef, totlen)
  position = Csize_t(1)
  for i in eachindex(names)
    for k in 1:sizeof(names[i])
      names_flat[position] = codeunit(names[i], k)
      position += 1
    end
    names_flat[position] = 0x0
    position += 1
  end
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSaddnames")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint,Cint), prob.handle, typexx, names_flat, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddnames

"""
    XPRSaddsetnames(prob, names, first, last)::prob

When a model with MIP entities is loaded, any special ordered sets may not have names associated with them.

If you wish names to appear in the ASCII solutions files, the names for a range of sets can be added with this function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `names::AbstractVector{AbstractString}`: Character buffer containing the null-terminated string names.
- `first::Integer`: Start of the range of sets.
- `last::Integer`: End of the range of sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddsetnames](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddsetnames.html) in the C API.
"""
function XPRSaddsetnames(prob::XPRSprob, names::AbstractVector{T0}, first, last)::XPRSprob where {T0<:AbstractString}
  totlen = Csize_t(0)
  for i in eachindex(names)
    totlen += sizeof(names[i]) + 1
  end
  names_flat = Vector{Cchar}(undef, totlen)
  position = Csize_t(1)
  for i in eachindex(names)
    for k in 1:sizeof(names[i])
      names_flat[position] = codeunit(names[i], k)
      position += 1
    end
    names_flat[position] = 0x0
    position += 1
  end
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSaddsetnames")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cchar},Cint,Cint), prob.handle, names_flat, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddsetnames

"""
    XPRSscale(prob, rowscale, colscale)::prob

Re-scales the current matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowscale::AbstractVector{Integer}`: Integer array of size ROWS containing the powers of `2` with which to scale the rows, or `nothing` if not required.
- `colscale::AbstractVector{Integer}`: Integer array of size COLS containing the powers of `2` with which to scale the columns, or `nothing` if not required.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSscale](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSscale.html) in the C API.
"""
function XPRSscale(prob::XPRSprob, rowscale, colscale)::XPRSprob
  if isnothing(rowscale) || length(rowscale) == 0
    c_rowscale = nothing
  elseif isa(rowscale, AbstractVector{Int32})
    c_rowscale = rowscale
  else
    c_rowscale = convert(Vector{Int32}, rowscale)
  end
  if isnothing(colscale) || length(colscale) == 0
    c_colscale = nothing
  elseif isa(colscale, AbstractVector{Int32})
    c_colscale = colscale
  else
    c_colscale = convert(Vector{Int32}, colscale)
  end
  faddr = getFunctionAddress("XPRSscale")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(c_rowscale) ? C_NULL : c_rowscale, isnothing(c_colscale) ? C_NULL : c_colscale)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSscale

"""
    XPRSreaddirs(prob, filename)::prob

Reads a directives file to help direct the tree search.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name from which the directives are to be read.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSreaddirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSreaddirs.html) in the C API.
"""
function XPRSreaddirs(prob::XPRSprob, filename::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  faddr = getFunctionAddress("XPRSreaddirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, filename_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSreaddirs

"""
    XPRSwritedirs(prob, filename)::prob

Writes the tree search directives from the current problem to a directives file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the directives should be written.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwritedirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwritedirs.html) in the C API.
"""
function XPRSwritedirs(prob::XPRSprob, filename::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  faddr = getFunctionAddress("XPRSwritedirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, filename_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwritedirs

"""
    XPRSunloadprob(prob)::prob

Unloads and frees all memory associated with the current problem.

It also invalidates the current problem (as opposed to reading in an empty problem).

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSunloadprob](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSunloadprob.html) in the C API.
"""
function XPRSunloadprob(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSunloadprob")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSunloadprob

"""
    XPRSsetindicators(prob, nrows, rowind, colind, complement)::prob

Specifies that a set of rows in the matrix will be treated as indicator constraints during a tree search.

An indicator constraint is made of a `condition` and a `constraint`. The `condition` is of the type "`bin = value`", where `bin` is a binary variable and `value` is either 0 or 1. The `constraint` is any matrix row (may be linear, quadratic or general nonlinear). During tree search, a row configured as an indicator constraint is enforced only when condition holds, that is only if the indicator variable `bin` has the specified value. Note that every row may only get assigned a single indicator variable and term. If a row needs to be activated by multiple different terms, the row needs to be duplicated so that each term can be assigned to a distinct row. If the indicator variable should be changed, the old term needs to be deleted first (by calling XPRSdelindicators or by calling this function with a comps argument of 0) before assigning a new one.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: The number of indicator constraints.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the indices of the rows that define the constraint part for the indicator constraints.
- `colind::AbstractVector{Integer}`: Integer array of length `nrows` containing the column indices of the indicator variables.
- `complement::AbstractVector{Integer}`: Integer array of length `nrows` with the complement flags: 0not an indicator constraint (in this case the corresponding entry in the `colind` array is ignored); 1for indicator constraints with condition "`bin = 1`"; -1for indicator constraints with condition "`bin = 0`".
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetindicators](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetindicators.html) in the C API.
"""
function XPRSsetindicators(prob::XPRSprob, nrows, rowind, colind, complement)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(complement) || length(complement) == 0
    c_complement = nothing
  elseif isa(complement, AbstractVector{Int32})
    c_complement = complement
  else
    c_complement = convert(Vector{Int32}, complement)
  end
  faddr = getFunctionAddress("XPRSsetindicators")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cint}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_complement) ? C_NULL : c_complement)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetindicators

"""
    XPRSaddpwlcons(prob, npwls, npoints, colind, resultant, start, xval, yval)::prob

Adds one or more piecewise linear constraints to the problem.

Each piecewise linear constraint `y = f(x)` consists of an (input) column x, a (different) resultant (output column) y and a piecewise linear function f. The piecewise linear function f is described by at least two breakpoints, which are given as combinations of x- and y-values. Discontinuous piecewise linear functions are supported, in this case both the left and right limit at a given point need to be entered as breakpoints. To differentiate between left and right limit, the breakpoints need to be given as a list with non-decreasing x-values.

# Arguments
- `prob::XPRSprob`: The current problem.
- `npwls::Integer`: The number of piecewise linear constraints to add.
- `npoints::Integer`: The total number of breakpoints of all piecewise linear constraints that should be added.
- `colind::AbstractVector{Integer}`: Integer array of length `npwls` containing the indices of the input variables x of the piecewise linear functions.
- `resultant::AbstractVector{Integer}`: Integer array of length `npwls` containing the indices of the output variables y of the piecewise linear functions.
- `start::AbstractVector{Integer}`: Integer array of length `npwls` containing the start index of each piecewise linear constraint in the `xval` and `yval` arrays.
- `xval::AbstractVector{Number}`: Double array of length `npoints` containing the x-values of the breakpoints.
- `yval::AbstractVector{Number}`: Double array of length `npoints` containing the y-values of the breakpoints.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddpwlcons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddpwlcons.html) in the C API.
"""
function XPRSaddpwlcons(prob::XPRSprob, npwls, npoints, colind, resultant, start, xval, yval)::XPRSprob
  npwlsxx = Int32(npwls)
  npointsxx = Int32(npoints)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(resultant) || length(resultant) == 0
    c_resultant = nothing
  elseif isa(resultant, AbstractVector{Int32})
    c_resultant = resultant
  else
    c_resultant = convert(Vector{Int32}, resultant)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(xval) || length(xval) == 0
    c_xval = nothing
  elseif isa(xval, AbstractVector{Float64})
    c_xval = xval
  else
    c_xval = convert(Vector{Float64}, xval)
  end
  if isnothing(yval) || length(yval) == 0
    c_yval = nothing
  elseif isa(yval, AbstractVector{Float64})
    c_yval = yval
  else
    c_yval = convert(Vector{Float64}, yval)
  end
  faddr = getFunctionAddress("XPRSaddpwlcons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, npwlsxx, npointsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_resultant) ? C_NULL : c_resultant, isnothing(c_start) ? C_NULL : c_start, isnothing(c_xval) ? C_NULL : c_xval, isnothing(c_yval) ? C_NULL : c_yval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddpwlcons

"""
    XPRSaddpwlcons64(prob, npwls, npoints, colind, resultant, start, xval, yval)::prob

Adds one or more piecewise linear constraints to the problem.

Each piecewise linear constraint `y = f(x)` consists of an (input) column x, a (different) resultant (output column) y and a piecewise linear function f. The piecewise linear function f is described by at least two breakpoints, which are given as combinations of x- and y-values. Discontinuous piecewise linear functions are supported, in this case both the left and right limit at a given point need to be entered as breakpoints. To differentiate between left and right limit, the breakpoints need to be given as a list with non-decreasing x-values.

# Arguments
- `prob::XPRSprob`: The current problem.
- `npwls::Integer`: The number of piecewise linear constraints to add.
- `npoints::Integer`: The total number of breakpoints of all piecewise linear constraints that should be added.
- `colind::AbstractVector{Integer}`: Integer array of length `npwls` containing the indices of the input variables x of the piecewise linear functions.
- `resultant::AbstractVector{Integer}`: Integer array of length `npwls` containing the indices of the output variables y of the piecewise linear functions.
- `start::AbstractVector{Integer}`: Integer array of length `npwls` containing the start index of each piecewise linear constraint in the `xval` and `yval` arrays.
- `xval::AbstractVector{Number}`: Double array of length `npoints` containing the x-values of the breakpoints.
- `yval::AbstractVector{Number}`: Double array of length `npoints` containing the y-values of the breakpoints.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddpwlcons64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddpwlcons64.html) in the C API.
"""
function XPRSaddpwlcons64(prob::XPRSprob, npwls, npoints, colind, resultant, start, xval, yval)::XPRSprob
  npwlsxx = Int32(npwls)
  npointsxx = Int64(npoints)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(resultant) || length(resultant) == 0
    c_resultant = nothing
  elseif isa(resultant, AbstractVector{Int32})
    c_resultant = resultant
  else
    c_resultant = convert(Vector{Int32}, resultant)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(xval) || length(xval) == 0
    c_xval = nothing
  elseif isa(xval, AbstractVector{Float64})
    c_xval = xval
  else
    c_xval = convert(Vector{Float64}, xval)
  end
  if isnothing(yval) || length(yval) == 0
    c_yval = nothing
  elseif isa(yval, AbstractVector{Float64})
    c_yval = yval
  else
    c_yval = convert(Vector{Float64}, yval)
  end
  faddr = getFunctionAddress("XPRSaddpwlcons64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Clonglong},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, npwlsxx, npointsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_resultant) ? C_NULL : c_resultant, isnothing(c_start) ? C_NULL : c_start, isnothing(c_xval) ? C_NULL : c_xval, isnothing(c_yval) ? C_NULL : c_yval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddpwlcons64

"""
    XPRSgetpwlcons(prob, colind, resultant, start, xval, yval, maxpoints, first, last)::colind, resultant, start, xval, yval, npoints

Returns the piecewise linear constraints `y = f(x)` in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `x`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the start indices of the different constraints in the breakpoint arrays.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `xval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `x`-values of the breakpoints.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `yval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `y`-values of the breakpoints.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxpoints::Integer`: Maximum number of breakpoints to be retrieved.
- `first::Integer`: First piecewise linear constraint in the range.
- `last::Integer`: Last piecewise linear constraint in the range.
# Return values
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `x`.
- `resultant::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
- `start::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the start indices of the different constraints in the breakpoint arrays.
- `xval::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `x`-values of the breakpoints.
- `yval::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `y`-values of the breakpoints.
- `npoints::Int32`: Pointer to return the number of breakpoints in the selected constraints.

See also the documentation of the correponding function [XPRSgetpwlcons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpwlcons.html) in the C API.
"""
function XPRSgetpwlcons(prob::XPRSprob, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, start::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, xval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, yval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxpoints, first, last)::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Int32}
  maxpointsxx = Int32(maxpoints)
  p_npoints_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, last - first + 1)
  elseif colind != nothing
    if length(colind) < last - first + 1
      throw(XPRSexception("Argument colind is too short, needs " * (last - first + 1) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(resultant, XPRSallocatable)
    resultant = Vector{Int32}(undef, last - first + 1)
  elseif resultant != nothing
    if length(resultant) < last - first + 1
      throw(XPRSexception("Argument resultant is too short, needs " * (last - first + 1) * " elements but has only " * length(resultant), nothing))
    end
  end
  if isa(start, XPRSallocatable)
    start = Vector{Int32}(undef, last - first + 2)
  elseif start != nothing
    if length(start) < last - first + 2
      throw(XPRSexception("Argument start is too short, needs " * (last - first + 2) * " elements but has only " * length(start), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpwlcons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, isnothing(colind) ? C_NULL : colind, isnothing(resultant) ? C_NULL : resultant, isnothing(start) ? C_NULL : start, isnothing(xval) ? C_NULL : xval, isnothing(yval) ? C_NULL : yval, maxpointsxx, p_npoints_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_npoints = p_npoints_dummy[]
  colind, resultant, start, xval, yval, p_npoints
end
export XPRSgetpwlcons

"""
    XPRSgetpwlcons64(prob, colind, resultant, start, xval, yval, maxpoints, first, last)::colind, resultant, start, xval, yval, npoints

Returns the piecewise linear constraints `y = f(x)` in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `x`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}`: Integer array which will be filled with the start indices of the different constraints in the breakpoint arrays.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `xval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `x`-values of the breakpoints.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `yval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `y`-values of the breakpoints.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxpoints::Integer`: Maximum number of breakpoints to be retrieved.
- `first::Integer`: First piecewise linear constraint in the range.
- `last::Integer`: Last piecewise linear constraint in the range.
# Return values
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `x`.
- `resultant::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
- `start::Union{Nothing,AbstractVector{Int64}}`: Integer array which will be filled with the start indices of the different constraints in the breakpoint arrays.
- `xval::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `x`-values of the breakpoints.
- `yval::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxpoints` which will be filled with the `y`-values of the breakpoints.
- `npoints::Int64`: Pointer to return the number of breakpoints in the selected constraints.

See also the documentation of the correponding function [XPRSgetpwlcons64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpwlcons64.html) in the C API.
"""
function XPRSgetpwlcons64(prob::XPRSprob, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, start::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}, xval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, yval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxpoints, first, last)::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Int64}
  maxpointsxx = Int64(maxpoints)
  p_npoints_dummy = Ref{Int64}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, last - first + 1)
  elseif colind != nothing
    if length(colind) < last - first + 1
      throw(XPRSexception("Argument colind is too short, needs " * (last - first + 1) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(resultant, XPRSallocatable)
    resultant = Vector{Int32}(undef, last - first + 1)
  elseif resultant != nothing
    if length(resultant) < last - first + 1
      throw(XPRSexception("Argument resultant is too short, needs " * (last - first + 1) * " elements but has only " * length(resultant), nothing))
    end
  end
  if isa(start, XPRSallocatable)
    start = Vector{Int64}(undef, last - first + 2)
  elseif start != nothing
    if length(start) < last - first + 2
      throw(XPRSexception("Argument start is too short, needs " * (last - first + 2) * " elements but has only " * length(start), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpwlcons64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Ptr{Clonglong},Ptr{Cdouble},Ptr{Cdouble},Clonglong,Ref{Clonglong},Cint,Cint), prob.handle, isnothing(colind) ? C_NULL : colind, isnothing(resultant) ? C_NULL : resultant, isnothing(start) ? C_NULL : start, isnothing(xval) ? C_NULL : xval, isnothing(yval) ? C_NULL : yval, maxpointsxx, p_npoints_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_npoints = p_npoints_dummy[]
  colind, resultant, start, xval, yval, p_npoints
end
export XPRSgetpwlcons64

"""
    XPRSaddgencons(prob, ncons, ncols, nvals, contype, resultant, colstart, colind, valstart, val)::prob

Adds one or more general constraints to the problem.

Each general constraint `y = f(x1, ..., xn, c1, ..., cn)` consists of one or more (input) columns xi, zero or more constant values ci and a resultant (output column) y, different from all xi. General constraints include `maximum` and `minimum` (arbitrary number of input columns of any type and arbitrary number of input values, at least one total), `and` and `or` (at least one binary input column, no constant values, binary resultant) and `absolute value` (exactly one input column of arbitrary type, no constant values).

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncons::Integer`: The number of general constraints to add.
- `ncols::Integer`: The total number of input variables in general constraints that should be added.
- `nvals::Integer`: The total number of constant values in general constraints that should be added.
- `contype::AbstractVector{XPRSGenConsType}`: Integer array of length `ncons` containing the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
- `resultant::AbstractVector{Integer}`: Integer array of length `ncons` containing the indices of the output variables of the general constraints.
- `colstart::AbstractVector{Integer}`: Integer array of length `ncons` containing the start index of each general constraint in the `colind` array.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the input variables in all general constraints.
- `valstart::AbstractVector{Integer}`: Integer array of length `ncons` containing the start index of each general constraint in the `val` array (may be `nothing` if `ncoefs = 0`).
- `val::AbstractVector{Number}`: Double array of length `nvals` containing the constant values in all general constraints (may be `nothing` if `ncoefs = 0`).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddgencons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddgencons.html) in the C API.
"""
function XPRSaddgencons(prob::XPRSprob, ncons, ncols, nvals, contype, resultant, colstart, colind, valstart, val)::XPRSprob
  nconsxx = Int32(ncons)
  ncolsxx = Int32(ncols)
  nvalsxx = Int32(nvals)
  if isnothing(contype) || length(contype) == 0
    c_contype = C_NULL
  else
    c_contype = convert(Vector{Int32}, contype)
  end
  if isnothing(resultant) || length(resultant) == 0
    c_resultant = nothing
  elseif isa(resultant, AbstractVector{Int32})
    c_resultant = resultant
  else
    c_resultant = convert(Vector{Int32}, resultant)
  end
  if isnothing(colstart) || length(colstart) == 0
    c_colstart = nothing
  elseif isa(colstart, AbstractVector{Int32})
    c_colstart = colstart
  else
    c_colstart = convert(Vector{Int32}, colstart)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(valstart) || length(valstart) == 0
    c_valstart = nothing
  elseif isa(valstart, AbstractVector{Int32})
    c_valstart = valstart
  else
    c_valstart = convert(Vector{Int32}, valstart)
  end
  if isnothing(val) || length(val) == 0
    c_val = nothing
  elseif isa(val, AbstractVector{Float64})
    c_val = val
  else
    c_val = convert(Vector{Float64}, val)
  end
  faddr = getFunctionAddress("XPRSaddgencons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ptr{Int32},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, nconsxx, ncolsxx, nvalsxx, c_contype, isnothing(c_resultant) ? C_NULL : c_resultant, isnothing(c_colstart) ? C_NULL : c_colstart, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_valstart) ? C_NULL : c_valstart, isnothing(c_val) ? C_NULL : c_val)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddgencons

"""
    XPRSaddgencons64(prob, ncons, ncols, nvals, contype, resultant, colstart, colind, valstart, val)::prob

Adds one or more general constraints to the problem.

Each general constraint `y = f(x1, ..., xn, c1, ..., cn)` consists of one or more (input) columns xi, zero or more constant values ci and a resultant (output column) y, different from all xi. General constraints include `maximum` and `minimum` (arbitrary number of input columns of any type and arbitrary number of input values, at least one total), `and` and `or` (at least one binary input column, no constant values, binary resultant) and `absolute value` (exactly one input column of arbitrary type, no constant values).

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncons::Integer`: The number of general constraints to add.
- `ncols::Integer`: The total number of input variables in general constraints that should be added.
- `nvals::Integer`: The total number of constant values in general constraints that should be added.
- `contype::AbstractVector{XPRSGenConsType}`: Integer array of length `ncons` containing the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
- `resultant::AbstractVector{Integer}`: Integer array of length `ncons` containing the indices of the output variables of the general constraints.
- `colstart::AbstractVector{Integer}`: Integer array of length `ncons` containing the start index of each general constraint in the `colind` array.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the input variables in all general constraints.
- `valstart::AbstractVector{Integer}`: Integer array of length `ncons` containing the start index of each general constraint in the `val` array (may be `nothing` if `ncoefs = 0`).
- `val::AbstractVector{Number}`: Double array of length `nvals` containing the constant values in all general constraints (may be `nothing` if `ncoefs = 0`).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddgencons64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddgencons64.html) in the C API.
"""
function XPRSaddgencons64(prob::XPRSprob, ncons, ncols, nvals, contype, resultant, colstart, colind, valstart, val)::XPRSprob
  nconsxx = Int32(ncons)
  ncolsxx = Int64(ncols)
  nvalsxx = Int64(nvals)
  if isnothing(contype) || length(contype) == 0
    c_contype = C_NULL
  else
    c_contype = convert(Vector{Int32}, contype)
  end
  if isnothing(resultant) || length(resultant) == 0
    c_resultant = nothing
  elseif isa(resultant, AbstractVector{Int32})
    c_resultant = resultant
  else
    c_resultant = convert(Vector{Int32}, resultant)
  end
  if isnothing(colstart) || length(colstart) == 0
    c_colstart = nothing
  elseif isa(colstart, AbstractVector{Int64})
    c_colstart = colstart
  else
    c_colstart = convert(Vector{Int64}, colstart)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(valstart) || length(valstart) == 0
    c_valstart = nothing
  elseif isa(valstart, AbstractVector{Int64})
    c_valstart = valstart
  else
    c_valstart = convert(Vector{Int64}, valstart)
  end
  if isnothing(val) || length(val) == 0
    c_val = nothing
  elseif isa(val, AbstractVector{Float64})
    c_val = val
  else
    c_val = convert(Vector{Float64}, val)
  end
  faddr = getFunctionAddress("XPRSaddgencons64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Clonglong,Ptr{Int32},Ptr{Cint},Ptr{Clonglong},Ptr{Cint},Ptr{Clonglong},Ptr{Cdouble}), prob.handle, nconsxx, ncolsxx, nvalsxx, c_contype, isnothing(c_resultant) ? C_NULL : c_resultant, isnothing(c_colstart) ? C_NULL : c_colstart, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_valstart) ? C_NULL : c_valstart, isnothing(c_val) ? C_NULL : c_val)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddgencons64

"""
    XPRSgetgencons(prob, contype, resultant, colstart, colind, maxcols, valstart, val, maxvals, first, last)::contype, resultant, colstart, colind, ncols, valstart, val, nvals

Returns the general constraints `y = f(x1, ..., xn, c1, ..., cm)` in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `contype::Union{XPRSallocatable,Nothing,AbstractVector{XPRSGenConsType}}`: `nothing` if not required or an integer array of length at least `last-first+1` which will be filled with the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colstart::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `colind` array.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `xi`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxcols::Integer`: Maximum number of input columns to be retrieved.
- `valstart::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `val` array.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `val::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Integer array which will be filled with the constant values `ci`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxvals::Integer`: Maximum number of constant values to be retrieved.
- `first::Integer`: First general constraint in the range.
- `last::Integer`: Last general constraint in the range.
# Return values
- `contype::Union{Nothing,AbstractVector{XPRSGenConsType}}`: `nothing` if not required or an integer array of length at least `last-first+1` which will be filled with the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
- `resultant::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
- `colstart::Union{Nothing,AbstractVector{Int32}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `colind` array.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `xi`.
- `ncols::Int32`: Pointer to return the number of input columns in the `colind` array.
- `valstart::Union{Nothing,AbstractVector{Int32}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `val` array.
- `val::Union{Nothing,AbstractVector{Float64}}`: Integer array which will be filled with the constant values `ci`.
- `nvals::Int32`: Pointer to return the number of constant values in the `val` array.

See also the documentation of the correponding function [XPRSgetgencons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetgencons.html) in the C API.
"""
function XPRSgetgencons(prob::XPRSprob, contype::Union{XPRSallocatable,Nothing,AbstractVector{XPRSGenConsType}}, resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colstart::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, maxcols, valstart::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, val::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxvals, first, last)::Tuple{Union{Nothing,AbstractVector{XPRSGenConsType}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Int32}
  maxcolsxx = Int32(maxcols)
  p_ncols_dummy = Ref{Int32}(0)
  maxvalsxx = Int32(maxvals)
  p_nvals_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(colstart, XPRSallocatable)
    colstart = Vector{Int32}(undef, last - first + 2)
  elseif colstart != nothing
    if length(colstart) < last - first + 2
      throw(XPRSexception("Argument colstart is too short, needs " * (last - first + 2) * " elements but has only " * length(colstart), nothing))
    end
  end
  if isa(contype, XPRSallocatable)
    c_contype = Vector{Int32}(undef, last - first + 1)
  elseif contype != nothing
    if length(contype) < last - first + 1
      throw(XPRSexception("Argument contype is too short, needs " * (last - first + 1) * " elements but has only " * length(contype), nothing))
    end
    c_contype = convert(Vector{Int32}, contype)
  end
  if isa(resultant, XPRSallocatable)
    resultant = Vector{Int32}(undef, last - first + 1)
  elseif resultant != nothing
    if length(resultant) < last - first + 1
      throw(XPRSexception("Argument resultant is too short, needs " * (last - first + 1) * " elements but has only " * length(resultant), nothing))
    end
  end
  if isa(valstart, XPRSallocatable)
    valstart = Vector{Int32}(undef, last - first + 2)
  elseif valstart != nothing
    if length(valstart) < last - first + 2
      throw(XPRSexception("Argument valstart is too short, needs " * (last - first + 2) * " elements but has only " * length(valstart), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetgencons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Int32},Ptr{Cint},Ptr{Cint},Ptr{Cint},Cint,Ref{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, c_contype, isnothing(resultant) ? C_NULL : resultant, isnothing(colstart) ? C_NULL : colstart, isnothing(colind) ? C_NULL : colind, maxcolsxx, p_ncols_dummy, isnothing(valstart) ? C_NULL : valstart, isnothing(val) ? C_NULL : val, maxvalsxx, p_nvals_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  if isnothing(contype)
    contype = nothing
  elseif isa(contype, XPRSallocatable)
    contype = map(x->XPRSGenConsType(x), c_contype)
  else
    for i in eachindex(c_contype)
      contype[i] = XPRSGenConsType(c_contype[i])
    end
  end
  p_ncols = p_ncols_dummy[]
  p_nvals = p_nvals_dummy[]
  contype, resultant, colstart, colind, p_ncols, valstart, val, p_nvals
end
export XPRSgetgencons

"""
    XPRSgetgencons64(prob, contype, resultant, colstart, colind, maxcols, valstart, val, maxvals, first, last)::contype, resultant, colstart, colind, ncols, valstart, val, nvals

Returns the general constraints `y = f(x1, ..., xn, c1, ..., cm)` in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `contype::Union{XPRSallocatable,Nothing,AbstractVector{XPRSGenConsType}}`: `nothing` if not required or an integer array of length at least `last-first+1` which will be filled with the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colstart::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `colind` array.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `xi`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxcols::Integer`: Maximum number of input columns to be retrieved.
- `valstart::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `val` array.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `val::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Integer array which will be filled with the constant values `ci`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxvals::Integer`: Maximum number of constant values to be retrieved.
- `first::Integer`: First general constraint in the range.
- `last::Integer`: Last general constraint in the range.
# Return values
- `contype::Union{Nothing,AbstractVector{XPRSGenConsType}}`: `nothing` if not required or an integer array of length at least `last-first+1` which will be filled with the types of the general constraints: XPRS_GENCONS_MAX (0)indicates a `maximum` constraint; XPRS_GENCONS_MIN (1)indicates a `minimum` constraint; XPRS_GENCONS_AND (2)indicates an `and` constraint.
- `resultant::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the output variables `y`.
- `colstart::Union{Nothing,AbstractVector{Int64}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `colind` array.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the indices of the input variables `xi`.
- `ncols::Int64`: Pointer to return the number of input columns in the `colind` array.
- `valstart::Union{Nothing,AbstractVector{Int64}}`: Integer array of length at least `last-first+2` which will be filled with the start index of each general constraint in the `val` array.
- `val::Union{Nothing,AbstractVector{Float64}}`: Integer array which will be filled with the constant values `ci`.
- `nvals::Int64`: Pointer to return the number of constant values in the `val` array.

See also the documentation of the correponding function [XPRSgetgencons64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetgencons64.html) in the C API.
"""
function XPRSgetgencons64(prob::XPRSprob, contype::Union{XPRSallocatable,Nothing,AbstractVector{XPRSGenConsType}}, resultant::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colstart::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, maxcols, valstart::Union{XPRSallocatable,Nothing,AbstractVector{Int64}}, val::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxvals, first, last)::Tuple{Union{Nothing,AbstractVector{XPRSGenConsType}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int64}},Union{Nothing,AbstractVector{Int32}},Int64,Union{Nothing,AbstractVector{Int64}},Union{Nothing,AbstractVector{Float64}},Int64}
  maxcolsxx = Int64(maxcols)
  p_ncols_dummy = Ref{Int64}(0)
  maxvalsxx = Int64(maxvals)
  p_nvals_dummy = Ref{Int64}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(colstart, XPRSallocatable)
    colstart = Vector{Int64}(undef, last - first + 2)
  elseif colstart != nothing
    if length(colstart) < last - first + 2
      throw(XPRSexception("Argument colstart is too short, needs " * (last - first + 2) * " elements but has only " * length(colstart), nothing))
    end
  end
  if isa(contype, XPRSallocatable)
    c_contype = Vector{Int32}(undef, last - first + 1)
  elseif contype != nothing
    if length(contype) < last - first + 1
      throw(XPRSexception("Argument contype is too short, needs " * (last - first + 1) * " elements but has only " * length(contype), nothing))
    end
    c_contype = convert(Vector{Int32}, contype)
  end
  if isa(resultant, XPRSallocatable)
    resultant = Vector{Int32}(undef, last - first + 1)
  elseif resultant != nothing
    if length(resultant) < last - first + 1
      throw(XPRSexception("Argument resultant is too short, needs " * (last - first + 1) * " elements but has only " * length(resultant), nothing))
    end
  end
  if isa(valstart, XPRSallocatable)
    valstart = Vector{Int64}(undef, last - first + 2)
  elseif valstart != nothing
    if length(valstart) < last - first + 2
      throw(XPRSexception("Argument valstart is too short, needs " * (last - first + 2) * " elements but has only " * length(valstart), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetgencons64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Int32},Ptr{Cint},Ptr{Clonglong},Ptr{Cint},Clonglong,Ref{Clonglong},Ptr{Clonglong},Ptr{Cdouble},Clonglong,Ref{Clonglong},Cint,Cint), prob.handle, c_contype, isnothing(resultant) ? C_NULL : resultant, isnothing(colstart) ? C_NULL : colstart, isnothing(colind) ? C_NULL : colind, maxcolsxx, p_ncols_dummy, isnothing(valstart) ? C_NULL : valstart, isnothing(val) ? C_NULL : val, maxvalsxx, p_nvals_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  if isnothing(contype)
    contype = nothing
  elseif isa(contype, XPRSallocatable)
    contype = map(x->XPRSGenConsType(x), c_contype)
  else
    for i in eachindex(c_contype)
      contype[i] = XPRSGenConsType(c_contype[i])
    end
  end
  p_ncols = p_ncols_dummy[]
  p_nvals = p_nvals_dummy[]
  contype, resultant, colstart, colind, p_ncols, valstart, val, p_nvals
end
export XPRSgetgencons64

"""
    XPRSdelpwlcons(prob, npwls, pwlind)::prob

Delete piecewise linear constraints from a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `npwls::Integer`: Number of piecewise linear constraints to delete.
- `pwlind::AbstractVector{Integer}`: An integer array of length `npwls` containing the piecewise linear constraints to delete.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelpwlcons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelpwlcons.html) in the C API.
"""
function XPRSdelpwlcons(prob::XPRSprob, npwls, pwlind)::XPRSprob
  npwlsxx = Int32(npwls)
  if isnothing(pwlind) || length(pwlind) == 0
    c_pwlind = nothing
  elseif isa(pwlind, AbstractVector{Int32})
    c_pwlind = pwlind
  else
    c_pwlind = convert(Vector{Int32}, pwlind)
  end
  faddr = getFunctionAddress("XPRSdelpwlcons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, npwlsxx, isnothing(c_pwlind) ? C_NULL : c_pwlind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelpwlcons

"""
    XPRSdelgencons(prob, ncons, conind)::prob

Delete general constraints from a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncons::Integer`: Number of general constraints to delete.
- `conind::AbstractVector{Integer}`: An integer array of length `ncons` containing the general constraints to delete.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelgencons](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelgencons.html) in the C API.
"""
function XPRSdelgencons(prob::XPRSprob, ncons, conind)::XPRSprob
  nconsxx = Int32(ncons)
  if isnothing(conind) || length(conind) == 0
    c_conind = nothing
  elseif isa(conind, AbstractVector{Int32})
    c_conind = conind
  else
    c_conind = convert(Vector{Int32}, conind)
  end
  faddr = getFunctionAddress("XPRSdelgencons")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nconsxx, isnothing(c_conind) ? C_NULL : c_conind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelgencons

"""
    XPRSdumpcontrols(prob)::prob

Displays the list of controls and their current value for those controls that have been set to a non default value.

# Arguments
- `prob::XPRSprob`: The problem for which controls are dumped.
# Return value
- `prob::XPRSprob`: The problem for which controls are dumped.

See also the documentation of the correponding function [XPRSdumpcontrols](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdumpcontrols.html) in the C API.
"""
function XPRSdumpcontrols(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSdumpcontrols")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdumpcontrols

"""
    XPRSgetindicators(prob, colind, complement, first, last)::colind, complement

Returns the indicator constraint condition (indicator variable and complement flag) associated to the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `last-first+1` where the column indices of the indicator variables are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `complement::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `last-first+1` where the indicator complement flags will be returned: 0not an indicator constraint (in this case the corresponding entry in the `colind` array is ignored); 1for indicator constraints with condition "`bin = 1`"; -1for indicator constraints with condition "`bin = 0`".
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range (inclusive).
# Return values
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `last-first+1` where the column indices of the indicator variables are to be placed.
- `complement::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `last-first+1` where the indicator complement flags will be returned: 0not an indicator constraint (in this case the corresponding entry in the `colind` array is ignored); 1for indicator constraints with condition "`bin = 1`"; -1for indicator constraints with condition "`bin = 0`".

See also the documentation of the correponding function [XPRSgetindicators](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetindicators.html) in the C API.
"""
function XPRSgetindicators(prob::XPRSprob, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, complement::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, first, last)::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, last - first + 1)
  elseif colind != nothing
    if length(colind) < last - first + 1
      throw(XPRSexception("Argument colind is too short, needs " * (last - first + 1) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(complement, XPRSallocatable)
    complement = Vector{Int32}(undef, last - first + 1)
  elseif complement != nothing
    if length(complement) < last - first + 1
      throw(XPRSexception("Argument complement is too short, needs " * (last - first + 1) * " elements but has only " * length(complement), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetindicators")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Cint,Cint), prob.handle, isnothing(colind) ? C_NULL : colind, isnothing(complement) ? C_NULL : complement, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  colind, complement
end
export XPRSgetindicators

"""
    XPRSdelindicators(prob, first, last)::prob

Delete indicator constraints.

This turns the specified rows into normal rows (not controlled by indicator variables).

# Arguments
- `prob::XPRSprob`: The current problem.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range (inclusive).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelindicators](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelindicators.html) in the C API.
"""
function XPRSdelindicators(prob::XPRSprob, first, last)::XPRSprob
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSdelindicators")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint), prob.handle, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelindicators

"""
    XPRSminim(prob, flags)::prob

**Deprecated**XPRSlpoptimize or XPRSmipoptimize should be used instead.

Begins a search for the optimal LP solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSmaxim` (`MAXIM`) or `XPRSminim` (`MINIM`).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSminim](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSminim.html) in the C API.
"""
function XPRSminim(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSminim")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSminim

"""
    XPRSmaxim(prob, flags)::prob

**Deprecated**XPRSlpoptimize or XPRSmipoptimize should be used instead.

Begins a search for the optimal LP solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSmaxim` (`MAXIM`) or `XPRSminim` (`MINIM`).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSmaxim](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmaxim.html) in the C API.
"""
function XPRSmaxim(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSmaxim")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSmaxim

"""
    XPRSlpoptimize(prob, flags)::prob

This function begins a search for the optimal continuous (LP) solution.

The direction of optimization is given by OBJSENSE. The status of the problem when the function completes can be checked using LPSTATUS. Any MIP entities in the problem will be ignored.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSlpoptimize` (`LPOPTIMIZE`).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSlpoptimize](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSlpoptimize.html) in the C API.
"""
function XPRSlpoptimize(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSlpoptimize")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSlpoptimize

"""
    XPRSmipoptimize(prob, flags)::prob

This function begins a tree search for the optimal MIP solution.

The direction of optimization is given by OBJSENSE. The status of the problem when the function completes can be checked using MIPSTATUS.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to XPRSmipoptimize (MIPOPTIMIZE), which specifies how to solve the initial continuous problem where the MIP entities are relaxed.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSmipoptimize](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmipoptimize.html) in the C API.
"""
function XPRSmipoptimize(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSmipoptimize")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSmipoptimize

"""
    XPRSoptimize(prob, flags)::solvestatus, solstatus

This function begins a search for the optimal solution of the problem.

The direction of optimization is given by OBJSENSE.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSoptimize` (`OPTIMIZE`).
# Return values
- `solvestatus::Int32`: The solve status after termination.
- `solstatus::Int32`: The solution status after termination.

See also the documentation of the correponding function [XPRSoptimize](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSoptimize.html) in the C API.
"""
function XPRSoptimize(prob::XPRSprob, flags::Union{Nothing,AbstractString})::Tuple{Int32,Int32}
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  solvestatus_dummy = Ref{Int32}(0)
  solstatus_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSoptimize")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Ref{Cint},Ref{Cint}), prob.handle, flags_pass, solvestatus_dummy, solstatus_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  solvestatus = solvestatus_dummy[]
  solstatus = solstatus_dummy[]
  solvestatus, solstatus
end
export XPRSoptimize

"""
    XPRSreadslxsol(prob, filename, flags)::prob

Reads an ASCII solution file `.slx` created by the XPRSwriteslxsol function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the solution is to be read.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSreadslxsol` (`READSLXSOL`): non-breaking-whitespace conversion; lread the solution as an LP solution in case of a MIP problem; mread the solution as a solution for the MIP problem; aread multiple MIP solutions from the `.slx` file and add them to the MIP problem; vuse the provided filename verbatim, without appending the `.slx` extension; zread a compressed input file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSreadslxsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSreadslxsol.html) in the C API.
"""
function XPRSreadslxsol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSreadslxsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSreadslxsol

"""
    XPRSalter(prob, filename)::prob

Alters or changes matrix elements, right hand sides and constraint senses in the current problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters specifying the file to be read.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSalter](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSalter.html) in the C API.
"""
function XPRSalter(prob::XPRSprob, filename::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  faddr = getFunctionAddress("XPRSalter")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, filename_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSalter

"""
    XPRSreadbasis(prob, filename, flags)::prob

Instructs the Optimizer to read in a previously saved basis from a file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name from which the basis is to be read.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSreadbasis` (`READBASIS`): CPLEX compatibility; (no effect, kept for compatibility); ninput basis file containing basic solution values; tinput a compact advanced form of the basis; vuse the provided filename verbatim, without appending the `.bss` extension; zread a compressed input file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSreadbasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSreadbasis.html) in the C API.
"""
function XPRSreadbasis(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSreadbasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSreadbasis

"""
    XPRSreadbinsol(prob, filename, flags)::prob

Reads a solution from a binary solution file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name from which the solution is to be read.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSreadbinsol` (`READBINSOL`): mload the solution as a solution for the MIP; xload the solution as a solution for the LP; vuse the provided filename verbatim, without appending the `.sol` extension; zread a compressed input file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSreadbinsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSreadbinsol.html) in the C API.
"""
function XPRSreadbinsol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSreadbinsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSreadbinsol

"""
    XPRSgetinfeas(prob, x, slack, duals, djs)::nprimalcols, nprimalrows, ndualrows, ndualcols, x, slack, duals, djs

Returns a list of infeasible primal and dual variables.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalcols` where the primal infeasible variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalrows` where the primal infeasible rows will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndualrows` where the dual infeasible rows will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndualcols` where the dual infeasible variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `nprimalcols::Int32`: Pointer to an integer where the number of primal infeasible variables is returned.
- `nprimalrows::Int32`: Pointer to an integer where the number of primal infeasible rows is returned.
- `ndualrows::Int32`: Pointer to an integer where the number of dual infeasible rows is returned.
- `ndualcols::Int32`: Pointer to an integer where the number of dual infeasible variables is returned.
- `x::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalcols` where the primal infeasible variables will be returned.
- `slack::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalrows` where the primal infeasible rows will be returned.
- `duals::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndualrows` where the dual infeasible rows will be returned.
- `djs::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndualcols` where the dual infeasible variables will be returned.

See also the documentation of the correponding function [XPRSgetinfeas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetinfeas.html) in the C API.
"""
function XPRSgetinfeas(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Int32,Int32,Int32,Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  p_nprimalcols_dummy = Ref{Int32}(0)
  p_nprimalrows_dummy = Ref{Int32}(0)
  p_ndualrows_dummy = Ref{Int32}(0)
  p_ndualcols_dummy = Ref{Int32}(0)
  if isa(djs, XPRSallocatable)
    djs = Vector{Int32}(undef, 0)
  elseif djs != nothing
    if length(djs) < 0
      throw(XPRSexception("Argument djs is too short, needs " * (0) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Int32}(undef, 0)
  elseif duals != nothing
    if length(duals) < 0
      throw(XPRSexception("Argument duals is too short, needs " * (0) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Int32}(undef, 0)
  elseif slack != nothing
    if length(slack) < 0
      throw(XPRSexception("Argument slack is too short, needs " * (0) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Int32}(undef, 0)
  elseif x != nothing
    if length(x) < 0
      throw(XPRSexception("Argument x is too short, needs " * (0) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetinfeas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ref{Cint},Ref{Cint},Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint}), prob.handle, p_nprimalcols_dummy, p_nprimalrows_dummy, p_ndualrows_dummy, p_ndualcols_dummy, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nprimalcols = p_nprimalcols_dummy[]
  p_nprimalrows = p_nprimalrows_dummy[]
  p_ndualrows = p_ndualrows_dummy[]
  p_ndualcols = p_ndualcols_dummy[]
  p_nprimalcols, p_nprimalrows, p_ndualrows, p_ndualcols, x, slack, duals, djs
end
export XPRSgetinfeas

"""
    XPRSgetscaledinfeas(prob, x, slack, duals, djs)::nprimalcols, nprimalrows, ndualrows, ndualcols, x, slack, duals, djs

Returns a list of scaled infeasible primal and dual variables for the original problem.

If the problem is currently presolved, it is postsolved before the function returns.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalcols` where the primal infeasible variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalrows` where the primal infeasible rows will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndualrows` where the dual infeasible rows will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndualcols` where the dual infeasible variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `nprimalcols::Int32`: Number of primal infeasible variables.
- `nprimalrows::Int32`: Number of primal infeasible rows.
- `ndualrows::Int32`: Number of dual infeasible rows.
- `ndualcols::Int32`: Number of dual infeasible variables.
- `x::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalcols` where the primal infeasible variables will be returned.
- `slack::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nprimalrows` where the primal infeasible rows will be returned.
- `duals::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndualrows` where the dual infeasible rows will be returned.
- `djs::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndualcols` where the dual infeasible variables will be returned.

See also the documentation of the correponding function [XPRSgetscaledinfeas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetscaledinfeas.html) in the C API.
"""
function XPRSgetscaledinfeas(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Int32,Int32,Int32,Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  p_nprimalcols_dummy = Ref{Int32}(0)
  p_nprimalrows_dummy = Ref{Int32}(0)
  p_ndualrows_dummy = Ref{Int32}(0)
  p_ndualcols_dummy = Ref{Int32}(0)
  if isa(djs, XPRSallocatable)
    djs = Vector{Int32}(undef, 0)
  elseif djs != nothing
    if length(djs) < 0
      throw(XPRSexception("Argument djs is too short, needs " * (0) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Int32}(undef, 0)
  elseif duals != nothing
    if length(duals) < 0
      throw(XPRSexception("Argument duals is too short, needs " * (0) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Int32}(undef, 0)
  elseif slack != nothing
    if length(slack) < 0
      throw(XPRSexception("Argument slack is too short, needs " * (0) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Int32}(undef, 0)
  elseif x != nothing
    if length(x) < 0
      throw(XPRSexception("Argument x is too short, needs " * (0) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetscaledinfeas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ref{Cint},Ref{Cint},Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint}), prob.handle, p_nprimalcols_dummy, p_nprimalrows_dummy, p_ndualrows_dummy, p_ndualcols_dummy, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nprimalcols = p_nprimalcols_dummy[]
  p_nprimalrows = p_nprimalrows_dummy[]
  p_ndualrows = p_ndualrows_dummy[]
  p_ndualcols = p_ndualcols_dummy[]
  p_nprimalcols, p_nprimalrows, p_ndualrows, p_ndualcols, x, slack, duals, djs
end
export XPRSgetscaledinfeas

"""
    XPRSgetunbvec(prob)::seq

Returns the index vector which causes the primal simplex or dual simplex algorithm to determine that a matrix is primal or dual unbounded respectively.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `seq::Int32`: Pointer to an integer where the vector causing the problem to be detected as being primal or dual unbounded will be returned.

See also the documentation of the correponding function [XPRSgetunbvec](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetunbvec.html) in the C API.
"""
function XPRSgetunbvec(prob::XPRSprob)::Int32
  p_seq_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetunbvec")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), prob.handle, p_seq_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_seq = p_seq_dummy[]
  p_seq
end
export XPRSgetunbvec

"""
    XPRScrossoverlpsol(prob)::status

Provides a basic optimal solution for a given solution of an LP problem.

This function behaves like the crossover after the barrier algorithm.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `status::Int32`: Pointer to an `int` where the status will be returned.

See also the documentation of the correponding function [XPRScrossoverlpsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScrossoverlpsol.html) in the C API.
"""
function XPRScrossoverlpsol(prob::XPRSprob)::Int32
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRScrossoverlpsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), prob.handle, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRScrossoverlpsol

"""
    XPRStune(prob, flags)::prob

This function begins a tuner session for the current problem.

The tuner will solve the problem multiple times while evaluating a list of control settings and promising combinations of them. When finished, the tuner will select and set the best control setting on the problem. Note that the direction of optimization is given by OBJSENSE.

# Arguments
- `prob::XPRSprob`: The current problem.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to XPRStune, which specify whether to tune the current problem as an LP or a MIP problem, and the algorithm for solving the LP problem or the initial LP relaxation of the MIP.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRStune](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRStune.html) in the C API.
"""
function XPRStune(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRStune")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRStune

"""
    XPRStuneprobsetfile(prob, setfile, ifmip, sense)::prob

This function begins a tuner session for a set of problems.

The tuner will solve the problems multiple times while evaluating a list of control settings and promising combinations of them. When finished, the tuner will select and set the best control setting on the problems.

# Arguments
- `prob::XPRSprob`: The current problem.
- `setfile::Union{Nothing,AbstractString}`: A plain text file which contains a list of problem filenames.
- `ifmip::Integer`: -1to automatically determine whether to solve the problem set as LP or MIP; 0to force the tuner to tune the problem set as LP; 1to force the tuner to tune the problem set as MIP.
- `sense::Integer`: 0to automatically determine the sense of each problem; 1to force the tuner to minimize each problem; -1to force the tuner to maximize each problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRStuneprobsetfile](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRStuneprobsetfile.html) in the C API.
"""
function XPRStuneprobsetfile(prob::XPRSprob, setfile::Union{Nothing,AbstractString}, ifmip, sense)::XPRSprob
  if isnothing(setfile)
    setfile_pass = C_NULL
  else
    setfile_pass = setfile
  end
  ifmipxx = Int32(ifmip)
  sensexx = Int32(sense)
  faddr = getFunctionAddress("XPRStuneprobsetfile")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint), prob.handle, setfile_pass, ifmipxx, sensexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRStuneprobsetfile

"""
    XPRStunerwritemethod(prob, methodfile)::prob

This function writes the current tuner method to a given file or prints it to the console.

# Arguments
- `prob::XPRSprob`: The current problem.
- `methodfile::Union{Nothing,AbstractString}`: The method file name, to which the tuner will write the current tuner method.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRStunerwritemethod](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRStunerwritemethod.html) in the C API.
"""
function XPRStunerwritemethod(prob::XPRSprob, methodfile::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(methodfile)
    methodfile_pass = C_NULL
  else
    methodfile_pass = methodfile
  end
  faddr = getFunctionAddress("XPRStunerwritemethod")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, methodfile_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRStunerwritemethod

"""
    XPRStunerreadmethod(prob, methodfile)::prob

This function loads a user defined tuner method from the given file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `methodfile::Union{Nothing,AbstractString}`: The method file name, from which the tuner can load a user-defined tuner method.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRStunerreadmethod](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRStunerreadmethod.html) in the C API.
"""
function XPRStunerreadmethod(prob::XPRSprob, methodfile::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(methodfile)
    methodfile_pass = C_NULL
  else
    methodfile_pass = methodfile
  end
  faddr = getFunctionAddress("XPRStunerreadmethod")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, methodfile_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRStunerreadmethod

"""
Wraps callable C library function XPRSgetbarnumstability:
"""
function XPRSgetbarnumstability(prob::XPRSprob, colstab::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowstab::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  if isa(colstab, XPRSallocatable)
    colstab = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif colstab != nothing
    if length(colstab) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument colstab is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(colstab), nothing))
    end
  end
  if isa(rowstab, XPRSallocatable)
    rowstab = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif rowstab != nothing
    if length(rowstab) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument rowstab is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(rowstab), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetbarnumstability")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(colstab) ? C_NULL : colstab, isnothing(rowstab) ? C_NULL : rowstab)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  colstab, rowstab
end
export XPRSgetbarnumstability

"""
    XPRSgetlastbarsol(prob, x, slack, duals, djs)::x, slack, duals, djs, status

Used to obtain the last barrier solution values following optimization that used the barrier solver.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALROWS` where the values of the dual variables (cBTB-1) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALCOLS` where the reduced cost for each variable (cT-cBTB-1A) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
- `slack::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.
- `duals::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALROWS` where the values of the dual variables (cBTB-1) will be returned.
- `djs::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALCOLS` where the reduced cost for each variable (cT-cBTB-1A) will be returned.
- `status::Int32`: Status of the last barrier solve.

See also the documentation of the correponding function [XPRSgetlastbarsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetlastbarsol.html) in the C API.
"""
function XPRSgetlastbarsol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Int32}
  p_status_dummy = Ref{Int32}(0)
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif duals != nothing
    if length(duals) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument duals is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetlastbarsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ref{Cint}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  x, slack, duals, djs, p_status
end
export XPRSgetlastbarsol

"""
    XPRSiisclear(prob)::prob

Resets the search for Irreducible Infeasible Sets (IIS).

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSiisclear](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisclear.html) in the C API.
"""
function XPRSiisclear(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSiisclear")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSiisclear

"""
    XPRSiisfirst(prob, mode)::status

Initiates a search for an Irreducible Infeasible Set (IIS) in an infeasible problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `mode::Integer`: The IIS search mode: 0stops after finding the initial infeasible subproblem; 1find an IIS, emphasizing simplicity of the IIS; 2find an IIS, emphasizing a quick result.
# Return value
- `status::Int32`: The status after the search: 0success; 1feasible problem; 2error; 3timeout or interruption.

See also the documentation of the correponding function [XPRSiisfirst](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisfirst.html) in the C API.
"""
function XPRSiisfirst(prob::XPRSprob, mode)::Int32
  modexx = Int32(mode)
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSiisfirst")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, modexx, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSiisfirst

"""
    XPRSiisnext(prob)::status

Continues the search for further Irreducible Infeasible Sets (IIS), or calls XPRSiisfirst (IIS) if no IIS has been identified yet.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `status::Int32`: The status after the search: 0success; 1no more IIS could be found, or problem is feasible if no XPRSiisfirst call preceded; 2on error (when the function returns nonzero).

See also the documentation of the correponding function [XPRSiisnext](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisnext.html) in the C API.
"""
function XPRSiisnext(prob::XPRSprob)::Int32
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSiisnext")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), prob.handle, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSiisnext

"""
    XPRSiisstatus(prob, nrows, ncols, suminfeas, numinfeas)::niis, nrows, ncols, suminfeas, numinfeas

Returns statistics on the Irreducible Infeasible Sets (IIS) found so far by XPRSiisfirst (IIS), XPRSiisnext (IIS `-n`) or XPRSiisall (IIS `-a`).

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Number of rows in the IISs.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `ncols::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Number of bounds in the IISs.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `suminfeas::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: The sum of infeasibilities in the IISs after the first phase simplex.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `numinfeas::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: The number of infeasible variables in the IISs after the first phase simplex.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `niis::Int32`: The number of IISs found so far.
- `nrows::Union{Nothing,AbstractVector{Int32}}`: Number of rows in the IISs.
- `ncols::Union{Nothing,AbstractVector{Int32}}`: Number of bounds in the IISs.
- `suminfeas::Union{Nothing,AbstractVector{Float64}}`: The sum of infeasibilities in the IISs after the first phase simplex.
- `numinfeas::Union{Nothing,AbstractVector{Int32}}`: The number of infeasible variables in the IISs after the first phase simplex.

See also the documentation of the correponding function [XPRSiisstatus](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisstatus.html) in the C API.
"""
function XPRSiisstatus(prob::XPRSprob, nrows::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, ncols::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, suminfeas::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, numinfeas::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Int32}}}
  p_niis_dummy = Ref{Int32}(0)
  if isa(ncols, XPRSallocatable)
    ncols = Vector{Int32}(undef, 0)
  elseif ncols != nothing
    if length(ncols) < 0
      throw(XPRSexception("Argument ncols is too short, needs " * (0) * " elements but has only " * length(ncols), nothing))
    end
  end
  if isa(nrows, XPRSallocatable)
    nrows = Vector{Int32}(undef, 0)
  elseif nrows != nothing
    if length(nrows) < 0
      throw(XPRSexception("Argument nrows is too short, needs " * (0) * " elements but has only " * length(nrows), nothing))
    end
  end
  if isa(numinfeas, XPRSallocatable)
    numinfeas = Vector{Int32}(undef, 0)
  elseif numinfeas != nothing
    if length(numinfeas) < 0
      throw(XPRSexception("Argument numinfeas is too short, needs " * (0) * " elements but has only " * length(numinfeas), nothing))
    end
  end
  if isa(suminfeas, XPRSallocatable)
    suminfeas = Vector{Float64}(undef, 0)
  elseif suminfeas != nothing
    if length(suminfeas) < 0
      throw(XPRSexception("Argument suminfeas is too short, needs " * (0) * " elements but has only " * length(suminfeas), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSiisstatus")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cint}), prob.handle, p_niis_dummy, isnothing(nrows) ? C_NULL : nrows, isnothing(ncols) ? C_NULL : ncols, isnothing(suminfeas) ? C_NULL : suminfeas, isnothing(numinfeas) ? C_NULL : numinfeas)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_niis = p_niis_dummy[]
  p_niis, nrows, ncols, suminfeas, numinfeas
end
export XPRSiisstatus

"""
    XPRSiisall(prob)::prob

Performs an automated search for independent Irreducible Infeasible Sets (IIS) in an infeasible problem.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSiisall](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisall.html) in the C API.
"""
function XPRSiisall(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSiisall")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSiisall

"""
    XPRSiiswrite(prob, iis, filename, filetype, flags)::prob

Writes an LP/MPS/CSV file containing a given Irreducible Infeasible Set (IIS).

If 0 is passed as the IIS number parameter, the initial infeasible subproblem is written.

# Arguments
- `prob::XPRSprob`: The current problem.
- `iis::Integer`: The ordinal number of the IIS to be written.
- `filename::Union{Nothing,AbstractString}`: The name of the file to be created.
- `filetype::Integer`: Type of file to be created: 0creates an lp/mps file containing the IIS as a linear programming problem; 1creates a comma separated (csv) file containing the description and supplementary information on the given IIS.
- `flags::Union{Nothing,AbstractString}`: Flags passed to the XPRSwriteprob function.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSiiswrite](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiiswrite.html) in the C API.
"""
function XPRSiiswrite(prob::XPRSprob, iis, filename::Union{Nothing,AbstractString}, filetype, flags::Union{Nothing,AbstractString})::XPRSprob
  iisxx = Int32(iis)
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  filetypexx = Int32(filetype)
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSiiswrite")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring,Cint,Cstring), prob.handle, iisxx, filename_pass, filetypexx, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSiiswrite

"""
    XPRSiisisolations(prob, iis)::prob

Performs the isolation identification procedure for an Irreducible Infeasible Set (IIS).

This function applies only to linear problems.

# Arguments
- `prob::XPRSprob`: The current problem.
- `iis::Integer`: The number of the IIS identified by either XPRSiisfirst (IIS), XPRSiisnext (IIS `-n`) or XPRSiisall (IIS `-a`) in which the isolations should be identified.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSiisisolations](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSiisisolations.html) in the C API.
"""
function XPRSiisisolations(prob::XPRSprob, iis)::XPRSprob
  iisxx = Int32(iis)
  faddr = getFunctionAddress("XPRSiisisolations")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, iisxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSiisisolations

"""
    XPRSgetiisdata(prob, iis, rowind, colind, contype, bndtype, duals, djs, isolationrows, isolationcols)::nrows, ncols, rowind, colind, contype, bndtype, duals, djs, isolationrows, isolationcols

Returns information for an Irreducible Infeasible Set: size, variables and constraints (row and column vectors), and conflicting sides of the variables.

For pure linear problems there is also information on duals, reduced costs and isolations.

# Arguments
- `prob::XPRSprob`: The current problem.
- `iis::Integer`: The ordinal number of the IIS to get data for.
- `rowind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Indices of rows in the IIS.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Indices of bounds (columns) in the IIS.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `contype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Sense of rows in the IIS: Lfor less or equal row; Gfor greater or equal row.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `bndtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Sense of bound in the IIS: Ufor upper bound; Lfor lower bound.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: The dual multipliers associated with the rows.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: The dual multipliers (reduced costs) associated with the bounds.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `isolationrows::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: The isolation status of the rows: -1if isolation information is not available for row (run iis isolations); 0if row is not in isolation; 1if row is in isolation.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `isolationcols::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: The isolation status of the bounds: -1if isolation information is not available for column (run iis isolations); 0if column is not in isolation; 1if column is in isolation.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `nrows::Int32`: Pointer to an integer where the number of rows in the IIS will be returned.
- `ncols::Int32`: Pointer to an integer where the number of bounds in the IIS will be returned.
- `rowind::Union{Nothing,AbstractVector{Int32}}`: Indices of rows in the IIS.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Indices of bounds (columns) in the IIS.
- `contype::Union{Nothing,AbstractVector{Cchar}}`: Sense of rows in the IIS: Lfor less or equal row; Gfor greater or equal row.
- `bndtype::Union{Nothing,AbstractVector{Cchar}}`: Sense of bound in the IIS: Ufor upper bound; Lfor lower bound.
- `duals::Union{Nothing,AbstractVector{Float64}}`: The dual multipliers associated with the rows.
- `djs::Union{Nothing,AbstractVector{Float64}}`: The dual multipliers (reduced costs) associated with the bounds.
- `isolationrows::Union{Nothing,AbstractVector{Cchar}}`: The isolation status of the rows: -1if isolation information is not available for row (run iis isolations); 0if row is not in isolation; 1if row is in isolation.
- `isolationcols::Union{Nothing,AbstractVector{Cchar}}`: The isolation status of the bounds: -1if isolation information is not available for column (run iis isolations); 0if column is not in isolation; 1if column is in isolation.

See also the documentation of the correponding function [XPRSgetiisdata](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetiisdata.html) in the C API.
"""
function XPRSgetiisdata(prob::XPRSprob, iis, rowind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, contype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, bndtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, isolationrows::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, isolationcols::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}})::Tuple{Int32,Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Cchar}}}
  iisxx = Int32(iis)
  p_nrows_dummy = Ref{Int32}(0)
  p_ncols_dummy = Ref{Int32}(0)
  if isa(bndtype, XPRSallocatable)
    bndtype = Vector{Cchar}(undef, 0)
  elseif bndtype != nothing
    if length(bndtype) < 0
      throw(XPRSexception("Argument bndtype is too short, needs " * (0) * " elements but has only " * length(bndtype), nothing))
    end
  end
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, 0)
  elseif colind != nothing
    if length(colind) < 0
      throw(XPRSexception("Argument colind is too short, needs " * (0) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(contype, XPRSallocatable)
    contype = Vector{Cchar}(undef, 0)
  elseif contype != nothing
    if length(contype) < 0
      throw(XPRSexception("Argument contype is too short, needs " * (0) * " elements but has only " * length(contype), nothing))
    end
  end
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, 0)
  elseif djs != nothing
    if length(djs) < 0
      throw(XPRSexception("Argument djs is too short, needs " * (0) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, 0)
  elseif duals != nothing
    if length(duals) < 0
      throw(XPRSexception("Argument duals is too short, needs " * (0) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(isolationcols, XPRSallocatable)
    isolationcols = Vector{Cchar}(undef, 0)
  elseif isolationcols != nothing
    if length(isolationcols) < 0
      throw(XPRSexception("Argument isolationcols is too short, needs " * (0) * " elements but has only " * length(isolationcols), nothing))
    end
  end
  if isa(isolationrows, XPRSallocatable)
    isolationrows = Vector{Cchar}(undef, 0)
  elseif isolationrows != nothing
    if length(isolationrows) < 0
      throw(XPRSexception("Argument isolationrows is too short, needs " * (0) * " elements but has only " * length(isolationrows), nothing))
    end
  end
  if isa(rowind, XPRSallocatable)
    rowind = Vector{Int32}(undef, 0)
  elseif rowind != nothing
    if length(rowind) < 0
      throw(XPRSexception("Argument rowind is too short, needs " * (0) * " elements but has only " * length(rowind), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetiisdata")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint},Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cchar},Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cchar},Ptr{Cchar}), prob.handle, iisxx, p_nrows_dummy, p_ncols_dummy, isnothing(rowind) ? C_NULL : rowind, isnothing(colind) ? C_NULL : colind, isnothing(contype) ? C_NULL : contype, isnothing(bndtype) ? C_NULL : bndtype, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs, isnothing(isolationrows) ? C_NULL : isolationrows, isnothing(isolationcols) ? C_NULL : isolationcols)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nrows = p_nrows_dummy[]
  p_ncols = p_ncols_dummy[]
  p_nrows, p_ncols, rowind, colind, contype, bndtype, duals, djs, isolationrows, isolationcols
end
export XPRSgetiisdata

"""
    XPRSloadpresolvebasis(prob, rowstat, colstat)::prob

Loads a presolved basis from the user's areas.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowstat::AbstractVector{Integer}`: Integer array of length ROWS containing the basis status of the slack, surplus or artificial variable associated with each row.
- `colstat::AbstractVector{Integer}`: Integer array of length COLS containing the basis status of each of the columns in the matrix.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadpresolvebasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadpresolvebasis.html) in the C API.
"""
function XPRSloadpresolvebasis(prob::XPRSprob, rowstat, colstat)::XPRSprob
  if isnothing(rowstat) || length(rowstat) == 0
    c_rowstat = nothing
  elseif isa(rowstat, AbstractVector{Int32})
    c_rowstat = rowstat
  else
    c_rowstat = convert(Vector{Int32}, rowstat)
  end
  if isnothing(colstat) || length(colstat) == 0
    c_colstat = nothing
  elseif isa(colstat, AbstractVector{Int32})
    c_colstat = colstat
  else
    c_colstat = convert(Vector{Int32}, colstat)
  end
  faddr = getFunctionAddress("XPRSloadpresolvebasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(c_rowstat) ? C_NULL : c_rowstat, isnothing(c_colstat) ? C_NULL : c_colstat)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadpresolvebasis

"""
    XPRSgetmipentities(prob, coltype, colind, limit, settype, start, setcols, refval)::nentities, nsets, coltype, colind, limit, settype, start, setcols, refval

Retrieves integr and entity information about a problem.

It must be called before XPRSmipoptimize if the presolve option is used.

# Arguments
- `prob::XPRSprob`: The current problem.
- `coltype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `nentities` where the entity types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nentities` where the column indices of the MIP entities will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `limit::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `nentities` where the limits for the partial integer variables and lower bounds for the semi-continuous and semi-continuous integer variables will be returned (any entries in the positions corresponding to binary and integer variables will be meaningless).
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `settype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `nsets` where the set types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::AbstractVector{Int32}`: Integer array where the offsets into the `setcols` and `refval` arrays indicating the start of the sets will be returned.
- `setcols::AbstractVector{Int32}`: Integer array of length `SETMEMBERS` where the columns in each set will be returned.
- `refval::AbstractVector{Float64}`: Double array of length `SETMEMBERS` where the reference row entries for each member of the sets will be returned.
# Return values
- `nentities::Int32`: Pointer to the integer where the number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities will be returned.
- `nsets::Int32`: Pointer to the integer where the number of SOS1 and SOS2 sets will be returned.
- `coltype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `nentities` where the entity types will be returned.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nentities` where the column indices of the MIP entities will be returned.
- `limit::Union{Nothing,AbstractVector{Float64}}`: Double array of length `nentities` where the limits for the partial integer variables and lower bounds for the semi-continuous and semi-continuous integer variables will be returned (any entries in the positions corresponding to binary and integer variables will be meaningless).
- `settype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `nsets` where the set types will be returned.
- `start::AbstractVector{Int32}`: Integer array where the offsets into the `setcols` and `refval` arrays indicating the start of the sets will be returned.
- `setcols::AbstractVector{Int32}`: Integer array of length `SETMEMBERS` where the columns in each set will be returned.
- `refval::AbstractVector{Float64}`: Double array of length `SETMEMBERS` where the reference row entries for each member of the sets will be returned.

See also the documentation of the correponding function [XPRSgetmipentities](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmipentities.html) in the C API.
"""
function XPRSgetmipentities(prob::XPRSprob, coltype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, limit::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, settype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, start::AbstractVector{Int32}, setcols::AbstractVector{Int32}, refval::AbstractVector{Float64})::Tuple{Int32,Int32,Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Cchar}},AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64}}
  p_nentities_dummy = Ref{Int32}(0)
  p_nsets_dummy = Ref{Int32}(0)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif colind != nothing
    if length(colind) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument colind is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(coltype, XPRSallocatable)
    coltype = Vector{Cchar}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif coltype != nothing
    if length(coltype) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument coltype is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(coltype), nothing))
    end
  end
  if isa(limit, XPRSallocatable)
    limit = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif limit != nothing
    if length(limit) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument limit is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(limit), nothing))
    end
  end
  if isa(settype, XPRSallocatable)
    settype = Vector{Cchar}(undef, XPRSgetintattrib(prob, XPRS_SETS))
  elseif settype != nothing
    if length(settype) < XPRSgetintattrib(prob, XPRS_SETS)
      throw(XPRSexception("Argument settype is too short, needs " * (XPRSgetintattrib(prob, XPRS_SETS)) * " elements but has only " * length(settype), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetmipentities")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ref{Cint},Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, p_nentities_dummy, p_nsets_dummy, isnothing(coltype) ? C_NULL : coltype, isnothing(colind) ? C_NULL : colind, isnothing(limit) ? C_NULL : limit, isnothing(settype) ? C_NULL : settype, isnothing(start) ? C_NULL : start, isnothing(setcols) ? C_NULL : setcols, isnothing(refval) ? C_NULL : refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nentities = p_nentities_dummy[]
  p_nsets = p_nsets_dummy[]
  p_nentities, p_nsets, coltype, colind, limit, settype, start, setcols, refval
end
export XPRSgetmipentities

"""
    XPRSgetmipentities64(prob, coltype, colind, limit, settype, start, setcols, refval)::nentities, nsets, coltype, colind, limit, settype, start, setcols, refval

Retrieves integr and entity information about a problem.

It must be called before XPRSmipoptimize if the presolve option is used.

# Arguments
- `prob::XPRSprob`: The current problem.
- `coltype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `nentities` where the entity types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `nentities` where the column indices of the MIP entities will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `limit::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `nentities` where the limits for the partial integer variables and lower bounds for the semi-continuous and semi-continuous integer variables will be returned (any entries in the positions corresponding to binary and integer variables will be meaningless).
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `settype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `nsets` where the set types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::AbstractVector{Int64}`: Integer array where the offsets into the `setcols` and `refval` arrays indicating the start of the sets will be returned.
- `setcols::AbstractVector{Int32}`: Integer array of length `SETMEMBERS` where the columns in each set will be returned.
- `refval::AbstractVector{Float64}`: Double array of length `SETMEMBERS` where the reference row entries for each member of the sets will be returned.
# Return values
- `nentities::Int32`: Pointer to the integer where the number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities will be returned.
- `nsets::Int32`: Pointer to the integer where the number of SOS1 and SOS2 sets will be returned.
- `coltype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `nentities` where the entity types will be returned.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `nentities` where the column indices of the MIP entities will be returned.
- `limit::Union{Nothing,AbstractVector{Float64}}`: Double array of length `nentities` where the limits for the partial integer variables and lower bounds for the semi-continuous and semi-continuous integer variables will be returned (any entries in the positions corresponding to binary and integer variables will be meaningless).
- `settype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `nsets` where the set types will be returned.
- `start::AbstractVector{Int64}`: Integer array where the offsets into the `setcols` and `refval` arrays indicating the start of the sets will be returned.
- `setcols::AbstractVector{Int32}`: Integer array of length `SETMEMBERS` where the columns in each set will be returned.
- `refval::AbstractVector{Float64}`: Double array of length `SETMEMBERS` where the reference row entries for each member of the sets will be returned.

See also the documentation of the correponding function [XPRSgetmipentities64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmipentities64.html) in the C API.
"""
function XPRSgetmipentities64(prob::XPRSprob, coltype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, limit::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, settype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, start::AbstractVector{Int64}, setcols::AbstractVector{Int32}, refval::AbstractVector{Float64})::Tuple{Int32,Int32,Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Cchar}},AbstractVector{Int64},AbstractVector{Int32},AbstractVector{Float64}}
  p_nentities_dummy = Ref{Int32}(0)
  p_nsets_dummy = Ref{Int32}(0)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif colind != nothing
    if length(colind) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument colind is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(coltype, XPRSallocatable)
    coltype = Vector{Cchar}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif coltype != nothing
    if length(coltype) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument coltype is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(coltype), nothing))
    end
  end
  if isa(limit, XPRSallocatable)
    limit = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_MIPENTS))
  elseif limit != nothing
    if length(limit) < XPRSgetintattrib(prob, XPRS_MIPENTS)
      throw(XPRSexception("Argument limit is too short, needs " * (XPRSgetintattrib(prob, XPRS_MIPENTS)) * " elements but has only " * length(limit), nothing))
    end
  end
  if isa(settype, XPRSallocatable)
    settype = Vector{Cchar}(undef, XPRSgetintattrib(prob, XPRS_SETS))
  elseif settype != nothing
    if length(settype) < XPRSgetintattrib(prob, XPRS_SETS)
      throw(XPRSexception("Argument settype is too short, needs " * (XPRSgetintattrib(prob, XPRS_SETS)) * " elements but has only " * length(settype), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetmipentities64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ref{Cint},Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, p_nentities_dummy, p_nsets_dummy, isnothing(coltype) ? C_NULL : coltype, isnothing(colind) ? C_NULL : colind, isnothing(limit) ? C_NULL : limit, isnothing(settype) ? C_NULL : settype, isnothing(start) ? C_NULL : start, isnothing(setcols) ? C_NULL : setcols, isnothing(refval) ? C_NULL : refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nentities = p_nentities_dummy[]
  p_nsets = p_nsets_dummy[]
  p_nentities, p_nsets, coltype, colind, limit, settype, start, setcols, refval
end
export XPRSgetmipentities64

"""
    XPRSloadsecurevecs(prob, nrows, ncols, rowind, colind)::prob

Allows the user to mark rows and columns in order to prevent the presolve removing these rows and columns from the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of rows to be marked.
- `ncols::Integer`: Number of columns to be marked.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the rows to be marked.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the columns to be marked.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadsecurevecs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadsecurevecs.html) in the C API.
"""
function XPRSloadsecurevecs(prob::XPRSprob, nrows, ncols, rowind, colind)::XPRSprob
  nrowsxx = Int32(nrows)
  ncolsxx = Int32(ncols)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  faddr = getFunctionAddress("XPRSloadsecurevecs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cint}), prob.handle, nrowsxx, ncolsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadsecurevecs

"""
    XPRSaddrows(prob, nrows, ncoefs, rowtype, rhs, rng, start, colind, rowcoef)::prob

Adds rows to the optimizer matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of new rows.
- `ncoefs::Integer`: Number of new nonzeros in the added rows.
- `rowtype::AbstractVector{Cchar}`: Character array of length nrows containing the row types: Lindicates a `<=` row; Gindicates `>=` row; Eindicates an = row.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side elements.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the row range elements.
- `start::AbstractVector{Integer}`: Integer array of length `nrows` containing the offsets in the `colind` and `rowcoef` arrays of the start of the elements for each row.
- `colind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the (contiguous) column indices for the elements in each row.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the (contiguous) element values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddrows.html) in the C API.
"""
function XPRSaddrows(prob::XPRSprob, nrows, ncoefs, rowtype, rhs, rng, start, colind, rowcoef)::XPRSprob
  nrowsxx = Int32(nrows)
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  faddr = getFunctionAddress("XPRSaddrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, nrowsxx, ncoefsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddrows

"""
    XPRSaddrows64(prob, nrows, ncoefs, rowtype, rhs, rng, start, colind, rowcoef)::prob

Adds rows to the optimizer matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of new rows.
- `ncoefs::Integer`: Number of new nonzeros in the added rows.
- `rowtype::AbstractVector{Cchar}`: Character array of length nrows containing the row types: Lindicates a `<=` row; Gindicates `>=` row; Eindicates an = row.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side elements.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the row range elements.
- `start::AbstractVector{Integer}`: Integer array of length `nrows` containing the offsets in the `colind` and `rowcoef` arrays of the start of the elements for each row.
- `colind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the (contiguous) column indices for the elements in each row.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the (contiguous) element values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddrows64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddrows64.html) in the C API.
"""
function XPRSaddrows64(prob::XPRSprob, nrows, ncoefs, rowtype, rhs, rng, start, colind, rowcoef)::XPRSprob
  nrowsxx = Int32(nrows)
  ncoefsxx = Int64(ncoefs)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  faddr = getFunctionAddress("XPRSaddrows64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, nrowsxx, ncoefsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddrows64

"""
    XPRSdelrows(prob, nrows, rowind)::prob

Delete rows from a matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of rows to delete.
- `rowind::AbstractVector{Integer}`: An integer array of length `nrows` containing the rows to delete.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelrows.html) in the C API.
"""
function XPRSdelrows(prob::XPRSprob, nrows, rowind)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSdelrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelrows

"""
    XPRSaddcols(prob, ncols, ncoefs, objcoef, start, rowind, rowcoef, lb, ub)::prob

Adds columns to the optimizer matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of new columns.
- `ncoefs::Integer`: Number of new nonzeros in the added columns.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients of the new columns.
- `start::AbstractVector{Integer}`: Integer array of length `ncols` containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `rowind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the row indices for the elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the element values.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the added columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the added columns.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddcols](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddcols.html) in the C API.
"""
function XPRSaddcols(prob::XPRSprob, ncols, ncoefs, objcoef, start, rowind, rowcoef, lb, ub)::XPRSprob
  ncolsxx = Int32(ncols)
  ncoefsxx = Int32(ncoefs)
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  faddr = getFunctionAddress("XPRSaddcols")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ncolsxx, ncoefsxx, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddcols

"""
    XPRSaddcols64(prob, ncols, ncoefs, objcoef, start, rowind, rowcoef, lb, ub)::prob

Adds columns to the optimizer matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of new columns.
- `ncoefs::Integer`: Number of new nonzeros in the added columns.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients of the new columns.
- `start::AbstractVector{Integer}`: Integer array of length `ncols` containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `rowind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the row indices for the elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the element values.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the added columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the added columns.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddcols64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddcols64.html) in the C API.
"""
function XPRSaddcols64(prob::XPRSprob, ncols, ncoefs, objcoef, start, rowind, rowcoef, lb, ub)::XPRSprob
  ncolsxx = Int32(ncols)
  ncoefsxx = Int64(ncoefs)
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  faddr = getFunctionAddress("XPRSaddcols64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ncolsxx, ncoefsxx, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddcols64

"""
    XPRSdelcols(prob, ncols, colind)::prob

Delete columns from a matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of columns to delete.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the columns to delete.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelcols](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelcols.html) in the C API.
"""
function XPRSdelcols(prob::XPRSprob, ncols, colind)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  faddr = getFunctionAddress("XPRSdelcols")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelcols

"""
    XPRSchgcoltype(prob, ncols, colind, coltype)::prob

Used to change the type of a specified set of columns in the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of columns to change.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns.
- `coltype::AbstractVector{Cchar}`: Character array of length `ncols` giving the new column types: Cindicates a continuous column; Bindicates a binary column; Iindicates an integer column.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgcoltype](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgcoltype.html) in the C API.
"""
function XPRSchgcoltype(prob::XPRSprob, ncols, colind, coltype)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  faddr = getFunctionAddress("XPRSchgcoltype")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_coltype) ? C_NULL : c_coltype)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgcoltype

"""
    XPRSloadbasis(prob, rowstat, colstat)::prob

Loads a basis from the user's areas.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowstat::AbstractVector{Integer}`: Integer array of length ROWS containing the basis status of the slack, surplus or artificial variable associated with each row.
- `colstat::AbstractVector{Integer}`: Integer array of length COLS containing the basis status of each of the columns in the constraint matrix.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadbasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadbasis.html) in the C API.
"""
function XPRSloadbasis(prob::XPRSprob, rowstat, colstat)::XPRSprob
  if isnothing(rowstat) || length(rowstat) == 0
    c_rowstat = nothing
  elseif isa(rowstat, AbstractVector{Int32})
    c_rowstat = rowstat
  else
    c_rowstat = convert(Vector{Int32}, rowstat)
  end
  if isnothing(colstat) || length(colstat) == 0
    c_colstat = nothing
  elseif isa(colstat, AbstractVector{Int32})
    c_colstat = colstat
  else
    c_colstat = convert(Vector{Int32}, colstat)
  end
  faddr = getFunctionAddress("XPRSloadbasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(c_rowstat) ? C_NULL : c_rowstat, isnothing(c_colstat) ? C_NULL : c_colstat)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadbasis

"""
    XPRSpostsolve(prob)::prob

Postsolve the current matrix when it is in a presolved state.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSpostsolve](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSpostsolve.html) in the C API.
"""
function XPRSpostsolve(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSpostsolve")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSpostsolve

"""
    XPRSdelsets(prob, nsets, setind)::prob

Delete sets from a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nsets::Integer`: Number of sets to delete.
- `setind::AbstractVector{Integer}`: An integer array of length `nsets` containing the sets to delete.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelsets](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelsets.html) in the C API.
"""
function XPRSdelsets(prob::XPRSprob, nsets, setind)::XPRSprob
  nsetsxx = Int32(nsets)
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  faddr = getFunctionAddress("XPRSdelsets")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nsetsxx, isnothing(c_setind) ? C_NULL : c_setind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelsets

"""
    XPRSaddsets(prob, nsets, nelems, settype, start, colind, refval)::prob

Allows sets to be added to the problem after passing it to the Optimizer using the input routines.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nsets::Integer`: Number of new sets.
- `nelems::Integer`: Number of new nonzeros in the added sets.
- `settype::AbstractVector{Cchar}`: Character array of length nsets containing the set types: 1indicates a SOS1; 2indicates a SOS2;
- `start::AbstractVector{Integer}`: Integer array of length `nsets` containing the offsets in the `colind` and `refval` arrays of the start of the elements for each set.
- `colind::AbstractVector{Integer}`: Integer array of length `nelems` containing the (contiguous) column indices for the elements in each set.
- `refval::AbstractVector{Number}`: Double array of length `nelems` containing the (contiguous) reference values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddsets](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddsets.html) in the C API.
"""
function XPRSaddsets(prob::XPRSprob, nsets, nelems, settype, start, colind, refval)::XPRSprob
  nsetsxx = Int32(nsets)
  nelemsxx = Int32(nelems)
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSaddsets")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, nsetsxx, nelemsxx, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddsets

"""
    XPRSaddsets64(prob, nsets, nelems, settype, start, colind, refval)::prob

Allows sets to be added to the problem after passing it to the Optimizer using the input routines.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nsets::Integer`: Number of new sets.
- `nelems::Integer`: Number of new nonzeros in the added sets.
- `settype::AbstractVector{Cchar}`: Character array of length nsets containing the set types: 1indicates a SOS1; 2indicates a SOS2;
- `start::AbstractVector{Integer}`: Integer array of length `nsets` containing the offsets in the `colind` and `refval` arrays of the start of the elements for each set.
- `colind::AbstractVector{Integer}`: Integer array of length `nelems` containing the (contiguous) column indices for the elements in each set.
- `refval::AbstractVector{Number}`: Double array of length `nelems` containing the (contiguous) reference values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddsets64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddsets64.html) in the C API.
"""
function XPRSaddsets64(prob::XPRSprob, nsets, nelems, settype, start, colind, refval)::XPRSprob
  nsetsxx = Int32(nsets)
  nelemsxx = Int64(nelems)
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSaddsets64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, nsetsxx, nelemsxx, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddsets64

"""
    XPRSstrongbranch(prob, nbounds, colind, bndtype, bndval, iterlim, objval, status)::objval, status

Performs strong branching iterations on all specified bound changes.

For each candidate bound change, `XPRSstrongbranch` performs dual simplex iterations starting from the current optimal solution of the base LP, and returns both the status and objective value reached after these iterations.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nbounds::Integer`: Number of bound changes to try.
- `colind::AbstractVector{Integer}`: Integer array of size `nbounds` containing the indices of the columns on which the bounds will change.
- `bndtype::AbstractVector{Cchar}`: Character array of length `nbounds` indicating the type of bound to change: Uindicates change the upper bound; Lindicates change the lower bound; Bindicates change both bounds, i.e. fix the column.
- `bndval::AbstractVector{Number}`: Double array of length `nbounds` giving the new bound values.
- `iterlim::Integer`: Maximum number of LP iterations to perform for each bound change.
- `objval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Objective value of each LP after performing the strong branching iterations.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `status::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Status of each LP after performing the strong branching iterations, as detailed for the LPSTATUS attribute.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `objval::Union{Nothing,AbstractVector{Float64}}`: Objective value of each LP after performing the strong branching iterations.
- `status::Union{Nothing,AbstractVector{Int32}}`: Status of each LP after performing the strong branching iterations, as detailed for the LPSTATUS attribute.

See also the documentation of the correponding function [XPRSstrongbranch](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSstrongbranch.html) in the C API.
"""
function XPRSstrongbranch(prob::XPRSprob, nbounds, colind, bndtype, bndval, iterlim, objval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, status::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Int32}}}
  nboundsxx = Int32(nbounds)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(bndtype) || length(bndtype) == 0
    c_bndtype = nothing
  elseif isa(bndtype, AbstractVector{Cchar})
    c_bndtype = bndtype
  else
    c_bndtype = convert(Vector{Cchar}, bndtype)
  end
  if isnothing(bndval) || length(bndval) == 0
    c_bndval = nothing
  elseif isa(bndval, AbstractVector{Float64})
    c_bndval = bndval
  else
    c_bndval = convert(Vector{Float64}, bndval)
  end
  iterlimxx = Int32(iterlim)
  faddr = getFunctionAddress("XPRSstrongbranch")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Cint,Ptr{Cdouble},Ptr{Cint}), prob.handle, nboundsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_bndtype) ? C_NULL : c_bndtype, isnothing(c_bndval) ? C_NULL : c_bndval, iterlimxx, isnothing(objval) ? C_NULL : objval, isnothing(status) ? C_NULL : status)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  objval, status
end
export XPRSstrongbranch

"""
    XPRSestimaterowdualranges(prob, nrows, rowind, iterlim, mindual, maxdual)::mindual, maxdual

Performs a dual side range sensitivity analysis, i.e. calculates estimates for the possible ranges for dual values.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: The number of rows to analyze.
- `rowind::AbstractVector{Integer}`: Row indices to analyze.
- `iterlim::Integer`: Effort limit expressed as simplex iterations per row.
- `mindual::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Estimated lower bounds on the possible dual ranges.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxdual::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Estimated upper bounds on the possible dual ranges.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `mindual::Union{Nothing,AbstractVector{Float64}}`: Estimated lower bounds on the possible dual ranges.
- `maxdual::Union{Nothing,AbstractVector{Float64}}`: Estimated upper bounds on the possible dual ranges.

See also the documentation of the correponding function [XPRSestimaterowdualranges](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSestimaterowdualranges.html) in the C API.
"""
function XPRSestimaterowdualranges(prob::XPRSprob, nrows, rowind, iterlim, mindual::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxdual::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  iterlimxx = Int32(iterlim)
  faddr = getFunctionAddress("XPRSestimaterowdualranges")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Cint,Ptr{Cdouble},Ptr{Cdouble}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, iterlimxx, isnothing(mindual) ? C_NULL : mindual, isnothing(maxdual) ? C_NULL : maxdual)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  mindual, maxdual
end
export XPRSestimaterowdualranges

"""
    XPRSsetmessagestatus(prob, msgcode, status)::prob

Manages suppression of messages.

# Arguments
- `prob::XPRSprob`: The problem for which message `msgcode` is to have its suppression status changed; pass `nothing` if the message should have the status apply globally to all problems.
- `msgcode::Integer`: The id number of the message.
- `status::Integer`: Non-zero if the message is not suppressed; `0` otherwise. If a value for `status` is not supplied in the command-line call then the console Optimizer prints the value of the suppression status to screen i.e., non-zero if the message is not suppressed; `0` otherwise.
# Return value
- `prob::XPRSprob`: The problem for which message `msgcode` is to have its suppression status changed; pass `nothing` if the message should have the status apply globally to all problems.

See also the documentation of the correponding function [XPRSsetmessagestatus](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetmessagestatus.html) in the C API.
"""
function XPRSsetmessagestatus(prob::XPRSprob, msgcode, status)::XPRSprob
  msgcodexx = Int32(msgcode)
  statusxx = Int32(status)
  faddr = getFunctionAddress("XPRSsetmessagestatus")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint), prob.handle, msgcodexx, statusxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetmessagestatus

"""
    XPRSgetmessagestatus(prob, msgcode)::status

Retrieves the current suppression status of a message.

# Arguments
- `prob::XPRSprob`: The problem to check for the suppression status of the message error code.
- `msgcode::Integer`: The id number of the message.
# Return value
- `status::Int32`: Non-zero if the message is not suppressed; `0` otherwise.

See also the documentation of the correponding function [XPRSgetmessagestatus](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmessagestatus.html) in the C API.
"""
function XPRSgetmessagestatus(prob::XPRSprob, msgcode)::Int32
  msgcodexx = Int32(msgcode)
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetmessagestatus")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, msgcodexx, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSgetmessagestatus

"""
    XPRSchgobjsense(prob, objsense)::prob

Changes the problem's objective function sense to minimize or maximize.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objsense::XPRSObjSense`: `XPRS_OBJ_MINIMIZE` to change into a minimization, or `XPRS_OBJ_MAXIMIZE` to change into maximization problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgobjsense](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgobjsense.html) in the C API.
"""
function XPRSchgobjsense(prob::XPRSprob, objsense)::XPRSprob
  faddr = getFunctionAddress("XPRSchgobjsense")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, Int32(objsense))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgobjsense

"""
    XPRSchgglblimit(prob, ncols, colind, limit)::prob

Used to change semi-continuous or semi-integer lower bounds, or upper limits on partial integers.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of column limits to change.
- `colind::AbstractVector{Integer}`: Integer array of size `ncols` containing the indices of the semi-continuous, semi-integer or partial integer columns that should have their limits changed.
- `limit::AbstractVector{Number}`: Double array of length `ncols` giving the new limit values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgglblimit](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgglblimit.html) in the C API.
"""
function XPRSchgglblimit(prob::XPRSprob, ncols, colind, limit)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  faddr = getFunctionAddress("XPRSchgglblimit")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_limit) ? C_NULL : c_limit)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end

"""
    XPRSchgglblimit(prob, vec)

Implementation of `XPRSchgglblimit` that combines arguments `ncols`, `colind`, `limit`
into a single argument `vec`. Note that the indices in `vec` must be specified
as 0-based indices.
"""
function XPRSchgglblimit(prob::XPRSprob, vec::AbstractSparseArray{Float64,Int32,1})::Nothing
  XPRSchgglblimit(prob, vec.n, vec.nzind, vec.nzval)
end

export XPRSchgglblimit

"""
    XPRSsave(prob)::prob

Saves the current data structures, i.e. matrices, control settings and problem attribute settings to file and terminates the run so that optimization can be resumed later.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsave](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsave.html) in the C API.
"""
function XPRSsave(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSsave")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsave

"""
    XPRSsaveas(prob, sSaveFileName)::prob

Saves the current data structures, i.e. matrices, control settings and problem attribute settings to file and terminates the run so that optimization can be resumed later.

# Arguments
- `prob::XPRSprob`: The current problem.
- `sSaveFileName::Union{Nothing,AbstractString}`: The name of the file (without .svf) to save to.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsaveas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsaveas.html) in the C API.
"""
function XPRSsaveas(prob::XPRSprob, sSaveFileName::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(sSaveFileName)
    sSaveFileName_pass = C_NULL
  else
    sSaveFileName_pass = sSaveFileName
  end
  faddr = getFunctionAddress("XPRSsaveas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, sSaveFileName_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsaveas

"""
    XPRSrestore(prob, probname, flags)::prob

Restores the Optimizer's data structures from a file created by XPRSsave (SAVE).

Optimization may then recommence from the point at which the file was created.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the problem name.
- `flags::Union{Nothing,AbstractString}`: Additional flags force (no effect, kept for compatibility); hDo not restore hardware information from the file; vuse the provided filename verbatim, without appending the `.svf` extension.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSrestore](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrestore.html) in the C API.
"""
function XPRSrestore(prob::XPRSprob, probname::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSrestore")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, probname_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSrestore

"""
    XPRSpivot(prob, enter, leave)::prob

Performs a simplex pivot by bringing variable `enter` into the basis and removing `leave`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `enter::Integer`: Index of row or column to enter basis.
- `leave::Integer`: Index of row or column to leave basis.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSpivot](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSpivot.html) in the C API.
"""
function XPRSpivot(prob::XPRSprob, enter, leave)::XPRSprob
  enterxx = Int32(enter)
  leavexx = Int32(leave)
  faddr = getFunctionAddress("XPRSpivot")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint), prob.handle, enterxx, leavexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSpivot

"""
    XPRSloadlpsol(prob, x, slack, duals, djs)::status

Loads an LP solution for the problem into the Optimizer.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::AbstractVector{Number}`: Optional: Double array of length COLS (for the original problem and not the presolve problem) containing the values of the variables.
- `slack::AbstractVector{Number}`: Optional: double array of length ROWS containing the values of slack variables.
- `duals::AbstractVector{Number}`: Optional: double array of length ROWS containing the values of dual variables.
- `djs::AbstractVector{Number}`: Optional: double array of length COLS containing the values of reduced costs.
# Return value
- `status::Int32`: Pointer to an `int` where the status will be returned.

See also the documentation of the correponding function [XPRSloadlpsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadlpsol.html) in the C API.
"""
function XPRSloadlpsol(prob::XPRSprob, x, slack, duals, djs)::Int32
  if isnothing(x) || length(x) == 0
    c_x = nothing
  elseif isa(x, AbstractVector{Float64})
    c_x = x
  else
    c_x = convert(Vector{Float64}, x)
  end
  if isnothing(slack) || length(slack) == 0
    c_slack = nothing
  elseif isa(slack, AbstractVector{Float64})
    c_slack = slack
  else
    c_slack = convert(Vector{Float64}, slack)
  end
  if isnothing(duals) || length(duals) == 0
    c_duals = nothing
  elseif isa(duals, AbstractVector{Float64})
    c_duals = duals
  else
    c_duals = convert(Vector{Float64}, duals)
  end
  if isnothing(djs) || length(djs) == 0
    c_djs = nothing
  elseif isa(djs, AbstractVector{Float64})
    c_djs = djs
  else
    c_djs = convert(Vector{Float64}, djs)
  end
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSloadlpsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ref{Cint}), prob.handle, isnothing(c_x) ? C_NULL : c_x, isnothing(c_slack) ? C_NULL : c_slack, isnothing(c_duals) ? C_NULL : c_duals, isnothing(c_djs) ? C_NULL : c_djs, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSloadlpsol

"""
    XPRSbasiscondition(prob)::cond, scaledcond

**Deprecated**Please use the XPRSbasisstability function instead.

Calculates the condition number of the current basis after solving the LP relaxation.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return values
- `cond::Float64`: The returned condition number of the current basis.
- `scaledcond::Float64`: The returned condition number of the current basis for the scaled problem.

See also the documentation of the correponding function [XPRSbasiscondition](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSbasiscondition.html) in the C API.
"""
function XPRSbasiscondition(prob::XPRSprob)::Tuple{Float64,Float64}
  p_cond_dummy = Ref{Float64}(0)
  p_scaledcond_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSbasiscondition")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cdouble},Ref{Cdouble}), prob.handle, p_cond_dummy, p_scaledcond_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_cond = p_cond_dummy[]
  p_scaledcond = p_scaledcond_dummy[]
  p_cond, p_scaledcond
end
export XPRSbasiscondition

"""
    XPRSrepairweightedinfeas(prob, lepref, gepref, lbpref, ubpref, phase2, delta, flags)::status

By relaxing a set of selected constraints and bounds of an infeasible problem, it attempts to identify a 'solution' that violates the selected set of constraints and bounds minimally, while satisfying all other constraints and bounds.

Among such solution candidates, it selects one that is optimal regarding the original objective function. For the console version, see REPAIRINFEAS.

# Arguments
- `prob::XPRSprob`: The current problem.
- `lepref::AbstractVector{Number}`: Array of size `ROWS` containing the preferences for relaxing the less or equal side of row.
- `gepref::AbstractVector{Number}`: Array of size `ROWS` containing the preferences for relaxing the greater or equal side of a row.
- `lbpref::AbstractVector{Number}`: Array of size `COLS` containing the preferences for relaxing lower bounds.
- `ubpref::AbstractVector{Number}`: Array of size `COLS` containing preferences for relaxing upper bounds.
- `phase2::Integer`: Controls the second phase of optimization: ouse the objective sense of the original problem (default); xmaximize the relaxed problem using the original objective; fskip optimization regarding the original objective; nminimize the relaxed problem using the original objective; iif the relaxation is infeasible, generate an irreducible infeasible subset for the analys of the problem; aif the relaxation is infeasible, generate all irreducible infeasible subsets for the analys of the problem.
- `delta::Float64`: The relaxation multiplier in the second phase -1.
- `flags::Union{Nothing,AbstractString}`: Specifies flags to be passed to the Optimizer.
# Return value
- `status::Int32`: The status after the relaxation: 1relaxed problem is infeasible; 2relaxed problem is unbounded; 3solution of the relaxed problem regarding the original objective is nonoptimal; 4error (when return code is nonzero); 5numerical instability; 6analysis of an infeasible relaxation was performed, but the relaxation is feasible.

See also the documentation of the correponding function [XPRSrepairweightedinfeas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrepairweightedinfeas.html) in the C API.
"""
function XPRSrepairweightedinfeas(prob::XPRSprob, lepref, gepref, lbpref, ubpref, phase2, delta, flags::Union{Nothing,AbstractString})::Int32
  p_status_dummy = Ref{Int32}(0)
  if isnothing(lepref) || length(lepref) == 0
    c_lepref = nothing
  elseif isa(lepref, AbstractVector{Float64})
    c_lepref = lepref
  else
    c_lepref = convert(Vector{Float64}, lepref)
  end
  if isnothing(gepref) || length(gepref) == 0
    c_gepref = nothing
  elseif isa(gepref, AbstractVector{Float64})
    c_gepref = gepref
  else
    c_gepref = convert(Vector{Float64}, gepref)
  end
  if isnothing(lbpref) || length(lbpref) == 0
    c_lbpref = nothing
  elseif isa(lbpref, AbstractVector{Float64})
    c_lbpref = lbpref
  else
    c_lbpref = convert(Vector{Float64}, lbpref)
  end
  if isnothing(ubpref) || length(ubpref) == 0
    c_ubpref = nothing
  elseif isa(ubpref, AbstractVector{Float64})
    c_ubpref = ubpref
  else
    c_ubpref = convert(Vector{Float64}, ubpref)
  end
  phase2xx = Cchar(phase2)
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSrepairweightedinfeas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cchar,Cdouble,Cstring), prob.handle, p_status_dummy, isnothing(c_lepref) ? C_NULL : c_lepref, isnothing(c_gepref) ? C_NULL : c_gepref, isnothing(c_lbpref) ? C_NULL : c_lbpref, isnothing(c_ubpref) ? C_NULL : c_ubpref, phase2xx, Float64(delta), flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSrepairweightedinfeas

"""
    XPRSrepairweightedinfeasbounds(prob, lepref, gepref, lbpref, ubpref, lerelax, gerelax, lbrelax, ubrelax, phase2, delta, flags)::status

An extended version of XPRSrepairweightedinfeas that allows for bounding the level of relaxation allowed.

# Arguments
- `prob::XPRSprob`: The current problem.
- `lepref::AbstractVector{Number}`: Array of size `ROWS` containing the preferences for relaxing the less or equal side of row.
- `gepref::AbstractVector{Number}`: Array of size `ROWS` containing the preferences for relaxing the greater or equal side of a row.
- `lbpref::AbstractVector{Number}`: Array of size `COLS` containing the preferences for relaxing lower bounds.
- `ubpref::AbstractVector{Number}`: Array of size `COLS` containing preferences for relaxing upper bounds.
- `lerelax::AbstractVector{Number}`: Array of size `ROWS` containing the upper bounds on the amount the less or equal side of a row can be relaxed.
- `gerelax::AbstractVector{Number}`: Array of size `ROWS` containing the upper bounds on the amount the greater or equal side of a row can be relaxed.
- `lbrelax::AbstractVector{Number}`: Array of size `COLS` containing the upper bounds on the amount the lower bounds can be relaxed.
- `ubrelax::AbstractVector{Number}`: Array of size `COLS` containing the upper bounds on the amount the upper bounds can be relaxed.
- `phase2::Integer`: Controls the second phase of optimization: ouse the objective sense of the original problem (default); xmaximize the relaxed problem using the original objective; fskip optimization regarding the original objective; nminimize the relaxed problem using the original objective; iif the relaxation is infeasible, generate an irreducible infeasible subset for the analys of the problem; aif the relaxation is infeasible, generate all irreducible infeasible subsets for the analys of the problem.
- `delta::Float64`: The relaxation multiplier in the second phase -1.
- `flags::Union{Nothing,AbstractString}`: Specifies flags to be passed to the Optimizer.
# Return value
- `status::Int32`: The status after the relaxation: 1relaxed problem is infeasible; 2relaxed problem is unbounded; 3solution of the relaxed problem regarding the original objective is nonoptimal; 4error (when return code is nonzero); 5numerical instability; 6analysis of an infeasible relaxation was performed, but the relaxation is feasible.

See also the documentation of the correponding function [XPRSrepairweightedinfeasbounds](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrepairweightedinfeasbounds.html) in the C API.
"""
function XPRSrepairweightedinfeasbounds(prob::XPRSprob, lepref, gepref, lbpref, ubpref, lerelax, gerelax, lbrelax, ubrelax, phase2, delta, flags::Union{Nothing,AbstractString})::Int32
  p_status_dummy = Ref{Int32}(0)
  if isnothing(lepref) || length(lepref) == 0
    c_lepref = nothing
  elseif isa(lepref, AbstractVector{Float64})
    c_lepref = lepref
  else
    c_lepref = convert(Vector{Float64}, lepref)
  end
  if isnothing(gepref) || length(gepref) == 0
    c_gepref = nothing
  elseif isa(gepref, AbstractVector{Float64})
    c_gepref = gepref
  else
    c_gepref = convert(Vector{Float64}, gepref)
  end
  if isnothing(lbpref) || length(lbpref) == 0
    c_lbpref = nothing
  elseif isa(lbpref, AbstractVector{Float64})
    c_lbpref = lbpref
  else
    c_lbpref = convert(Vector{Float64}, lbpref)
  end
  if isnothing(ubpref) || length(ubpref) == 0
    c_ubpref = nothing
  elseif isa(ubpref, AbstractVector{Float64})
    c_ubpref = ubpref
  else
    c_ubpref = convert(Vector{Float64}, ubpref)
  end
  if isnothing(lerelax) || length(lerelax) == 0
    c_lerelax = nothing
  elseif isa(lerelax, AbstractVector{Float64})
    c_lerelax = lerelax
  else
    c_lerelax = convert(Vector{Float64}, lerelax)
  end
  if isnothing(gerelax) || length(gerelax) == 0
    c_gerelax = nothing
  elseif isa(gerelax, AbstractVector{Float64})
    c_gerelax = gerelax
  else
    c_gerelax = convert(Vector{Float64}, gerelax)
  end
  if isnothing(lbrelax) || length(lbrelax) == 0
    c_lbrelax = nothing
  elseif isa(lbrelax, AbstractVector{Float64})
    c_lbrelax = lbrelax
  else
    c_lbrelax = convert(Vector{Float64}, lbrelax)
  end
  if isnothing(ubrelax) || length(ubrelax) == 0
    c_ubrelax = nothing
  elseif isa(ubrelax, AbstractVector{Float64})
    c_ubrelax = ubrelax
  else
    c_ubrelax = convert(Vector{Float64}, ubrelax)
  end
  phase2xx = Cchar(phase2)
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSrepairweightedinfeasbounds")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cchar,Cdouble,Cstring), prob.handle, p_status_dummy, isnothing(c_lepref) ? C_NULL : c_lepref, isnothing(c_gepref) ? C_NULL : c_gepref, isnothing(c_lbpref) ? C_NULL : c_lbpref, isnothing(c_ubpref) ? C_NULL : c_ubpref, isnothing(c_lerelax) ? C_NULL : c_lerelax, isnothing(c_gerelax) ? C_NULL : c_gerelax, isnothing(c_lbrelax) ? C_NULL : c_lbrelax, isnothing(c_ubrelax) ? C_NULL : c_ubrelax, phase2xx, Float64(delta), flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSrepairweightedinfeasbounds

"""
    XPRSrepairinfeas(prob, penalty, phase2, flags, lepref, gepref, lbpref, ubpref, delta)::status

Provides a simplified interface for XPRSrepairweightedinfeas.

# Arguments
- `prob::XPRSprob`: The current problem.
- `penalty::Integer`: The type of penalties created from the preferences: ceach penalty is the reciprocal of the preference (default); sthe penalties are placed in the scaled problem.
- `phase2::Integer`: Controls the second phase of optimization: ouse the objective sense of the original problem (default); xmaximize the relaxed problem using the original objective; fskip optimization regarding the original objective; nminimize the relaxed problem using the original objective; iif the relaxation is infeasible, generate an irreducible infeasible subset for the analys of the problem; aif the relaxation is infeasible, generate all irreducible infeasible subsets for the analys of the problem.
- `flags::Integer`: Specifies what type of solve should be done: gsolve as MIP (default); lsolve as a linear model ignoring the discreteness of variables; xcall the global solver.
- `lepref::Float64`: Preference for relaxing the less or equal side of row.
- `gepref::Float64`: Preference for relaxing the greater or equal side of a row.
- `lbpref::Float64`: Preferences for relaxing lower bounds.
- `ubpref::Float64`: Preferences for relaxing upper bounds.
- `delta::Float64`: The relaxation multiplier in the second phase -1.
# Return value
- `status::Int32`: The status after the relaxation: 0relaxed optimum found; 1relaxed problem is infeasible; 2relaxed problem is unbounded; 3solution of the relaxed problem regarding the original objective is nonoptimal; 4error (when return code is nonzero); 5numerical instability; 6analysis of an infeasible relaxation was performed, but the relaxation is feasible.

See also the documentation of the correponding function [XPRSrepairinfeas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrepairinfeas.html) in the C API.
"""
function XPRSrepairinfeas(prob::XPRSprob, penalty, phase2, flags, lepref, gepref, lbpref, ubpref, delta)::Int32
  p_status_dummy = Ref{Int32}(0)
  penaltyxx = Cchar(penalty)
  phase2xx = Cchar(phase2)
  flagsxx = Cchar(flags)
  faddr = getFunctionAddress("XPRSrepairinfeas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Cchar,Cchar,Cchar,Cdouble,Cdouble,Cdouble,Cdouble,Cdouble), prob.handle, p_status_dummy, penaltyxx, phase2xx, flagsxx, Float64(lepref), Float64(gepref), Float64(lbpref), Float64(ubpref), Float64(delta))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSrepairinfeas

"""
    XPRSbasisstability(prob, type, norm, scaled)::value

Calculates various measures for the stability of the current basis, including the basis condition number.

# Arguments
- `prob::XPRSprob`: The current problem.
- `type::Integer`: 0Condition number of the basis.
- `norm::Integer`: 0Use the infinity norm.
- `scaled::Integer`: If the stability values are to be calculated in the scaled, or the unscaled matrix.
# Return value
- `value::Float64`: Pointer to a double, where the calculated value is to be returned.

See also the documentation of the correponding function [XPRSbasisstability](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSbasisstability.html) in the C API.
"""
function XPRSbasisstability(prob::XPRSprob, type, norm, scaled)::Float64
  typexx = Int32(type)
  normxx = Int32(norm)
  scaledxx = Int32(scaled)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSbasisstability")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ref{Cdouble}), prob.handle, typexx, normxx, scaledxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSbasisstability

"""
    XPRSobjsa(prob, ncols, colind, lower, upper)::lower, upper

Returns upper and lower sensitivity ranges for specified objective function coefficients.

If the objective coefficients are varied within these ranges the current basis remains optimal and the reduced costs remain valid.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of objective function coefficients whose sensitivity is sought.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns whose objective function coefficients sensitivity ranges are required.
- `lower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the objective function lower range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `upper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the objective function upper range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `lower::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the objective function lower range values are to be returned.
- `upper::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the objective function upper range values are to be returned.

See also the documentation of the correponding function [XPRSobjsa](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSobjsa.html) in the C API.
"""
function XPRSobjsa(prob::XPRSprob, ncols, colind, lower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, upper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  faddr = getFunctionAddress("XPRSobjsa")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(lower) ? C_NULL : lower, isnothing(upper) ? C_NULL : upper)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  lower, upper
end
export XPRSobjsa

"""
    XPRSbndsa(prob, ncols, colind, lblower, lbupper, ublower, ubupper)::lblower, lbupper, ublower, ubupper

Returns upper and lower sensitivity ranges for specified variables' lower and upper bounds.

If the bounds are varied within these ranges the current basis remains optimal and feasible.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of variables whose sensitivity is sought.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns whose bounds' ranges are required.
- `lblower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable lower bound lower range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `lbupper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable lower bound upper range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `ublower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable upper bound lower range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `ubupper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable upper bound upper range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `lblower::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable lower bound lower range values are to be returned.
- `lbupper::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable lower bound upper range values are to be returned.
- `ublower::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable upper bound lower range values are to be returned.
- `ubupper::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ncols` where the variable upper bound upper range values are to be returned.

See also the documentation of the correponding function [XPRSbndsa](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSbndsa.html) in the C API.
"""
function XPRSbndsa(prob::XPRSprob, ncols, colind, lblower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, lbupper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, ublower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, ubupper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  faddr = getFunctionAddress("XPRSbndsa")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(lblower) ? C_NULL : lblower, isnothing(lbupper) ? C_NULL : lbupper, isnothing(ublower) ? C_NULL : ublower, isnothing(ubupper) ? C_NULL : ubupper)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  lblower, lbupper, ublower, ubupper
end
export XPRSbndsa

"""
    XPRSrhssa(prob, nrows, rowind, lower, upper)::lower, upper

Returns upper and lower sensitivity ranges for specified right hand side (RHS) function coefficients.

If the RHS coefficients are varied within these ranges the current basis remains optimal and the reduced costs remain valid.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: The number of RHS coefficients for which sensitivity ranges are required.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the indices of the rows whose RHS coefficients sensitivity ranges are required.
- `lower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `nrows` where the RHS lower range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `upper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `nrows` where the RHS upper range values are to be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `lower::Union{Nothing,AbstractVector{Float64}}`: Double array of length `nrows` where the RHS lower range values are to be returned.
- `upper::Union{Nothing,AbstractVector{Float64}}`: Double array of length `nrows` where the RHS upper range values are to be returned.

See also the documentation of the correponding function [XPRSrhssa](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrhssa.html) in the C API.
"""
function XPRSrhssa(prob::XPRSprob, nrows, rowind, lower::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, upper::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSrhssa")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(lower) ? C_NULL : lower, isnothing(upper) ? C_NULL : upper)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  lower, upper
end
export XPRSrhssa

"""
    XPRSaddqmatrix(prob, row, ncoefs, rowqcol1, rowqcol2, rowqcoef)::prob

Adds a new quadratic matrix into a row defined by triplets.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of the row where the quadratic matrix is to be added.
- `ncoefs::Integer`: Number of triplets used to define the quadratic matrix.
- `rowqcol1::AbstractVector{Integer}`: First index in the triplets.
- `rowqcol2::AbstractVector{Integer}`: Second index in the triplets.
- `rowqcoef::AbstractVector{Number}`: Coefficients in the triplets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddqmatrix](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddqmatrix.html) in the C API.
"""
function XPRSaddqmatrix(prob::XPRSprob, row, ncoefs, rowqcol1, rowqcol2, rowqcoef)::XPRSprob
  rowxx = Int32(row)
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  faddr = getFunctionAddress("XPRSaddqmatrix")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, ncoefsxx, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddqmatrix

"""
    XPRSaddqmatrix64(prob, row, ncoefs, rowqcol1, rowqcol2, rowqcoef)::prob

Adds a new quadratic matrix into a row defined by triplets.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of the row where the quadratic matrix is to be added.
- `ncoefs::Integer`: Number of triplets used to define the quadratic matrix.
- `rowqcol1::AbstractVector{Integer}`: First index in the triplets.
- `rowqcol2::AbstractVector{Integer}`: Second index in the triplets.
- `rowqcoef::AbstractVector{Number}`: Coefficients in the triplets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddqmatrix64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddqmatrix64.html) in the C API.
"""
function XPRSaddqmatrix64(prob::XPRSprob, row, ncoefs, rowqcol1, rowqcol2, rowqcoef)::XPRSprob
  rowxx = Int32(row)
  ncoefsxx = Int64(ncoefs)
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  faddr = getFunctionAddress("XPRSaddqmatrix64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, ncoefsxx, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddqmatrix64

"""
    XPRSdelqmatrix(prob, row)::prob

Deletes the quadratic part of a row or of the objective function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of row from which the quadratic part is to be deleted.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelqmatrix](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelqmatrix.html) in the C API.
"""
function XPRSdelqmatrix(prob::XPRSprob, row)::XPRSprob
  rowxx = Int32(row)
  faddr = getFunctionAddress("XPRSdelqmatrix")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, rowxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelqmatrix

"""
    XPRSloadqcqp(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoef, rowqcol1, rowqcol2, rowqcoef)::prob

Used to load a quadratic problem with quadratic side constraints into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function as well as in its constraints.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint (use this one for quadratic constraints as well); Eindicates an `=` constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nqrows::Integer`: Number of rows containing quadratic matrices.
- `qrowind::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the indices of rows with quadratic matrices in them.
- `nrowqcoef::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the number of nonzeros in each quadratic constraint matrix.
- `rowqcol1::AbstractVector{Integer}`: Integer array of size `nqcelem`, where `nqcelem` equals the sum of the elements in `nrowqcoef` (i.e. the total number of quadratic matrix elements in all the constraints).
- `rowqcol2::AbstractVector{Integer}`: Integer array of size `nqcelem`, containing the second index for the quadratic constraint matrices.
- `rowqcoef::AbstractVector{Number}`: Integer array of size `nqcelem`, containing the coefficients for the quadratic constraint matrices.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadqcqp](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadqcqp.html) in the C API.
"""
function XPRSloadqcqp(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoef, rowqcol1, rowqcol2, rowqcoef)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int32(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nqrowsxx = Int32(nqrows)
  if isnothing(qrowind) || length(qrowind) == 0
    c_qrowind = nothing
  elseif isa(qrowind, AbstractVector{Int32})
    c_qrowind = qrowind
  else
    c_qrowind = convert(Vector{Int32}, qrowind)
  end
  if isnothing(nrowqcoef) || length(nrowqcoef) == 0
    c_nrowqcoef = nothing
  elseif isa(nrowqcoef, AbstractVector{Int32})
    c_nrowqcoef = nrowqcoef
  else
    c_nrowqcoef = convert(Vector{Int32}, nrowqcoef)
  end
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  faddr = getFunctionAddress("XPRSloadqcqp")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nqrowsxx, isnothing(c_qrowind) ? C_NULL : c_qrowind, isnothing(c_nrowqcoef) ? C_NULL : c_nrowqcoef, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadqcqp

"""
    XPRSloadqcqp64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoef, rowqcol1, rowqcol2, rowqcoef)::prob

Used to load a quadratic problem with quadratic side constraints into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function as well as in its constraints.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint (use this one for quadratic constraints as well); Eindicates an `=` constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nqrows::Integer`: Number of rows containing quadratic matrices.
- `qrowind::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the indices of rows with quadratic matrices in them.
- `nrowqcoef::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the number of nonzeros in each quadratic constraint matrix.
- `rowqcol1::AbstractVector{Integer}`: Integer array of size `nqcelem`, where `nqcelem` equals the sum of the elements in `nrowqcoef` (i.e. the total number of quadratic matrix elements in all the constraints).
- `rowqcol2::AbstractVector{Integer}`: Integer array of size `nqcelem`, containing the second index for the quadratic constraint matrices.
- `rowqcoef::AbstractVector{Number}`: Integer array of size `nqcelem`, containing the coefficients for the quadratic constraint matrices.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadqcqp64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadqcqp64.html) in the C API.
"""
function XPRSloadqcqp64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoef, rowqcol1, rowqcol2, rowqcoef)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int64(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nqrowsxx = Int32(nqrows)
  if isnothing(qrowind) || length(qrowind) == 0
    c_qrowind = nothing
  elseif isa(qrowind, AbstractVector{Int32})
    c_qrowind = qrowind
  else
    c_qrowind = convert(Vector{Int32}, qrowind)
  end
  if isnothing(nrowqcoef) || length(nrowqcoef) == 0
    c_nrowqcoef = nothing
  elseif isa(nrowqcoef, AbstractVector{Int64})
    c_nrowqcoef = nrowqcoef
  else
    c_nrowqcoef = convert(Vector{Int64}, nrowqcoef)
  end
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  faddr = getFunctionAddress("XPRSloadqcqp64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nqrowsxx, isnothing(c_qrowind) ? C_NULL : c_qrowind, isnothing(c_nrowqcoef) ? C_NULL : c_nrowqcoef, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadqcqp64

"""
    XPRSloadmiqcqp(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoefs, rowqcol1, rowqcol2, rowqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a mixed integer quadratic problem with quadratic constraints into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function as well as in its constraints. Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint (use this one for quadratic constraints as well); Eindicates an `=` constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nqrows::Integer`: Number of rows containing quadratic matrices.
- `qrowind::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the indices of rows with quadratic matrices in them.
- `nrowqcoefs::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the number of nonzeros in each quadratic constraint matrix.
- `rowqcol1::AbstractVector{Integer}`: Integer array of size `nqcelem`, where `nqcelem` equals the sum of the elements in `nrowqcoefs` (i.e. the total number of quadratic matrix elements in all the constraints).
- `rowqcol2::AbstractVector{Integer}`: Integer array of size `nqcelem`, containing the second index for the quadratic constraint matrices.
- `rowqcoef::AbstractVector{Number}`: Integer array of size `nqcelem`, containing the coefficients for the quadratic constraint matrices.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integer variables.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing the set types: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmiqcqp](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmiqcqp.html) in the C API.
"""
function XPRSloadmiqcqp(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoefs, rowqcol1, rowqcol2, rowqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int32(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nqrowsxx = Int32(nqrows)
  if isnothing(qrowind) || length(qrowind) == 0
    c_qrowind = nothing
  elseif isa(qrowind, AbstractVector{Int32})
    c_qrowind = qrowind
  else
    c_qrowind = convert(Vector{Int32}, qrowind)
  end
  if isnothing(nrowqcoefs) || length(nrowqcoefs) == 0
    c_nrowqcoefs = nothing
  elseif isa(nrowqcoefs, AbstractVector{Int32})
    c_nrowqcoefs = nrowqcoefs
  else
    c_nrowqcoefs = convert(Vector{Int32}, nrowqcoefs)
  end
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int32})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int32}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmiqcqp")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nqrowsxx, isnothing(c_qrowind) ? C_NULL : c_qrowind, isnothing(c_nrowqcoefs) ? C_NULL : c_nrowqcoefs, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmiqcqp

"""
    XPRSloadmiqcqp64(prob, probname, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoefs, rowqcol1, rowqcol2, rowqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::prob

Used to load a mixed integer quadratic problem with quadratic constraints into the Optimizer data structure.

Such a problem may have quadratic terms in its objective function as well as in its constraints. Integer, binary, partial integer, semi-continuous and semi-continuous integer variables can be defined, together with sets of type 1 and 2. The reference row values for the set members are passed as an array rather than specifying a reference row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `probname::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing a name for the problem.
- `ncols::Integer`: Number of structural columns in the matrix.
- `nrows::Integer`: Number of rows in the matrix (not including the objective row).
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` containing the row types: Lindicates a `<=` constraint (use this one for quadratic constraints as well); Eindicates an `=` constraint; Gindicates a `>=` constraint; Rindicates a range constraint; Nindicates a nonbinding constraint.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side coefficients of the rows.
- `rng::AbstractVector{Number}`: Double array of length `nrows` containing the range values for range rows.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` containing the objective function coefficients.
- `start::AbstractVector{Integer}`: Integer array containing the offsets in the `rowind` and `rowcoef` arrays of the start of the elements for each column.
- `collen::AbstractVector{Integer}`: Integer array of length `ncols` containing the number of nonzero elements in each column.
- `rowind::AbstractVector{Integer}`: Integer array containing the row indices for the nonzero elements in each column.
- `rowcoef::AbstractVector{Number}`: Double array containing the nonzero element values; length as for `rowind`.
- `lb::AbstractVector{Number}`: Double array of length `ncols` containing the lower bounds on the columns.
- `ub::AbstractVector{Number}`: Double array of length `ncols` containing the upper bounds on the columns.
- `nobjqcoefs::Integer`: Number of quadratic terms.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `nobjqcoefs` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: Double array of size `nobjqcoefs` containing the quadratic coefficients.
- `nqrows::Integer`: Number of rows containing quadratic matrices.
- `qrowind::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the indices of rows with quadratic matrices in them.
- `nrowqcoefs::AbstractVector{Integer}`: Integer array of size `nqrows`, containing the number of nonzeros in each quadratic constraint matrix.
- `rowqcol1::AbstractVector{Integer}`: Integer array of size `nqcelem`, where `nqcelem` equals the sum of the elements in `nrowqcoefs` (i.e. the total number of quadratic matrix elements in all the constraints).
- `rowqcol2::AbstractVector{Integer}`: Integer array of size `nqcelem`, containing the second index for the quadratic constraint matrices.
- `rowqcoef::AbstractVector{Number}`: Integer array of size `nqcelem`, containing the coefficients for the quadratic constraint matrices.
- `nentities::Integer`: Number of binary, integer, semi-continuous, semi-continuous integer and partial integer entities.
- `nsets::Integer`: Number of SOS1 and SOS2 sets.
- `coltype::AbstractVector{Cchar}`: Character array of length `nentities` containing the entity types: Bbinary variables; Iinteger variables; Ppartial integer variables; Ssemi-continuous variables; Rsemi-continuous integer variables.
- `entind::AbstractVector{Integer}`: Integer array of length `nentities` containing the column indices of the MIP entities.
- `limit::AbstractVector{Number}`: Double array of length `nentities` containing the integer limits for the partial integer variables and lower bounds for semi-continuous and semi-continuous integer variables (any entries in the positions corresponding to binary and integer variables will be ignored).
- `settype::AbstractVector{Cchar}`: Character array of length `nsets` containing the set types: 1SOS1 type sets; 2SOS2 type sets.May be `nothing` if not required.
- `setstart::AbstractVector{Integer}`: Integer array containing the offsets in the `setind` and `refval` arrays indicating the start of the sets.
- `setind::AbstractVector{Integer}`: Integer array of length `setstart[nsets]-1` containing the columns in each set.
- `refval::AbstractVector{Number}`: Double array of length `setstart[nsets]-1` containing the reference row entries for each member of the sets.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadmiqcqp64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmiqcqp64.html) in the C API.
"""
function XPRSloadmiqcqp64(prob::XPRSprob, probname::Union{Nothing,AbstractString}, ncols, nrows, rowtype, rhs, rng, objcoef, start, collen, rowind, rowcoef, lb, ub, nobjqcoefs, objqcol1, objqcol2, objqcoef, nqrows, qrowind, nrowqcoefs, rowqcol1, rowqcol2, rowqcoef, nentities, nsets, coltype, entind, limit, settype, setstart, setind, refval)::XPRSprob
  if isnothing(probname)
    probname_pass = C_NULL
  else
    probname_pass = probname
  end
  ncolsxx = Int32(ncols)
  nrowsxx = Int32(nrows)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(collen) || length(collen) == 0
    c_collen = nothing
  elseif isa(collen, AbstractVector{Int32})
    c_collen = collen
  else
    c_collen = convert(Vector{Int32}, collen)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  if isnothing(lb) || length(lb) == 0
    c_lb = nothing
  elseif isa(lb, AbstractVector{Float64})
    c_lb = lb
  else
    c_lb = convert(Vector{Float64}, lb)
  end
  if isnothing(ub) || length(ub) == 0
    c_ub = nothing
  elseif isa(ub, AbstractVector{Float64})
    c_ub = ub
  else
    c_ub = convert(Vector{Float64}, ub)
  end
  nobjqcoefsxx = Int64(nobjqcoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  nqrowsxx = Int32(nqrows)
  if isnothing(qrowind) || length(qrowind) == 0
    c_qrowind = nothing
  elseif isa(qrowind, AbstractVector{Int32})
    c_qrowind = qrowind
  else
    c_qrowind = convert(Vector{Int32}, qrowind)
  end
  if isnothing(nrowqcoefs) || length(nrowqcoefs) == 0
    c_nrowqcoefs = nothing
  elseif isa(nrowqcoefs, AbstractVector{Int64})
    c_nrowqcoefs = nrowqcoefs
  else
    c_nrowqcoefs = convert(Vector{Int64}, nrowqcoefs)
  end
  if isnothing(rowqcol1) || length(rowqcol1) == 0
    c_rowqcol1 = nothing
  elseif isa(rowqcol1, AbstractVector{Int32})
    c_rowqcol1 = rowqcol1
  else
    c_rowqcol1 = convert(Vector{Int32}, rowqcol1)
  end
  if isnothing(rowqcol2) || length(rowqcol2) == 0
    c_rowqcol2 = nothing
  elseif isa(rowqcol2, AbstractVector{Int32})
    c_rowqcol2 = rowqcol2
  else
    c_rowqcol2 = convert(Vector{Int32}, rowqcol2)
  end
  if isnothing(rowqcoef) || length(rowqcoef) == 0
    c_rowqcoef = nothing
  elseif isa(rowqcoef, AbstractVector{Float64})
    c_rowqcoef = rowqcoef
  else
    c_rowqcoef = convert(Vector{Float64}, rowqcoef)
  end
  nentitiesxx = Int32(nentities)
  nsetsxx = Int32(nsets)
  if isnothing(coltype) || length(coltype) == 0
    c_coltype = nothing
  elseif isa(coltype, AbstractVector{Cchar})
    c_coltype = coltype
  else
    c_coltype = convert(Vector{Cchar}, coltype)
  end
  if isnothing(entind) || length(entind) == 0
    c_entind = nothing
  elseif isa(entind, AbstractVector{Int32})
    c_entind = entind
  else
    c_entind = convert(Vector{Int32}, entind)
  end
  if isnothing(limit) || length(limit) == 0
    c_limit = nothing
  elseif isa(limit, AbstractVector{Float64})
    c_limit = limit
  else
    c_limit = convert(Vector{Float64}, limit)
  end
  if isnothing(settype) || length(settype) == 0
    c_settype = nothing
  elseif isa(settype, AbstractVector{Cchar})
    c_settype = settype
  else
    c_settype = convert(Vector{Cchar}, settype)
  end
  if isnothing(setstart) || length(setstart) == 0
    c_setstart = nothing
  elseif isa(setstart, AbstractVector{Int64})
    c_setstart = setstart
  else
    c_setstart = convert(Vector{Int64}, setstart)
  end
  if isnothing(setind) || length(setind) == 0
    c_setind = nothing
  elseif isa(setind, AbstractVector{Int32})
    c_setind = setind
  else
    c_setind = convert(Vector{Int32}, setind)
  end
  if isnothing(refval) || length(refval) == 0
    c_refval = nothing
  elseif isa(refval, AbstractVector{Float64})
    c_refval = refval
  else
    c_refval = convert(Vector{Float64}, refval)
  end
  faddr = getFunctionAddress("XPRSloadmiqcqp64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Clonglong},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble},Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, probname_pass, ncolsxx, nrowsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_rng) ? C_NULL : c_rng, isnothing(c_objcoef) ? C_NULL : c_objcoef, isnothing(c_start) ? C_NULL : c_start, isnothing(c_collen) ? C_NULL : c_collen, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef, isnothing(c_lb) ? C_NULL : c_lb, isnothing(c_ub) ? C_NULL : c_ub, nobjqcoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef, nqrowsxx, isnothing(c_qrowind) ? C_NULL : c_qrowind, isnothing(c_nrowqcoefs) ? C_NULL : c_nrowqcoefs, isnothing(c_rowqcol1) ? C_NULL : c_rowqcol1, isnothing(c_rowqcol2) ? C_NULL : c_rowqcol2, isnothing(c_rowqcoef) ? C_NULL : c_rowqcoef, nentitiesxx, nsetsxx, isnothing(c_coltype) ? C_NULL : c_coltype, isnothing(c_entind) ? C_NULL : c_entind, isnothing(c_limit) ? C_NULL : c_limit, isnothing(c_settype) ? C_NULL : c_settype, isnothing(c_setstart) ? C_NULL : c_setstart, isnothing(c_setind) ? C_NULL : c_setind, isnothing(c_refval) ? C_NULL : c_refval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadmiqcqp64

"""
    XPRSaddobj(prob, ncols, colind, objcoef, priority, weight)::prob

Appends an objective function with the given coefficients to a multi-objective problem.

The weight and priority of the objective are set to the given values.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of objective function coefficient elements to add.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns whose objective coefficients will change.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` giving the new objective function coefficients.
- `priority::Integer`: The priority for the objective function.
- `weight::Float64`: The weight for the objective function.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddobj.html) in the C API.
"""
function XPRSaddobj(prob::XPRSprob, ncols, colind, objcoef, priority, weight)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  priorityxx = Int32(priority)
  faddr = getFunctionAddress("XPRSaddobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Cint,Cdouble), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_objcoef) ? C_NULL : c_objcoef, priorityxx, Float64(weight))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddobj

"""
    XPRSchgobjn(prob, objidx, ncols, colind, objcoef)::prob

Modifies one or more coefficients of an objective function in a multi-objective problem.

If the objective already exists, any coefficients not present in the `colind` and `objcoef` arrays will unchanged. If the objective does not exist, it will be added to the problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective function to add or modify.
- `ncols::Integer`: Number of objective function coefficient elements to change.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns whose objective coefficients will change.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` giving the new objective function coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgobjn](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgobjn.html) in the C API.
"""
function XPRSchgobjn(prob::XPRSprob, objidx, ncols, colind, objcoef)::XPRSprob
  objidxxx = Int32(objidx)
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  faddr = getFunctionAddress("XPRSchgobjn")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, objidxxx, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_objcoef) ? C_NULL : c_objcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgobjn

"""
    XPRSdelobj(prob, objidx)::prob

Removes an objective function from a multi-objective problem.

Any objectives with `index > objidx` will be shifted down. Deleting the last objective function in the problem causes all the objective coefficients to be zeroed, but `OBJECTIVES` remains set to `1`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective to remove.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelobj.html) in the C API.
"""
function XPRSdelobj(prob::XPRSprob, objidx)::XPRSprob
  objidxxx = Int32(objidx)
  faddr = getFunctionAddress("XPRSdelobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, objidxxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelobj

"""
    XPRScopycallbacks(dest, src)::dest

Copies callback functions defined for one problem to another.

# Arguments
- `dest::XPRSprob`: The problem to which the callbacks are copied.
- `src::XPRSprob`: The problem from which the callbacks are copied.
# Return value
- `dest::XPRSprob`: The problem to which the callbacks are copied.

See also the documentation of the correponding function [XPRScopycallbacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScopycallbacks.html) in the C API.
"""
function XPRScopycallbacks(dest::XPRSprob, src::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRScopycallbacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cvoid}), dest.handle, src.handle)
  consumeCallbackException(dest)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(dest), nothing))
  end
  dest
end
export XPRScopycallbacks

"""
    XPRScopycontrols(dest, src)::dest

Copies controls defined for one problem to another.

# Arguments
- `dest::XPRSprob`: The problem to which the controls are copied.
- `src::XPRSprob`: The problem from which the controls are copied.
# Return value
- `dest::XPRSprob`: The problem to which the controls are copied.

See also the documentation of the correponding function [XPRScopycontrols](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScopycontrols.html) in the C API.
"""
function XPRScopycontrols(dest::XPRSprob, src::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRScopycontrols")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cvoid}), dest.handle, src.handle)
  consumeCallbackException(dest)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(dest), nothing))
  end
  dest
end
export XPRScopycontrols

"""
    XPRScopyprob(dest, src, name)::dest

Copies information defined for one problem to another.

# Arguments
- `dest::XPRSprob`: The new problem pointer to which information is copied.
- `src::XPRSprob`: The old problem pointer from which information is copied.
- `name::Union{Nothing,AbstractString}`: A string of up to 1024 characters including `nothing` terminator containing the name for the problem copy.
# Return value
- `dest::XPRSprob`: The new problem pointer to which information is copied.

See also the documentation of the correponding function [XPRScopyprob](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScopyprob.html) in the C API.
"""
function XPRScopyprob(dest::XPRSprob, src::XPRSprob, name::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(name)
    name_pass = C_NULL
  else
    name_pass = name
  end
  faddr = getFunctionAddress("XPRScopyprob")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cvoid},Cstring), dest.handle, src.handle, name_pass)
  consumeCallbackException(dest)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(dest), nothing))
  end
  dest
end
export XPRScopyprob

"""
    XPRSinterrupt(prob, reason)::prob

Interrupts the Optimizer algorithms.

# Arguments
- `prob::XPRSprob`: The current problem.
- `reason::XPRSStopType`: The reason for stopping.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSinterrupt](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSinterrupt.html) in the C API.
"""
function XPRSinterrupt(prob::XPRSprob, reason)::XPRSprob
  faddr = getFunctionAddress("XPRSinterrupt")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, Int32(reason))
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSinterrupt

"""
    XPRSgetprobname(prob)::name

Returns the current problem name.

# Arguments
- `prob::XPRSprob`: The current problem.
# Return value
- `name::AbstractString`: A string of up to MAXPROBNAMELENGTH characters to contain the current problem name.

See also the documentation of the correponding function [XPRSgetprobname](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetprobname.html) in the C API.
"""
function XPRSgetprobname(prob::XPRSprob)::AbstractString
  name_buffer = Vector{Cchar}(undef, 1025)
  faddr = getFunctionAddress("XPRSgetprobname")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cchar}), prob.handle, name_buffer)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  name = unsafe_string(pointer(name_buffer))
  name
end
export XPRSgetprobname

"""
    XPRSsetintcontrol(prob, control, value)::prob

Sets the value of a given integer control parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be set.
- `value::Integer`: Value to which the control parameter is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetintcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetintcontrol.html) in the C API.
"""
function XPRSsetintcontrol(prob::XPRSprob, control, value)::XPRSprob
  controlxx = Int32(control)
  valuexx = Int32(value)
  faddr = getFunctionAddress("XPRSsetintcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint), prob.handle, controlxx, valuexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetintcontrol

"""
    XPRSsetintcontrol64(prob, control, value)::prob

Sets the value of a given integer control parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be set.
- `value::Integer`: Value to which the control parameter is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetintcontrol64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetintcontrol64.html) in the C API.
"""
function XPRSsetintcontrol64(prob::XPRSprob, control, value)::XPRSprob
  controlxx = Int32(control)
  valuexx = Int64(value)
  faddr = getFunctionAddress("XPRSsetintcontrol64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Clonglong), prob.handle, controlxx, valuexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetintcontrol64

"""
    XPRSsetdblcontrol(prob, control, value)::prob

Sets the value of a given double control parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be set.
- `value::Float64`: Value to which the control parameter is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetdblcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetdblcontrol.html) in the C API.
"""
function XPRSsetdblcontrol(prob::XPRSprob, control, value)::XPRSprob
  controlxx = Int32(control)
  faddr = getFunctionAddress("XPRSsetdblcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cdouble), prob.handle, controlxx, Float64(value))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetdblcontrol

"""
    XPRSsetstrcontrol(prob, control, value)::prob

Used to set the value of a given string control parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be set.
- `value::Union{Nothing,AbstractString}`: A string containing the value to which the control is to be set (plus a null terminator).
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetstrcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetstrcontrol.html) in the C API.
"""
function XPRSsetstrcontrol(prob::XPRSprob, control, value::Union{Nothing,AbstractString})::XPRSprob
  controlxx = Int32(control)
  if isnothing(value)
    value_pass = C_NULL
  else
    value_pass = value
  end
  faddr = getFunctionAddress("XPRSsetstrcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring), prob.handle, controlxx, value_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetstrcontrol

"""
    XPRSgetintcontrol(prob, control)::value

Enables users to recover the values of various integer control parameters

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be returned.
# Return value
- `value::Int32`: Pointer to an integer where the value of the control will be returned.

See also the documentation of the correponding function [XPRSgetintcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetintcontrol.html) in the C API.
"""
function XPRSgetintcontrol(prob::XPRSprob, control)::Int32
  controlxx = Int32(control)
  p_value_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetintcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, controlxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetintcontrol

"""
    XPRSgetintcontrol64(prob, control)::value

Enables users to recover the values of various integer control parameters

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be returned.
# Return value
- `value::Int64`: Pointer to an integer where the value of the control will be returned.

See also the documentation of the correponding function [XPRSgetintcontrol64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetintcontrol64.html) in the C API.
"""
function XPRSgetintcontrol64(prob::XPRSprob, control)::Int64
  controlxx = Int32(control)
  p_value_dummy = Ref{Int64}(0)
  faddr = getFunctionAddress("XPRSgetintcontrol64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Clonglong}), prob.handle, controlxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetintcontrol64

"""
    XPRSgetdblcontrol(prob, control)::value

Retrieves the value of a given double control parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be returned.
# Return value
- `value::Float64`: Pointer to the location where the control value will be returned.

See also the documentation of the correponding function [XPRSgetdblcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetdblcontrol.html) in the C API.
"""
function XPRSgetdblcontrol(prob::XPRSprob, control)::Float64
  controlxx = Int32(control)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetdblcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cdouble}), prob.handle, controlxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetdblcontrol

"""
    XPRSgetstrcontrol(prob, control)::value

Returns the value of a given string control parameters.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be returned.
# Return value
- `value::AbstractString`: Pointer to a string where the value of the control (plus null terminator) will be returned.

See also the documentation of the correponding function [XPRSgetstrcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetstrcontrol.html) in the C API.
"""
function XPRSgetstrcontrol(prob::XPRSprob, control)::AbstractString
  controlxx = Int32(control)
  value_buffer = Vector{Cchar}(undef, 1024)
  faddr = getFunctionAddress("XPRSgetstrcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar}), prob.handle, controlxx, value_buffer)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  value = unsafe_string(pointer(value_buffer))
  value
end
export XPRSgetstrcontrol

"""
    XPRSgetstringcontrol(prob, control, maxbytes)::value, nbytes

Returns the value of a given string control parameters.

# Arguments
- `prob::XPRSprob`: The current problem.
- `control::Integer`: Control parameter whose value is to be returned.
- `maxbytes::Integer`: Maximum number of bytes to be written into the value argument.
# Return values
- `value::AbstractString`: Pointer to a string where the value of the control (plus null terminator) will be returned.
- `nbytes::Int32`: Returns the length of the string control including the null terminator.

See also the documentation of the correponding function [XPRSgetstringcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetstringcontrol.html) in the C API.
"""
function XPRSgetstringcontrol(prob::XPRSprob, control, maxbytes)::Tuple{AbstractString,Int32}
  controlxx = Int32(control)
  value_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetstringcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint,Ref{Cint}), prob.handle, controlxx, value_buffer, maxbytesxx, p_nbytes_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  value = unsafe_string(pointer(value_buffer))
  p_nbytes = p_nbytes_dummy[]
  value, p_nbytes
end
export XPRSgetstringcontrol

"""
    XPRSgetintattrib(prob, attrib)::value

Enables users to recover the values of various integer problem attributes.

Problem attributes are set during loading and optimization of a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Int32`: Pointer to an integer where the value of the problem attribute will be returned.

See also the documentation of the correponding function [XPRSgetintattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetintattrib.html) in the C API.
"""
function XPRSgetintattrib(prob::XPRSprob, attrib)::Int32
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetintattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetintattrib

"""
    XPRSgetintattrib64(prob, attrib)::value

Enables users to recover the values of various integer problem attributes.

Problem attributes are set during loading and optimization of a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Int64`: Pointer to an integer where the value of the problem attribute will be returned.

See also the documentation of the correponding function [XPRSgetintattrib64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetintattrib64.html) in the C API.
"""
function XPRSgetintattrib64(prob::XPRSprob, attrib)::Int64
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Int64}(0)
  faddr = getFunctionAddress("XPRSgetintattrib64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Clonglong}), prob.handle, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetintattrib64

"""
    XPRSgetstrattrib(prob, attrib)::value

Enables users to recover the values of various string problem attributes.

Problem attributes are set during loading and optimization of a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::AbstractString`: Pointer to a string where the value of the attribute (plus null terminator) will be returned.

See also the documentation of the correponding function [XPRSgetstrattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetstrattrib.html) in the C API.
"""
function XPRSgetstrattrib(prob::XPRSprob, attrib)::AbstractString
  attribxx = Int32(attrib)
  value_buffer = Vector{Cchar}(undef, 1024)
  faddr = getFunctionAddress("XPRSgetstrattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar}), prob.handle, attribxx, value_buffer)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  value = unsafe_string(pointer(value_buffer))
  value
end
export XPRSgetstrattrib

"""
    XPRSgetstringattrib(prob, attrib, maxbytes)::value, nbytes

Enables users to recover the values of various string problem attributes.

Problem attributes are set during loading and optimization of a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `attrib::Integer`: Problem attribute whose value is to be returned.
- `maxbytes::Integer`: Maximum number of bytes to be written into the cgval argument.
# Return values
- `value::AbstractString`: Pointer to a string where the value of the attribute (plus null terminator) will be returned.
- `nbytes::Int32`: Returns the length of the string control including the null terminator.

See also the documentation of the correponding function [XPRSgetstringattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetstringattrib.html) in the C API.
"""
function XPRSgetstringattrib(prob::XPRSprob, attrib, maxbytes)::Tuple{AbstractString,Int32}
  attribxx = Int32(attrib)
  value_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetstringattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint,Ref{Cint}), prob.handle, attribxx, value_buffer, maxbytesxx, p_nbytes_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  value = unsafe_string(pointer(value_buffer))
  p_nbytes = p_nbytes_dummy[]
  value, p_nbytes
end
export XPRSgetstringattrib

"""
    XPRSgetdblattrib(prob, attrib)::value

Enables users to retrieve the values of various double problem attributes.

Problem attributes are set during loading and optimization of a problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Float64`: Pointer to a double where the value of the problem attribute will be returned.

See also the documentation of the correponding function [XPRSgetdblattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetdblattrib.html) in the C API.
"""
function XPRSgetdblattrib(prob::XPRSprob, attrib)::Float64
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetdblattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cdouble}), prob.handle, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetdblattrib

"""
    XPRSgetcontrolinfo(prob, name)::id, type

Accesses the id number and the type information of a control given its name.

A control name may be for example `XPRS_PRESOLVE`. Names are case-insensitive and may or may not have the `XPRS_` prefix. The id number is the constant used to identify the control for calls to functions such as XPRSgetintcontrol. The function will return an id number of `0` and a type value of `XPRS_TYPE_NOTDEFINED` if the name is not recognized as a control name. Note that this will occur if the name is an attribute name and not a control name.

# Arguments
- `prob::XPRSprob`: The current problem.
- `name::Union{Nothing,AbstractString}`: The name of the control to be queried.
# Return values
- `id::Int32`: Pointer to an integer where the id number will be returned.
- `type::XPRSParameterType`: Pointer to an integer where the type information will be returned.

See also the documentation of the correponding function [XPRSgetcontrolinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcontrolinfo.html) in the C API.
"""
function XPRSgetcontrolinfo(prob::XPRSprob, name::Union{Nothing,AbstractString})::Tuple{Int32,XPRSParameterType}
  if isnothing(name)
    name_pass = C_NULL
  else
    name_pass = name
  end
  p_id_dummy = Ref{Int32}(0)
  p_type_dummy = Ref{Cint}(0)
  faddr = getFunctionAddress("XPRSgetcontrolinfo")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Ref{Cint},Ref{Cint}), prob.handle, name_pass, p_id_dummy, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_id = p_id_dummy[]
  p_type = XPRSParameterType(p_type_dummy[])
  p_id, p_type
end
export XPRSgetcontrolinfo

"""
    XPRSgetattribinfo(prob, name)::id, type

Accesses the id number and the type information of an attribute given its name.

An attribute name may be for example `XPRS_ROWS`. Names are case-insensitive and may or may not have the `XPRS_` prefix. The id number is the constant used to identify the attribute for calls to functions such as XPRSgetintattrib. The type information returned will be one of the below integer constants defined in the `xprs.h` header file. The function will return an id number of 0 and a type value of `XPRS_TYPE_NOTDEFINED` if the name is not recognized as an attribute name. Note that this will occur if the name is a control name and not an attribute name.

# Arguments
- `prob::XPRSprob`: The current problem.
- `name::Union{Nothing,AbstractString}`: The name of the attribute to be queried.
# Return values
- `id::Int32`: Pointer to an integer where the id number will be returned.
- `type::XPRSParameterType`: Pointer to an integer where the type id will be returned.

See also the documentation of the correponding function [XPRSgetattribinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetattribinfo.html) in the C API.
"""
function XPRSgetattribinfo(prob::XPRSprob, name::Union{Nothing,AbstractString})::Tuple{Int32,XPRSParameterType}
  if isnothing(name)
    name_pass = C_NULL
  else
    name_pass = name
  end
  p_id_dummy = Ref{Int32}(0)
  p_type_dummy = Ref{Cint}(0)
  faddr = getFunctionAddress("XPRSgetattribinfo")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Ref{Cint},Ref{Cint}), prob.handle, name_pass, p_id_dummy, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_id = p_id_dummy[]
  p_type = XPRSParameterType(p_type_dummy[])
  p_id, p_type
end
export XPRSgetattribinfo

"""
    XPRSgetindex(prob, type, name)::index

Returns the index for a specified row or column name.

# Arguments
- `prob::XPRSprob`: The current problem.
- `type::Integer`: XPRS_NAMES_ROW`(=1)` if row index is required; XPRS_NAMES_COLUMN`(=2)` if column index is required; XPRS_NAMES_SET`(=3)` if set index is required; XPRS_NAMES_PWLCONS`(=4)` if piecewise linear constraint index is required; XPRS_NAMES_GENCONS`(=5)` if general constraint index is required; XPRS_NAMES_OBJECTIVE`(=6)` if objective index is required; XPRS_NAMES_USERFUNC`(=7)` if user function index is required; XPRS_NAMES_INTERNALFUNC`(=8)` if an internal function index is required.
- `name::Union{Nothing,AbstractString}`: Null terminated string.
# Return value
- `index::Int32`: Pointer of the integer where the row or column index number will be returned.

See also the documentation of the correponding function [XPRSgetindex](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetindex.html) in the C API.
"""
function XPRSgetindex(prob::XPRSprob, type, name::Union{Nothing,AbstractString})::Int32
  typexx = Int32(type)
  if isnothing(name)
    name_pass = C_NULL
  else
    name_pass = name
  end
  p_index_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetindex")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring,Ref{Cint}), prob.handle, typexx, name_pass, p_index_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_index = p_index_dummy[]
  p_index
end
export XPRSgetindex

"""
    XPRSsetobjintcontrol(prob, objidx, control, value)::prob

Sets the value of a given integer control parameter associated with an objective.

These parameters control how the objective is treated during multi-objective optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective to modify.
- `control::XPRSObjControl`: Control parameter whose value is to be modified.
- `value::Integer`: Value to which the control parameter is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetobjintcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetobjintcontrol.html) in the C API.
"""
function XPRSsetobjintcontrol(prob::XPRSprob, objidx, control, value)::XPRSprob
  objidxxx = Int32(objidx)
  valuexx = Int32(value)
  faddr = getFunctionAddress("XPRSsetobjintcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint), prob.handle, objidxxx, Int32(control), valuexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetobjintcontrol

"""
    XPRSsetobjdblcontrol(prob, objidx, control, value)::prob

Sets the value of a given double control parameter associated with an objective.

These parameters control how the objective is treated during multi-objective optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective to modify.
- `control::XPRSObjControl`: Control parameter whose value is to be modified.
- `value::Float64`: Value to which the control parameter is to be set.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSsetobjdblcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsetobjdblcontrol.html) in the C API.
"""
function XPRSsetobjdblcontrol(prob::XPRSprob, objidx, control, value)::XPRSprob
  objidxxx = Int32(objidx)
  faddr = getFunctionAddress("XPRSsetobjdblcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cdouble), prob.handle, objidxxx, Int32(control), Float64(value))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSsetobjdblcontrol

"""
    XPRSgetobjintcontrol(prob, objidx, control)::value

Retrieves the value of a given integer control parameter associated with an objective.

These parameters control how the objective is treated during multi-objective optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective to query.
- `control::XPRSObjControl`: Control parameter whose value is to be returned.
# Return value
- `value::Int32`: Pointer to an integer where the control value will be returned.

See also the documentation of the correponding function [XPRSgetobjintcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjintcontrol.html) in the C API.
"""
function XPRSgetobjintcontrol(prob::XPRSprob, objidx, control)::Int32
  objidxxx = Int32(objidx)
  p_value_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetobjintcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint}), prob.handle, objidxxx, Int32(control), p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetobjintcontrol

"""
    XPRSgetobjdblcontrol(prob, objidx, control)::value

Retrieves the value of a given double control parameter associated with an objective function.

These parameters control how the objective is treated during multi-objective optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective to query.
- `control::XPRSObjControl`: Control parameter whose value is to be returned.
# Return value
- `value::Float64`: Pointer to a double where the control value will be returned.

See also the documentation of the correponding function [XPRSgetobjdblcontrol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjdblcontrol.html) in the C API.
"""
function XPRSgetobjdblcontrol(prob::XPRSprob, objidx, control)::Float64
  objidxxx = Int32(objidx)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetobjdblcontrol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, objidxxx, Int32(control), p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetobjdblcontrol

"""
    XPRSgetobjintattrib(prob, solveidx, attrib)::value

Retrieves the value of a given integer attribute associated with a multi-objective solve.

When solving a multi-objective problem, several objectives might be optimized in sequence. After each solve, the problem attributes are captured so that they can be queried afterwards.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solveidx::Integer`: Index of the solve to query.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Int32`: Pointer to an integer where attribute value will be returned.

See also the documentation of the correponding function [XPRSgetobjintattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjintattrib.html) in the C API.
"""
function XPRSgetobjintattrib(prob::XPRSprob, solveidx, attrib)::Int32
  solveidxxx = Int32(solveidx)
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetobjintattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint}), prob.handle, solveidxxx, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetobjintattrib

"""
    XPRSgetobjintattrib64(prob, solveidx, attrib)::value

Retrieves the value of a given integer attribute associated with a multi-objective solve.

When solving a multi-objective problem, several objectives might be optimized in sequence. After each solve, the problem attributes are captured so that they can be queried afterwards.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solveidx::Integer`: Index of the solve to query.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Int64`: Pointer to an integer where attribute value will be returned.

See also the documentation of the correponding function [XPRSgetobjintattrib64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjintattrib64.html) in the C API.
"""
function XPRSgetobjintattrib64(prob::XPRSprob, solveidx, attrib)::Int64
  solveidxxx = Int32(solveidx)
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Int64}(0)
  faddr = getFunctionAddress("XPRSgetobjintattrib64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Clonglong}), prob.handle, solveidxxx, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetobjintattrib64

"""
    XPRSgetobjdblattrib(prob, solveidx, attrib)::value

Retrieves the value of a given double attribute associated with a multi-objective solve.

When solving a multi-objective problem, several objectives might be optimized in sequence. After each solve, the problem attributes are captured so that they can be queried afterwards.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solveidx::Integer`: Index of the solve to query.
- `attrib::Integer`: Problem attribute whose value is to be returned.
# Return value
- `value::Float64`: Pointer to a double where attribute value will be returned.

See also the documentation of the correponding function [XPRSgetobjdblattrib](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjdblattrib.html) in the C API.
"""
function XPRSgetobjdblattrib(prob::XPRSprob, solveidx, attrib)::Float64
  solveidxxx = Int32(solveidx)
  attribxx = Int32(attrib)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetobjdblattrib")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, solveidxxx, attribxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSgetobjdblattrib

"""
    XPRSgetqobj(prob, objqcol1, objqcol2)::objqcoef

Returns a single quadratic objective function coefficient corresponding to the variable pair ` (objqcol1, objqcol2)` of the Hessian matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objqcol1::Integer`: Column index for the first variable in the quadratic term.
- `objqcol2::Integer`: Column index for the second variable in the quadratic term.
# Return value
- `objqcoef::Float64`: Pointer to a double value where the objective function coefficient is to be placed.

See also the documentation of the correponding function [XPRSgetqobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetqobj.html) in the C API.
"""
function XPRSgetqobj(prob::XPRSprob, objqcol1, objqcol2)::Float64
  objqcol1xx = Int32(objqcol1)
  objqcol2xx = Int32(objqcol2)
  p_objqcoef_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetqobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, objqcol1xx, objqcol2xx, p_objqcoef_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_objqcoef = p_objqcoef_dummy[]
  p_objqcoef
end
export XPRSgetqobj

"""
    XPRSgetdirs(prob, indices, prios, branchdirs, uppseudo, downpseudo)::ndir, indices, prios, branchdirs, uppseudo, downpseudo

Used to return the directives that have been loaded into a matrix.

Priorities, forced branching directions and pseudo costs can be returned. If called after presolve, ` XPRSgetdirs` will get the directives for the presolved problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `indices::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndir` containing the column numbers (`0`, `1`, `2`,...) or negative values corresponding to special ordered sets (the first set numbered `-1`, the second numbered `-2`,...).
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `prios::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `ndir` containing the priorities for the columns and sets, where columns/sets with smallest priority will be branched on first.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `branchdirs::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `ndir` specifying the branching direction for each column or set: Uthe entity is to be forced up; Dthe entity is to be forced down; Nnot specified.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `uppseudo::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ndir` containing the up pseudo costs for the columns and sets.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `downpseudo::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ndir` containing the down pseudo costs for the columns and sets.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ndir::Int32`: Pointer to an integer where the number of directives will be returned.
- `indices::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndir` containing the column numbers (`0`, `1`, `2`,...) or negative values corresponding to special ordered sets (the first set numbered `-1`, the second numbered `-2`,...).
- `prios::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `ndir` containing the priorities for the columns and sets, where columns/sets with smallest priority will be branched on first.
- `branchdirs::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `ndir` specifying the branching direction for each column or set: Uthe entity is to be forced up; Dthe entity is to be forced down; Nnot specified.
- `uppseudo::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ndir` containing the up pseudo costs for the columns and sets.
- `downpseudo::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ndir` containing the down pseudo costs for the columns and sets.

See also the documentation of the correponding function [XPRSgetdirs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetdirs.html) in the C API.
"""
function XPRSgetdirs(prob::XPRSprob, indices::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, prios::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, branchdirs::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, uppseudo::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, downpseudo::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  p_ndir_dummy = Ref{Int32}(0)
  if isa(branchdirs, XPRSallocatable)
    branchdirs = Vector{Cchar}(undef, XPRSgetintattrib(prob, 1003))
  elseif branchdirs != nothing
    if length(branchdirs) < XPRSgetintattrib(prob, 1003)
      throw(XPRSexception("Argument branchdirs is too short, needs " * (XPRSgetintattrib(prob, 1003)) * " elements but has only " * length(branchdirs), nothing))
    end
  end
  if isa(downpseudo, XPRSallocatable)
    downpseudo = Vector{Float64}(undef, XPRSgetintattrib(prob, 1003))
  elseif downpseudo != nothing
    if length(downpseudo) < XPRSgetintattrib(prob, 1003)
      throw(XPRSexception("Argument downpseudo is too short, needs " * (XPRSgetintattrib(prob, 1003)) * " elements but has only " * length(downpseudo), nothing))
    end
  end
  if isa(indices, XPRSallocatable)
    indices = Vector{Int32}(undef, XPRSgetintattrib(prob, 1003))
  elseif indices != nothing
    if length(indices) < XPRSgetintattrib(prob, 1003)
      throw(XPRSexception("Argument indices is too short, needs " * (XPRSgetintattrib(prob, 1003)) * " elements but has only " * length(indices), nothing))
    end
  end
  if isa(prios, XPRSallocatable)
    prios = Vector{Int32}(undef, XPRSgetintattrib(prob, 1003))
  elseif prios != nothing
    if length(prios) < XPRSgetintattrib(prob, 1003)
      throw(XPRSexception("Argument prios is too short, needs " * (XPRSgetintattrib(prob, 1003)) * " elements but has only " * length(prios), nothing))
    end
  end
  if isa(uppseudo, XPRSallocatable)
    uppseudo = Vector{Float64}(undef, XPRSgetintattrib(prob, 1003))
  elseif uppseudo != nothing
    if length(uppseudo) < XPRSgetintattrib(prob, 1003)
      throw(XPRSexception("Argument uppseudo is too short, needs " * (XPRSgetintattrib(prob, 1003)) * " elements but has only " * length(uppseudo), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetdirs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, p_ndir_dummy, isnothing(indices) ? C_NULL : indices, isnothing(prios) ? C_NULL : prios, isnothing(branchdirs) ? C_NULL : branchdirs, isnothing(uppseudo) ? C_NULL : uppseudo, isnothing(downpseudo) ? C_NULL : downpseudo)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ndir = p_ndir_dummy[]
  p_ndir, indices, prios, branchdirs, uppseudo, downpseudo
end
export XPRSgetdirs

"""
    XPRSgetscale(prob, rowscale, colscale)::rowscale, colscale

Returns the the current scaling of the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowscale::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of size ROWS that will contain the powers of `2` with which the rows are currently scaled.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colscale::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of size COLS that will contain the powers of `2` with which the columns are currently scaled.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `rowscale::Union{Nothing,AbstractVector{Int32}}`: Integer array of size ROWS that will contain the powers of `2` with which the rows are currently scaled.
- `colscale::Union{Nothing,AbstractVector{Int32}}`: Integer array of size COLS that will contain the powers of `2` with which the columns are currently scaled.

See also the documentation of the correponding function [XPRSgetscale](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetscale.html) in the C API.
"""
function XPRSgetscale(prob::XPRSprob, rowscale::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colscale::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  if isa(colscale, XPRSallocatable)
    colscale = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif colscale != nothing
    if length(colscale) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument colscale is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(colscale), nothing))
    end
  end
  if isa(rowscale, XPRSallocatable)
    rowscale = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif rowscale != nothing
    if length(rowscale) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument rowscale is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(rowscale), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetscale")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(rowscale) ? C_NULL : rowscale, isnothing(colscale) ? C_NULL : colscale)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rowscale, colscale
end
export XPRSgetscale

"""
    XPRSgetpivotorder(prob, pivotorder)::pivotorder

Returns the pivot order of the basic variables.

# Arguments
- `prob::XPRSprob`: The current problem.
- `pivotorder::Union{XPRSallocatable,AbstractVector{Int32}}`: Integer array of length ROWS where the pivot order will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `pivotorder::AbstractVector{Int32}`: Integer array of length ROWS where the pivot order will be returned.

See also the documentation of the correponding function [XPRSgetpivotorder](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpivotorder.html) in the C API.
"""
function XPRSgetpivotorder(prob::XPRSprob, pivotorder::Union{XPRSallocatable,AbstractVector{Int32}})::AbstractVector{Int32}
  if isa(pivotorder, XPRSallocatable)
    pivotorder = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif pivotorder != nothing
    if length(pivotorder) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument pivotorder is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(pivotorder), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpivotorder")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint}), prob.handle, isnothing(pivotorder) ? C_NULL : pivotorder)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  pivotorder
end
export XPRSgetpivotorder

"""
    XPRSgetpresolvemap(prob, rowmap, colmap)::rowmap, colmap

Returns the mapping of the row and column numbers from the presolve problem back to the original problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowmap::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length ROWS where the row maps will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colmap::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length COLS where the column maps will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `rowmap::Union{Nothing,AbstractVector{Int32}}`: Integer array of length ROWS where the row maps will be returned.
- `colmap::Union{Nothing,AbstractVector{Int32}}`: Integer array of length COLS where the column maps will be returned.

See also the documentation of the correponding function [XPRSgetpresolvemap](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpresolvemap.html) in the C API.
"""
function XPRSgetpresolvemap(prob::XPRSprob, rowmap::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colmap::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  if isa(colmap, XPRSallocatable)
    colmap = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif colmap != nothing
    if length(colmap) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument colmap is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(colmap), nothing))
    end
  end
  if isa(rowmap, XPRSallocatable)
    rowmap = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif rowmap != nothing
    if length(rowmap) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument rowmap is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(rowmap), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpresolvemap")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(rowmap) ? C_NULL : rowmap, isnothing(colmap) ? C_NULL : colmap)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rowmap, colmap
end
export XPRSgetpresolvemap

"""
    XPRSbtran(prob, vec)::vec

Post-multiplies a (row) vector provided by the user by the inverse of the current basis.

# Arguments
- `prob::XPRSprob`: The current problem.
- `vec::AbstractVector{Float64}`: Double array of length ROWS containing the values by which the basis inverse is to be multiplied.
# Return value
- `vec::AbstractVector{Float64}`: Double array of length ROWS containing the values by which the basis inverse is to be multiplied.

See also the documentation of the correponding function [XPRSbtran](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSbtran.html) in the C API.
"""
function XPRSbtran(prob::XPRSprob, vec::AbstractVector{Float64})::AbstractVector{Float64}
  faddr = getFunctionAddress("XPRSbtran")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble}), prob.handle, isnothing(vec) ? C_NULL : vec)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  vec
end
export XPRSbtran

"""
    XPRSftran(prob, vec)::vec

Pre-multiplies a (column) vector provided by the user by the inverse of the current matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `vec::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be multiplied by the basis inverse.
# Return value
- `vec::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be multiplied by the basis inverse.

See also the documentation of the correponding function [XPRSftran](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSftran.html) in the C API.
"""
function XPRSftran(prob::XPRSprob, vec::AbstractVector{Float64})::AbstractVector{Float64}
  faddr = getFunctionAddress("XPRSftran")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble}), prob.handle, isnothing(vec) ? C_NULL : vec)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  vec
end
export XPRSftran

"""
    XPRSsparsebtran(prob, val, ind)::val, ind, ncoefs

Post-multiplies a (row) vector provided by the user by the inverse of the current matrix.

Sparse version of XPRSbtran.

# Arguments
- `prob::XPRSprob`: The current problem.
- `val::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be post-multiplied by the basis inverse.
- `ind::AbstractVector{Int32}`: Integer array of indices identifying the non-zero entries of `val`.
# Return values
- `val::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be post-multiplied by the basis inverse.
- `ind::AbstractVector{Int32}`: Integer array of indices identifying the non-zero entries of `val`.
- `ncoefs::Int32`: Memory location where the number of non-zero entries is given.

See also the documentation of the correponding function [XPRSsparsebtran](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsparsebtran.html) in the C API.
"""
function XPRSsparsebtran(prob::XPRSprob, val::AbstractVector{Float64}, ind::AbstractVector{Int32})::Tuple{AbstractVector{Float64},AbstractVector{Int32},Int32}
  p_ncoefs_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSsparsebtran")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cint},Ref{Cint}), prob.handle, isnothing(val) ? C_NULL : val, isnothing(ind) ? C_NULL : ind, p_ncoefs_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  val, ind, p_ncoefs
end
export XPRSsparsebtran

"""
    XPRSsparseftran(prob, val, ind)::val, ind, ncoefs

Pre-multiplies a (column) vector provided by the user by the inverse of the current matrix.

Sparse version of XPRSftran.

# Arguments
- `prob::XPRSprob`: The current problem.
- `val::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be multiplied by the basis inverse.
- `ind::AbstractVector{Int32}`: Integer array of indices identifying the non-zero entries of `val`.
# Return values
- `val::AbstractVector{Float64}`: Double array of length ROWS containing the values which are to be multiplied by the basis inverse.
- `ind::AbstractVector{Int32}`: Integer array of indices identifying the non-zero entries of `val`.
- `ncoefs::Int32`: Memory location where the number of non-zero entries is given.

See also the documentation of the correponding function [XPRSsparseftran](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSsparseftran.html) in the C API.
"""
function XPRSsparseftran(prob::XPRSprob, val::AbstractVector{Float64}, ind::AbstractVector{Int32})::Tuple{AbstractVector{Float64},AbstractVector{Int32},Int32}
  p_ncoefs_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSsparseftran")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cint},Ref{Cint}), prob.handle, isnothing(val) ? C_NULL : val, isnothing(ind) ? C_NULL : ind, p_ncoefs_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  val, ind, p_ncoefs
end
export XPRSsparseftran

"""
    XPRSgetobj(prob, objcoef, first, last)::objcoef

Returns the objective function coefficients for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objcoef::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the objective function coefficients are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return value
- `objcoef::AbstractVector{Float64}`: Double array of length `last-first+1` where the objective function coefficients are to be placed.

See also the documentation of the correponding function [XPRSgetobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobj.html) in the C API.
"""
function XPRSgetobj(prob::XPRSprob, objcoef::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(objcoef, XPRSallocatable)
    objcoef = Vector{Float64}(undef, last - first + 1)
  elseif objcoef != nothing
    if length(objcoef) < last - first + 1
      throw(XPRSexception("Argument objcoef is too short, needs " * (last - first + 1) * " elements but has only " * length(objcoef), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Cint,Cint), prob.handle, isnothing(objcoef) ? C_NULL : objcoef, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  objcoef
end
export XPRSgetobj

"""
    XPRSgetobjn(prob, objidx, objcoef, first, last)::objcoef

For a given objective function, returns the objective coefficients for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective function whose coefficients to return.
- `objcoef::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the objective function coefficients are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return value
- `objcoef::AbstractVector{Float64}`: Double array of length `last-first+1` where the objective function coefficients are to be placed.

See also the documentation of the correponding function [XPRSgetobjn](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetobjn.html) in the C API.
"""
function XPRSgetobjn(prob::XPRSprob, objidx, objcoef::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  objidxxx = Int32(objidx)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(objcoef, XPRSallocatable)
    objcoef = Vector{Float64}(undef, last - first + 1)
  elseif objcoef != nothing
    if length(objcoef) < last - first + 1
      throw(XPRSexception("Argument objcoef is too short, needs " * (last - first + 1) * " elements but has only " * length(objcoef), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetobjn")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cdouble},Cint,Cint), prob.handle, objidxxx, isnothing(objcoef) ? C_NULL : objcoef, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  objcoef
end
export XPRSgetobjn

"""
    XPRSgetrhs(prob, rhs, first, last)::rhs

Returns the right hand side elements for the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rhs::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the right hand side elements are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range.
# Return value
- `rhs::AbstractVector{Float64}`: Double array of length `last-first+1` where the right hand side elements are to be placed.

See also the documentation of the correponding function [XPRSgetrhs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrhs.html) in the C API.
"""
function XPRSgetrhs(prob::XPRSprob, rhs::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(rhs, XPRSallocatable)
    rhs = Vector{Float64}(undef, last - first + 1)
  elseif rhs != nothing
    if length(rhs) < last - first + 1
      throw(XPRSexception("Argument rhs is too short, needs " * (last - first + 1) * " elements but has only " * length(rhs), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetrhs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Cint,Cint), prob.handle, isnothing(rhs) ? C_NULL : rhs, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rhs
end
export XPRSgetrhs

"""
    XPRSgetrhsrange(prob, rng, first, last)::rng

Returns the right hand side range values for the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rng::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the right hand side range values are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range.
# Return value
- `rng::AbstractVector{Float64}`: Double array of length `last-first+1` where the right hand side range values are to be placed.

See also the documentation of the correponding function [XPRSgetrhsrange](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrhsrange.html) in the C API.
"""
function XPRSgetrhsrange(prob::XPRSprob, rng::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(rng, XPRSallocatable)
    rng = Vector{Float64}(undef, last - first + 1)
  elseif rng != nothing
    if length(rng) < last - first + 1
      throw(XPRSexception("Argument rng is too short, needs " * (last - first + 1) * " elements but has only " * length(rng), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetrhsrange")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Cint,Cint), prob.handle, isnothing(rng) ? C_NULL : rng, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rng
end
export XPRSgetrhsrange

"""
    XPRSgetlb(prob, lb, first, last)::lb

Returns the lower bounds for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `lb::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the lower bounds are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return value
- `lb::AbstractVector{Float64}`: Double array of length `last-first+1` where the lower bounds are to be placed.

See also the documentation of the correponding function [XPRSgetlb](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetlb.html) in the C API.
"""
function XPRSgetlb(prob::XPRSprob, lb::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(lb, XPRSallocatable)
    lb = Vector{Float64}(undef, last - first + 1)
  elseif lb != nothing
    if length(lb) < last - first + 1
      throw(XPRSexception("Argument lb is too short, needs " * (last - first + 1) * " elements but has only " * length(lb), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetlb")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Cint,Cint), prob.handle, isnothing(lb) ? C_NULL : lb, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  lb
end
export XPRSgetlb

"""
    XPRSgetub(prob, ub, first, last)::ub

Returns the upper bounds for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ub::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the upper bounds are to be placed.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return value
- `ub::AbstractVector{Float64}`: Double array of length `last-first+1` where the upper bounds are to be placed.

See also the documentation of the correponding function [XPRSgetub](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetub.html) in the C API.
"""
function XPRSgetub(prob::XPRSprob, ub::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::AbstractVector{Float64}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(ub, XPRSallocatable)
    ub = Vector{Float64}(undef, last - first + 1)
  elseif ub != nothing
    if length(ub) < last - first + 1
      throw(XPRSexception("Argument ub is too short, needs " * (last - first + 1) * " elements but has only " * length(ub), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetub")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Cint,Cint), prob.handle, isnothing(ub) ? C_NULL : ub, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  ub
end
export XPRSgetub

"""
    XPRSgetcols(prob, start, rowind, rowcoef, maxcoefs, first, last)::start, rowind, rowcoef, ncoefs

Returns the nonzeros in the constraint matrix for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int32}`: Integer array which will be filled with the indices indicating the starting offsets in the `rowind` and `rowcoef` arrays for each requested column.
- `rowind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the row indices of the nonzero coefficents for each column.
- `rowcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero coefficient values.
- `maxcoefs::Integer`: The size of the `rowind` and `rowcoef` arrays.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return values
- `start::AbstractVector{Int32}`: Integer array which will be filled with the indices indicating the starting offsets in the `rowind` and `rowcoef` arrays for each requested column.
- `rowind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the row indices of the nonzero coefficents for each column.
- `rowcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero coefficient values.
- `ncoefs::Int32`: Pointer to an integer where the number of nonzero coefficients in the selected columns will be returned.

See also the documentation of the correponding function [XPRSgetcols](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcols.html) in the C API.
"""
function XPRSgetcols(prob::XPRSprob, start::AbstractVector{Int32}, rowind::AbstractVector{Int32}, rowcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64},Int32}
  maxcoefsxx = Int32(maxcoefs)
  p_ncoefs_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetcols")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(rowind) ? C_NULL : rowind, isnothing(rowcoef) ? C_NULL : rowcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, rowind, rowcoef, p_ncoefs
end
export XPRSgetcols

"""
    XPRSgetcols64(prob, start, rowind, rowcoef, maxcoefs, first, last)::start, rowind, rowcoef, ncoefs

Returns the nonzeros in the constraint matrix for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int64}`: Integer array which will be filled with the indices indicating the starting offsets in the `rowind` and `rowcoef` arrays for each requested column.
- `rowind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the row indices of the nonzero coefficents for each column.
- `rowcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero coefficient values.
- `maxcoefs::Integer`: The size of the `rowind` and `rowcoef` arrays.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return values
- `start::AbstractVector{Int64}`: Integer array which will be filled with the indices indicating the starting offsets in the `rowind` and `rowcoef` arrays for each requested column.
- `rowind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the row indices of the nonzero coefficents for each column.
- `rowcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero coefficient values.
- `ncoefs::Int64`: Pointer to an integer where the number of nonzero coefficients in the selected columns will be returned.

See also the documentation of the correponding function [XPRSgetcols64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcols64.html) in the C API.
"""
function XPRSgetcols64(prob::XPRSprob, start::AbstractVector{Int64}, rowind::AbstractVector{Int32}, rowcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int64},AbstractVector{Int32},AbstractVector{Float64},Int64}
  maxcoefsxx = Int64(maxcoefs)
  p_ncoefs_dummy = Ref{Int64}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetcols64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble},Clonglong,Ref{Clonglong},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(rowind) ? C_NULL : rowind, isnothing(rowcoef) ? C_NULL : rowcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, rowind, rowcoef, p_ncoefs
end
export XPRSgetcols64

"""
    XPRSgetrows(prob, start, colind, colcoef, maxcoefs, first, last)::start, colind, colcoef, ncoefs

Returns the nonzeros in the constraint matrix for the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int32}`: Integer array which will be filled with the indices indicating the starting offsets in the `colind` and `colcoef` arrays for each requested row.
- `colind::AbstractVector{Int32}`: Integer arrays of length `maxcoefs` which will be filled with the column indices of the nonzero elements for each row.
- `colcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `maxcoefs::Integer`: Maximum number of elements to be retrieved.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range.
# Return values
- `start::AbstractVector{Int32}`: Integer array which will be filled with the indices indicating the starting offsets in the `colind` and `colcoef` arrays for each requested row.
- `colind::AbstractVector{Int32}`: Integer arrays of length `maxcoefs` which will be filled with the column indices of the nonzero elements for each row.
- `colcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `ncoefs::Int32`: Pointer to the integer where the number of nonzero elements in the selected rows will be returned.

See also the documentation of the correponding function [XPRSgetrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrows.html) in the C API.
"""
function XPRSgetrows(prob::XPRSprob, start::AbstractVector{Int32}, colind::AbstractVector{Int32}, colcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64},Int32}
  maxcoefsxx = Int32(maxcoefs)
  p_ncoefs_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(colcoef) ? C_NULL : colcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, colind, colcoef, p_ncoefs
end
export XPRSgetrows

"""
    XPRSgetrows64(prob, start, colind, colcoef, maxcoefs, first, last)::start, colind, colcoef, ncoefs

Returns the nonzeros in the constraint matrix for the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int64}`: Integer array which will be filled with the indices indicating the starting offsets in the `colind` and `colcoef` arrays for each requested row.
- `colind::AbstractVector{Int32}`: Integer arrays of length `maxcoefs` which will be filled with the column indices of the nonzero elements for each row.
- `colcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `maxcoefs::Integer`: Maximum number of elements to be retrieved.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range.
# Return values
- `start::AbstractVector{Int64}`: Integer array which will be filled with the indices indicating the starting offsets in the `colind` and `colcoef` arrays for each requested row.
- `colind::AbstractVector{Int32}`: Integer arrays of length `maxcoefs` which will be filled with the column indices of the nonzero elements for each row.
- `colcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `ncoefs::Int64`: Pointer to the integer where the number of nonzero elements in the selected rows will be returned.

See also the documentation of the correponding function [XPRSgetrows64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrows64.html) in the C API.
"""
function XPRSgetrows64(prob::XPRSprob, start::AbstractVector{Int64}, colind::AbstractVector{Int32}, colcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int64},AbstractVector{Int32},AbstractVector{Float64},Int64}
  maxcoefsxx = Int64(maxcoefs)
  p_ncoefs_dummy = Ref{Int64}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetrows64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble},Clonglong,Ref{Clonglong},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(colcoef) ? C_NULL : colcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, colind, colcoef, p_ncoefs
end
export XPRSgetrows64

"""
    XPRSgetrowflags(prob, flags, first, last)::flags

Retrieve if a range of rows have been set up as special rows.

# Arguments
- `prob::XPRSprob`: The current problem
- `flags::Union{XPRSallocatable,AbstractVector{Int32}}`: Int array of length `last-first+1` where type of information (see below) will be returned
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row index to be checked
- `last::Integer`: Last row index to be checked
# Return value
- `flags::AbstractVector{Int32}`: Int array of length `last-first+1` where type of information (see below) will be returned

See also the documentation of the correponding function [XPRSgetrowflags](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrowflags.html) in the C API.
"""
function XPRSgetrowflags(prob::XPRSprob, flags::Union{XPRSallocatable,AbstractVector{Int32}}, first, last)::AbstractVector{Int32}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(flags, XPRSallocatable)
    flags = Vector{Int32}(undef, last - first + 1)
  elseif flags != nothing
    if length(flags) < last - first + 1
      throw(XPRSexception("Argument flags is too short, needs " * (last - first + 1) * " elements but has only " * length(flags), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetrowflags")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Cint,Cint), prob.handle, isnothing(flags) ? C_NULL : flags, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  flags
end
export XPRSgetrowflags

"""
    XPRSclearrowflags(prob, flags, first, last)::prob

Clears extra information attached to a range of rows.

# Arguments
- `prob::XPRSprob`: The current problem
- `flags::AbstractVector{Integer}`: Int array of length `last-first+1` including type of extra information to remove (see below)
- `first::Integer`: First row index to be checked
- `last::Integer`: Last row index to be checked
# Return value
- `prob::XPRSprob`: The current problem

See also the documentation of the correponding function [XPRSclearrowflags](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSclearrowflags.html) in the C API.
"""
function XPRSclearrowflags(prob::XPRSprob, flags, first, last)::XPRSprob
  if isnothing(flags) || length(flags) == 0
    c_flags = nothing
  elseif isa(flags, AbstractVector{Int32})
    c_flags = flags
  else
    c_flags = convert(Vector{Int32}, flags)
  end
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSclearrowflags")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Cint,Cint), prob.handle, isnothing(c_flags) ? C_NULL : c_flags, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSclearrowflags

"""
    XPRSgetcoef(prob, row, col)::coef

Returns a single coefficient in the constraint matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Row of the constraint matrix.
- `col::Integer`: Column of the constraint matrix.
# Return value
- `coef::Float64`: Pointer to a double where the coefficient will be returned.

See also the documentation of the correponding function [XPRSgetcoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcoef.html) in the C API.
"""
function XPRSgetcoef(prob::XPRSprob, row, col)::Float64
  rowxx = Int32(row)
  colxx = Int32(col)
  p_coef_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetcoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, rowxx, colxx, p_coef_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_coef = p_coef_dummy[]
  p_coef
end
export XPRSgetcoef

"""
    XPRSgetmqobj(prob, start, colind, objqcoef, maxcoefs, first, last)::start, colind, objqcoef, ncoefs

Returns the nonzeros in the quadratic objective coefficients matrix for the columns in a given range.

To achieve maximum efficiency, `XPRSgetmqobj` returns the lower triangular part of this matrix only.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int32}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `objqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the column indices of the nonzero elements in the lower triangular part of `Q`.
- `objqcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `maxcoefs::Integer`: The maximum number of elements to be returned (size of the arrays).
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return values
- `start::AbstractVector{Int32}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `objqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the column indices of the nonzero elements in the lower triangular part of `Q`.
- `objqcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `ncoefs::Int32`: Pointer to an integer where the number of nonzero quadratic objective coefficients will be returned.

See also the documentation of the correponding function [XPRSgetmqobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmqobj.html) in the C API.
"""
function XPRSgetmqobj(prob::XPRSprob, start::AbstractVector{Int32}, colind::AbstractVector{Int32}, objqcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64},Int32}
  maxcoefsxx = Int32(maxcoefs)
  p_ncoefs_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetmqobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(objqcoef) ? C_NULL : objqcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, colind, objqcoef, p_ncoefs
end
export XPRSgetmqobj

"""
    XPRSgetmqobj64(prob, start, colind, objqcoef, maxcoefs, first, last)::start, colind, objqcoef, ncoefs

Returns the nonzeros in the quadratic objective coefficients matrix for the columns in a given range.

To achieve maximum efficiency, `XPRSgetmqobj` returns the lower triangular part of this matrix only.

# Arguments
- `prob::XPRSprob`: The current problem.
- `start::AbstractVector{Int64}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `objqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the column indices of the nonzero elements in the lower triangular part of `Q`.
- `objqcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `maxcoefs::Integer`: The maximum number of elements to be returned (size of the arrays).
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return values
- `start::AbstractVector{Int64}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `objqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` which will be filled with the column indices of the nonzero elements in the lower triangular part of `Q`.
- `objqcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` which will be filled with the nonzero element values.
- `ncoefs::Int64`: Pointer to an integer where the number of nonzero quadratic objective coefficients will be returned.

See also the documentation of the correponding function [XPRSgetmqobj64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmqobj64.html) in the C API.
"""
function XPRSgetmqobj64(prob::XPRSprob, start::AbstractVector{Int64}, colind::AbstractVector{Int32}, objqcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int64},AbstractVector{Int32},AbstractVector{Float64},Int64}
  maxcoefsxx = Int64(maxcoefs)
  p_ncoefs_dummy = Ref{Int64}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetmqobj64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble},Clonglong,Ref{Clonglong},Cint,Cint), prob.handle, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(objqcoef) ? C_NULL : objqcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, colind, objqcoef, p_ncoefs
end
export XPRSgetmqobj64

"""
    XPRSwritebasis(prob, filename, flags)::prob

Writes the current basis to a file for later input into the Optimizer.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name from which the basis is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSwritebasis` (`WRITEBASIS`): scrambled vector names; output values in hexadecimal; output in a format compatible with CPLEX; ioutput the internal presolved basis; toutput a compact advanced form of the basis; noutput basis file containing current solution values; houtput values in single precision; poutput values in full precision (obsolete as this is now default behavior); vuse the provided filename verbatim, without appending the `.bss` extension; zcompress the output file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwritebasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwritebasis.html) in the C API.
"""
function XPRSwritebasis(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwritebasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwritebasis

"""
    XPRSwritesol(prob, filename, flags)::prob

Writes the current solution to a CSV format ASCII file, problem_name`.asc` (and `.hdr`).

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the solution is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags to control which optional fields are output: ssequence number; nname; ttype; bbasis status; aactivity; ccost (columns), slack (rows); llower bound; uupper bound; ddj (column; reduced costs), dual value (rows; shadow prices); rright hand side (rows).If no flags are specified, all fields are output.Additional flags: poutputs in full precision; qonly outputs vectors with nonzero optimum value; xoutput the current LP solution instead of the MIP solution; zcompress the output file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwritesol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwritesol.html) in the C API.
"""
function XPRSwritesol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwritesol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwritesol

"""
    XPRSwritebinsol(prob, filename, flags)::prob

Writes the current MIP or LP solution to a binary solution file for later input into the Optimizer.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the solution is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSwritebinsol` (`WRITEBINSOL`): moutput the MIP solution; xoutput the LP solution; vuse the provided filename verbatim, without appending the `.sol` extension; zcompress the output file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwritebinsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwritebinsol.html) in the C API.
"""
function XPRSwritebinsol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwritebinsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwritebinsol

"""
Wraps callable C library function XPRSgetsol:
"""
function XPRSgetsol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif duals != nothing
    if length(duals) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument duals is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  x, slack, duals, djs
end
export XPRSgetsol

"""
    XPRSwriteprtsol(prob, filename, flags)::prob

Writes the current solution to a fixed format ASCII file, problem_name `.prt`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the solution is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags for `XPRSwriteprtsol` (`WRITEPRTSOL`) are: print the solution to the screen (via the message callback) instead of writing to a file; xwrite the LP solution instead of the current MIP solution; vuse the provided filename verbatim, without appending the `.prt` extension; zwrite a compressed output file; sinclude classical sensitivity analysis.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwriteprtsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwriteprtsol.html) in the C API.
"""
function XPRSwriteprtsol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwriteprtsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwriteprtsol

"""
    XPRSwriteslxsol(prob, filename, flags)::prob

Creates an ASCII solution file (`.slx`) using a similar format to MPS files.

These files can be read back into the Optimizer using the XPRSreadslxsol function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters containing the file name to which the solution is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags to pass to `XPRSwriteslxsol` (`WRITESLXSOL`): lwrite the LP solution in case of a MIP problem; mwrite the MIP solution; puse full precision for numerical values (obsolete as this is now default behavior); sincluding slack variables; dLP solution only: including dual variables; rLP solution only: including reduced cost; vuse the provided filename verbatim, without appending the `.slx` extension; zcompress the output file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwriteslxsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwriteslxsol.html) in the C API.
"""
function XPRSwriteslxsol(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwriteslxsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwriteslxsol

"""
    XPRSgetprimalray(prob, ray)::ray, hasray

Retrieves a primal ray (primal unbounded direction) for the current problem, if the problem is found to be unbounded.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ray::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length COLS to hold the ray.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `ray::AbstractVector{Float64}`: Double array of length COLS to hold the ray.
- `hasray::Int32`: This variable will be set to 1 if the Optimizer is able to return a primal ray, 0 otherwise.

See also the documentation of the correponding function [XPRSgetprimalray](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetprimalray.html) in the C API.
"""
function XPRSgetprimalray(prob::XPRSprob, ray::Union{XPRSallocatable,AbstractVector{Float64}})::Tuple{AbstractVector{Float64},Int32}
  p_hasray_dummy = Ref{Int32}(0)
  if isa(ray, XPRSallocatable)
    ray = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif ray != nothing
    if length(ray) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument ray is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(ray), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetprimalray")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ref{Cint}), prob.handle, isnothing(ray) ? C_NULL : ray, p_hasray_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_hasray = p_hasray_dummy[]
  ray, p_hasray
end
export XPRSgetprimalray

"""
    XPRSgetdualray(prob, ray)::ray, hasray

Retrieves a dual ray (dual unbounded direction) for the current problem, if the problem is found to be infeasible.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ray::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length ROWS to hold the ray.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `ray::AbstractVector{Float64}`: Double array of length ROWS to hold the ray.
- `hasray::Int32`: This variable will be set to 1 if the Optimizer is able to return a dual ray, 0 otherwise.

See also the documentation of the correponding function [XPRSgetdualray](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetdualray.html) in the C API.
"""
function XPRSgetdualray(prob::XPRSprob, ray::Union{XPRSallocatable,AbstractVector{Float64}})::Tuple{AbstractVector{Float64},Int32}
  p_hasray_dummy = Ref{Int32}(0)
  if isa(ray, XPRSallocatable)
    ray = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif ray != nothing
    if length(ray) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument ray is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(ray), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetdualray")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ref{Cint}), prob.handle, isnothing(ray) ? C_NULL : ray, p_hasray_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_hasray = p_hasray_dummy[]
  ray, p_hasray
end
export XPRSgetdualray

"""
    XPRSloadmipsol(prob, x)::status

Loads a starting MIP solution for the problem into the Optimizer.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::AbstractVector{Number}`: Double array of length COLS (for the original problem and not the presolve problem) containing the values of the variables.
# Return value
- `status::Int32`: Pointer to an `int` where the status will be returned.

See also the documentation of the correponding function [XPRSloadmipsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadmipsol.html) in the C API.
"""
function XPRSloadmipsol(prob::XPRSprob, x)::Int32
  if isnothing(x) || length(x) == 0
    c_x = nothing
  elseif isa(x, AbstractVector{Float64})
    c_x = x
  else
    c_x = convert(Vector{Float64}, x)
  end
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSloadmipsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ref{Cint}), prob.handle, isnothing(c_x) ? C_NULL : c_x, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSloadmipsol

"""
    XPRSgetbasis(prob, rowstat, colstat)::rowstat, colstat

Returns the current basis into the user's data arrays.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length ORIGINALROWS to the basis status of the slack, surplus or artificial variable associated with each row.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length ORIGINALCOLS to hold the basis status of the columns in the constraint matrix.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `rowstat::Union{Nothing,AbstractVector{Int32}}`: Integer array of length ORIGINALROWS to the basis status of the slack, surplus or artificial variable associated with each row.
- `colstat::Union{Nothing,AbstractVector{Int32}}`: Integer array of length ORIGINALCOLS to hold the basis status of the columns in the constraint matrix.

See also the documentation of the correponding function [XPRSgetbasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetbasis.html) in the C API.
"""
function XPRSgetbasis(prob::XPRSprob, rowstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  if isa(colstat, XPRSallocatable)
    colstat = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif colstat != nothing
    if length(colstat) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument colstat is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(colstat), nothing))
    end
  end
  if isa(rowstat, XPRSallocatable)
    rowstat = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif rowstat != nothing
    if length(rowstat) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument rowstat is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(rowstat), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetbasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(rowstat) ? C_NULL : rowstat, isnothing(colstat) ? C_NULL : colstat)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rowstat, colstat
end
export XPRSgetbasis

"""
    XPRSgetbasisval(prob, row, col)::rowstat, colstat

Returns the current basis status for a specific column or row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Row index to get the row basis status for.
- `col::Integer`: Column index to get the column basis status for.
# Return values
- `rowstat::Int32`: Integer pointer where the value of the row basis status will be returned.
- `colstat::Int32`: Integer pointer where the value of the column basis status will be returned.

See also the documentation of the correponding function [XPRSgetbasisval](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetbasisval.html) in the C API.
"""
function XPRSgetbasisval(prob::XPRSprob, row, col)::Tuple{Int32,Int32}
  rowxx = Int32(row)
  colxx = Int32(col)
  p_rowstat_dummy = Ref{Int32}(0)
  p_colstat_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetbasisval")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint},Ref{Cint}), prob.handle, rowxx, colxx, p_rowstat_dummy, p_colstat_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_rowstat = p_rowstat_dummy[]
  p_colstat = p_colstat_dummy[]
  p_rowstat, p_colstat
end
export XPRSgetbasisval

"""
    XPRSaddcuts(prob, ncuts, cuttype, rowtype, rhs, start, colind, cutcoef)::prob

Adds cuts directly to the matrix at the current node.

The cuts will automatically be added to the cut pool. Cuts added to a node will automatically be inherited on any descendant node, unless explicitly deleted with a call to XPRSdelcuts.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncuts::Integer`: Number of cuts to add.
- `cuttype::AbstractVector{Integer}`: Integer array of length `ncuts` containing the user assigned cut types.
- `rowtype::AbstractVector{Cchar}`: Character array of length `ncuts` containing the row types: Lindicates a `<=` row; Gindicates a `>=` row; Eindicates an = row.
- `rhs::AbstractVector{Number}`: Double array of length `ncuts` containing the right hand side elements for the cuts.
- `start::AbstractVector{Integer}`: Integer array containing offset into the `colind` and `cutcoef` arrays indicating the start of each cut.
- `colind::AbstractVector{Integer}`: Integer array of length `start[ncuts]` containing the column indices in the cuts.
- `cutcoef::AbstractVector{Number}`: Double array of length `start[ncuts]` containing the matrix values for the cuts.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddcuts.html) in the C API.
"""
function XPRSaddcuts(prob::XPRSprob, ncuts, cuttype, rowtype, rhs, start, colind, cutcoef)::XPRSprob
  ncutsxx = Int32(ncuts)
  if isnothing(cuttype) || length(cuttype) == 0
    c_cuttype = nothing
  elseif isa(cuttype, AbstractVector{Int32})
    c_cuttype = cuttype
  else
    c_cuttype = convert(Vector{Int32}, cuttype)
  end
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(cutcoef) || length(cutcoef) == 0
    c_cutcoef = nothing
  elseif isa(cutcoef, AbstractVector{Float64})
    c_cutcoef = cutcoef
  else
    c_cutcoef = convert(Vector{Float64}, cutcoef)
  end
  faddr = getFunctionAddress("XPRSaddcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncutsxx, isnothing(c_cuttype) ? C_NULL : c_cuttype, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_cutcoef) ? C_NULL : c_cutcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddcuts

"""
    XPRSaddcuts64(prob, ncuts, cuttype, rowtype, rhs, start, colind, cutcoef)::prob

Adds cuts directly to the matrix at the current node.

The cuts will automatically be added to the cut pool. Cuts added to a node will automatically be inherited on any descendant node, unless explicitly deleted with a call to XPRSdelcuts.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncuts::Integer`: Number of cuts to add.
- `cuttype::AbstractVector{Integer}`: Integer array of length `ncuts` containing the user assigned cut types.
- `rowtype::AbstractVector{Cchar}`: Character array of length `ncuts` containing the row types: Lindicates a `<=` row; Gindicates a `>=` row; Eindicates an = row.
- `rhs::AbstractVector{Number}`: Double array of length `ncuts` containing the right hand side elements for the cuts.
- `start::AbstractVector{Integer}`: Integer array containing offset into the `colind` and `cutcoef` arrays indicating the start of each cut.
- `colind::AbstractVector{Integer}`: Integer array of length `start[ncuts]` containing the column indices in the cuts.
- `cutcoef::AbstractVector{Number}`: Double array of length `start[ncuts]` containing the matrix values for the cuts.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddcuts64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddcuts64.html) in the C API.
"""
function XPRSaddcuts64(prob::XPRSprob, ncuts, cuttype, rowtype, rhs, start, colind, cutcoef)::XPRSprob
  ncutsxx = Int32(ncuts)
  if isnothing(cuttype) || length(cuttype) == 0
    c_cuttype = nothing
  elseif isa(cuttype, AbstractVector{Int32})
    c_cuttype = cuttype
  else
    c_cuttype = convert(Vector{Int32}, cuttype)
  end
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(cutcoef) || length(cutcoef) == 0
    c_cutcoef = nothing
  elseif isa(cutcoef, AbstractVector{Float64})
    c_cutcoef = cutcoef
  else
    c_cutcoef = convert(Vector{Float64}, cutcoef)
  end
  faddr = getFunctionAddress("XPRSaddcuts64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncutsxx, isnothing(c_cuttype) ? C_NULL : c_cuttype, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_cutcoef) ? C_NULL : c_cutcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddcuts64

"""
    XPRSdelcuts(prob, basis, cuttype, interp, delta, ncuts, cutind)::prob

Deletes cuts from the matrix at the current node.

Cuts from the parent node which have been automatically restored may be deleted as well as cuts added to the current node using XPRSaddcuts or XPRSloadcuts. The cuts to be deleted can be specified in a number of ways. If a cut is ruled out by any one of the criteria it will not be deleted.

# Arguments
- `prob::XPRSprob`: The current problem.
- `basis::Integer`: Ensures the basis will be valid if set to `1`.
- `cuttype::Integer`: User defined type of the cut to be deleted.
- `interp::Integer`: Way in which the cut `cuttype` is interpreted: -1match all cut types; 1treat cut types as numbers; 2treat cut types as bit maps - delete if any bit matches any bit set in `cuttype`; 3treat cut types as bit maps - delete if all bits match those set in `cuttype`.
- `delta::Float64`: Only delete cuts with an absolute slack value greater than `delta`.
- `ncuts::Integer`: Number of cuts to drop if a list of cuts is provided.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array containing pointers to the cuts which are to be deleted.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelcuts.html) in the C API.
"""
function XPRSdelcuts(prob::XPRSprob, basis, cuttype, interp, delta, ncuts, cutind)::XPRSprob
  basisxx = Int32(basis)
  cuttypexx = Int32(cuttype)
  interpxx = Int32(interp)
  ncutsxx = Int32(ncuts)
  if isnothing(cutind) || length(cutind) == 0
    c_cutind = nothing
  elseif isa(cutind, AbstractVector{Ptr{Cvoid}})
    c_cutind = cutind
  else
    c_cutind = convert(Vector{Ptr{Cvoid}}, cutind)
  end
  faddr = getFunctionAddress("XPRSdelcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Cdouble,Cint,Ptr{Ptr{Cvoid}}), prob.handle, basisxx, cuttypexx, interpxx, Float64(delta), ncutsxx, isnothing(c_cutind) ? C_NULL : c_cutind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelcuts

"""
    XPRSdelcpcuts(prob, cuttype, interp, ncuts, cutind)::prob

During the branch and bound search, cuts are stored in the cut pool to be applied at descendant nodes.

These cuts may be removed from a given node using XPRSdelcuts, but if this is to be applied in a large number of cases, it may be preferable to remove the cut completely from the cut pool. This is achieved using `XPRSdelcpcuts`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `cuttype::Integer`: User defined cut type to match against.
- `interp::Integer`: Way in which the cut `cuttype` is interpreted: -1match all cut types; 1treat cut types as numbers; 2treat cut types as bit maps - delete if any bit matches any bit set in `cuttype`; 3treat cut types as bit maps - delete if all bits match those set in `cuttype`.
- `ncuts::Integer`: The number of cuts to delete.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array containing pointers to the cuts which are to be deleted.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSdelcpcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSdelcpcuts.html) in the C API.
"""
function XPRSdelcpcuts(prob::XPRSprob, cuttype, interp, ncuts, cutind)::XPRSprob
  cuttypexx = Int32(cuttype)
  interpxx = Int32(interp)
  ncutsxx = Int32(ncuts)
  if isnothing(cutind) || length(cutind) == 0
    c_cutind = nothing
  elseif isa(cutind, AbstractVector{Ptr{Cvoid}})
    c_cutind = cutind
  else
    c_cutind = convert(Vector{Ptr{Cvoid}}, cutind)
  end
  faddr = getFunctionAddress("XPRSdelcpcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ptr{Ptr{Cvoid}}), prob.handle, cuttypexx, interpxx, ncutsxx, isnothing(c_cutind) ? C_NULL : c_cutind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSdelcpcuts

"""
    XPRSgetcutlist(prob, cuttype, interp, maxcuts, cutind)::ncuts, cutind

Retrieves a list of cut pointers for the cuts active at the current node.

# Arguments
- `prob::XPRSprob`: The current problem.
- `cuttype::Integer`: User defined type of the cuts to be returned.
- `interp::Integer`: Way in which the cut type is interpreted: -1get all cuts; 1treat cut types as numbers; 2treat cut types as bit maps - get cut if any bit matches any bit set in `cuttype`; 3treat cut types as bit maps - get cut if all bits match those set in `cuttype`.
- `maxcuts::Integer`: Maximum number of cuts to be retrieved.
- `cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}}`: Array of length `maxcuts` where the pointers to the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `ncuts::Int32`: Pointer to the integer where the number of active cuts of type `cuttype` will be returned.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array of length `maxcuts` where the pointers to the cuts will be returned.

See also the documentation of the correponding function [XPRSgetcutlist](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcutlist.html) in the C API.
"""
function XPRSgetcutlist(prob::XPRSprob, cuttype, interp, maxcuts, cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}})::Tuple{Int32,AbstractVector{Ptr{Cvoid}}}
  cuttypexx = Int32(cuttype)
  interpxx = Int32(interp)
  p_ncuts_dummy = Ref{Int32}(0)
  maxcutsxx = Int32(maxcuts)
  if isa(cutind, XPRSallocatable)
    cutind = Vector{Ptr{Cvoid}}(undef, maxcuts)
  elseif cutind != nothing
    if length(cutind) < maxcuts
      throw(XPRSexception("Argument cutind is too short, needs " * (maxcuts) * " elements but has only " * length(cutind), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcutlist")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint},Cint,Ptr{Ptr{Cvoid}}), prob.handle, cuttypexx, interpxx, p_ncuts_dummy, maxcutsxx, isnothing(cutind) ? C_NULL : cutind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncuts = p_ncuts_dummy[]
  p_ncuts, cutind
end
export XPRSgetcutlist

"""
    XPRSgetcpcutlist(prob, cuttype, interp, delta, maxcuts, cutind, viol)::ncuts, cutind, viol

Returns a list of cut indices from the cut pool.

# Arguments
- `prob::XPRSprob`: The current problem.
- `cuttype::Integer`: The user defined type of the cuts to be returned.
- `interp::Integer`: Way in which the cut type is interpreted: -1get all cuts; 1treat cut types as numbers; 2treat cut types as bit maps - get cut if any bit matches any bit set in `cuttype`; 3treat cut types as bit maps - get cut if all bits match those set in `cuttype`.
- `delta::Float64`: Only those cuts with a signed violation greater than delta will be returned.
- `maxcuts::Integer`: Maximum number of cuts to be returned.
- `cutind::Union{XPRSallocatable,Nothing,AbstractVector{Ptr{Cvoid}}}`: Array of length `maxcuts` where the pointers to the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `viol::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxcuts` where the values of the signed violations of the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ncuts::Int32`: Pointer to the integer where the number of cuts of type `cuttype` in the cut pool will be returned.
- `cutind::Union{Nothing,AbstractVector{Ptr{Cvoid}}}`: Array of length `maxcuts` where the pointers to the cuts will be returned.
- `viol::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxcuts` where the values of the signed violations of the cuts will be returned.

See also the documentation of the correponding function [XPRSgetcpcutlist](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcpcutlist.html) in the C API.
"""
function XPRSgetcpcutlist(prob::XPRSprob, cuttype, interp, delta, maxcuts, cutind::Union{XPRSallocatable,Nothing,AbstractVector{Ptr{Cvoid}}}, viol::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Ptr{Cvoid}}},Union{Nothing,AbstractVector{Float64}}}
  cuttypexx = Int32(cuttype)
  interpxx = Int32(interp)
  p_ncuts_dummy = Ref{Int32}(0)
  maxcutsxx = Int32(maxcuts)
  if isa(cutind, XPRSallocatable)
    cutind = Vector{Ptr{Cvoid}}(undef, maxcuts)
  elseif cutind != nothing
    if length(cutind) < maxcuts
      throw(XPRSexception("Argument cutind is too short, needs " * (maxcuts) * " elements but has only " * length(cutind), nothing))
    end
  end
  if isa(viol, XPRSallocatable)
    viol = Vector{Float64}(undef, maxcuts)
  elseif viol != nothing
    if length(viol) < maxcuts
      throw(XPRSexception("Argument viol is too short, needs " * (maxcuts) * " elements but has only " * length(viol), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcpcutlist")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cdouble,Ref{Cint},Cint,Ptr{Ptr{Cvoid}},Ptr{Cdouble}), prob.handle, cuttypexx, interpxx, Float64(delta), p_ncuts_dummy, maxcutsxx, isnothing(cutind) ? C_NULL : cutind, isnothing(viol) ? C_NULL : viol)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncuts = p_ncuts_dummy[]
  p_ncuts, cutind, viol
end
export XPRSgetcpcutlist

"""
    XPRSgetcpcuts(prob, rowind, ncuts, maxcoefs, cuttype, rowtype, start, colind, cutcoef, rhs)::cuttype, rowtype, start, colind, cutcoef, rhs

Returns cuts from the cut pool.

A list of cut pointers in the array `rowind` must be passed to the routine. The columns and elements of the cut will be returned in the regions pointed to by the `colind` and ` cutcoef` parameters. The columns and elements will be stored contiguously and the starting point of each cut will be returned in the region pointed to by the `start` parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` containing the pointers to the cuts.
- `ncuts::Integer`: Number of cuts to be returned.
- `maxcoefs::Integer`: Maximum number of column indices of the cuts to be returned.
- `cuttype::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length at least `ncuts` where the cut types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length at least `ncuts` where the sense of the cuts (`L`, `G`, or `E`) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::AbstractVector{Int32}`: Integer array of length at least `ncuts+1` containing the offsets into the `colind` and `cutcoef` arrays.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` where the column indices of the cuts will be returned.
- `cutcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` where the matrix values will be returned.
- `rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length at least `ncuts` where the right hand side elements for the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `cuttype::Union{Nothing,AbstractVector{Int32}}`: Integer array of length at least `ncuts` where the cut types will be returned.
- `rowtype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length at least `ncuts` where the sense of the cuts (`L`, `G`, or `E`) will be returned.
- `start::AbstractVector{Int32}`: Integer array of length at least `ncuts+1` containing the offsets into the `colind` and `cutcoef` arrays.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` where the column indices of the cuts will be returned.
- `cutcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` where the matrix values will be returned.
- `rhs::Union{Nothing,AbstractVector{Float64}}`: Double array of length at least `ncuts` where the right hand side elements for the cuts will be returned.

See also the documentation of the correponding function [XPRSgetcpcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcpcuts.html) in the C API.
"""
function XPRSgetcpcuts(prob::XPRSprob, rowind, ncuts, maxcoefs, cuttype::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, start::AbstractVector{Int32}, colind::AbstractVector{Int32}, cutcoef::AbstractVector{Float64}, rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Cchar}},AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64},Union{Nothing,AbstractVector{Float64}}}
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Ptr{Cvoid}})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Ptr{Cvoid}}, rowind)
  end
  ncutsxx = Int32(ncuts)
  maxcoefsxx = Int32(maxcoefs)
  faddr = getFunctionAddress("XPRSgetcpcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Ptr{Cvoid}},Cint,Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_rowind) ? C_NULL : c_rowind, ncutsxx, maxcoefsxx, isnothing(cuttype) ? C_NULL : cuttype, isnothing(rowtype) ? C_NULL : rowtype, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(cutcoef) ? C_NULL : cutcoef, isnothing(rhs) ? C_NULL : rhs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  cuttype, rowtype, start, colind, cutcoef, rhs
end
export XPRSgetcpcuts

"""
    XPRSgetcpcuts64(prob, rowind, ncuts, maxcoefs, cuttype, rowtype, start, colind, cutcoef, rhs)::cuttype, rowtype, start, colind, cutcoef, rhs

Returns cuts from the cut pool.

A list of cut pointers in the array `rowind` must be passed to the routine. The columns and elements of the cut will be returned in the regions pointed to by the `colind` and ` cutcoef` parameters. The columns and elements will be stored contiguously and the starting point of each cut will be returned in the region pointed to by the `start` parameter.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` containing the pointers to the cuts.
- `ncuts::Integer`: Number of cuts to be returned.
- `maxcoefs::Integer`: Maximum number of column indices of the cuts to be returned.
- `cuttype::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length at least `ncuts` where the cut types will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length at least `ncuts` where the sense of the cuts (`L`, `G`, or `E`) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::AbstractVector{Int64}`: Integer array of length at least `ncuts+1` containing the offsets into the `colind` and `cutcoef` arrays.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` where the column indices of the cuts will be returned.
- `cutcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` where the matrix values will be returned.
- `rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length at least `ncuts` where the right hand side elements for the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `cuttype::Union{Nothing,AbstractVector{Int32}}`: Integer array of length at least `ncuts` where the cut types will be returned.
- `rowtype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length at least `ncuts` where the sense of the cuts (`L`, `G`, or `E`) will be returned.
- `start::AbstractVector{Int64}`: Integer array of length at least `ncuts+1` containing the offsets into the `colind` and `cutcoef` arrays.
- `colind::AbstractVector{Int32}`: Integer array of length `maxcoefs` where the column indices of the cuts will be returned.
- `cutcoef::AbstractVector{Float64}`: Double array of length `maxcoefs` where the matrix values will be returned.
- `rhs::Union{Nothing,AbstractVector{Float64}}`: Double array of length at least `ncuts` where the right hand side elements for the cuts will be returned.

See also the documentation of the correponding function [XPRSgetcpcuts64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcpcuts64.html) in the C API.
"""
function XPRSgetcpcuts64(prob::XPRSprob, rowind, ncuts, maxcoefs, cuttype::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, start::AbstractVector{Int64}, colind::AbstractVector{Int32}, cutcoef::AbstractVector{Float64}, rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Cchar}},AbstractVector{Int64},AbstractVector{Int32},AbstractVector{Float64},Union{Nothing,AbstractVector{Float64}}}
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Ptr{Cvoid}})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Ptr{Cvoid}}, rowind)
  end
  ncutsxx = Int32(ncuts)
  maxcoefsxx = Int64(maxcoefs)
  faddr = getFunctionAddress("XPRSgetcpcuts64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Ptr{Cvoid}},Cint,Clonglong,Ptr{Cint},Ptr{Cchar},Ptr{Clonglong},Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_rowind) ? C_NULL : c_rowind, ncutsxx, maxcoefsxx, isnothing(cuttype) ? C_NULL : cuttype, isnothing(rowtype) ? C_NULL : rowtype, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(cutcoef) ? C_NULL : cutcoef, isnothing(rhs) ? C_NULL : rhs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  cuttype, rowtype, start, colind, cutcoef, rhs
end
export XPRSgetcpcuts64

"""
    XPRSloadcuts(prob, cuttype, interp, ncuts, cutind)::prob

Loads cuts from the cut pool into the matrix.

Without calling ` XPRSloadcuts` the cuts will remain in the cut pool but will not be active at the node. Cuts loaded at a node remain active at all descendant nodes unless they are deleted using XPRSdelcuts.

# Arguments
- `prob::XPRSprob`: The current problem.
- `cuttype::Integer`: Cut type.
- `interp::Integer`: The way in which the cut type is interpreted: -1load all cuts; 1treat cut types as numbers; 2treat cut types as bit maps - load cut if any bit matches any bit set in `cuttype`; 3treat cut types as bit maps - `0` load cut if all bits match those set in `cuttype`.
- `ncuts::Integer`: Number of cuts to load.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` containing pointers to the cuts to be loaded into the matrix.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSloadcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSloadcuts.html) in the C API.
"""
function XPRSloadcuts(prob::XPRSprob, cuttype, interp, ncuts, cutind)::XPRSprob
  cuttypexx = Int32(cuttype)
  interpxx = Int32(interp)
  ncutsxx = Int32(ncuts)
  if isnothing(cutind) || length(cutind) == 0
    c_cutind = nothing
  elseif isa(cutind, AbstractVector{Ptr{Cvoid}})
    c_cutind = cutind
  else
    c_cutind = convert(Vector{Ptr{Cvoid}}, cutind)
  end
  faddr = getFunctionAddress("XPRSloadcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ptr{Ptr{Cvoid}}), prob.handle, cuttypexx, interpxx, ncutsxx, isnothing(c_cutind) ? C_NULL : c_cutind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSloadcuts

"""
    XPRSstorecuts(prob, ncuts, nodups, cuttype, rowtype, rhs, start, cutind, colind, cutcoef)::cutind

Stores cuts into the cut pool, but does not apply them to the current node.

These cuts must be explicitly loaded into the matrix using XPRSloadcuts before they become active.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncuts::Integer`: Number of cuts to add.
- `nodups::Integer`: 0do not exclude duplicates from the cut pool; 1duplicates are to be excluded from the cut pool; 2duplicates are to be excluded from the cut pool, ignoring cut type.
- `cuttype::AbstractVector{Integer}`: Integer array of length `ncuts` containing the cut types.
- `rowtype::AbstractVector{Cchar}`: Character array of length `ncuts` containing the row types: Lindicates a `<=` row; Eindicates an = row; Gindicates a `>=` row.
- `rhs::AbstractVector{Number}`: Double array of length `ncuts` containing the right hand side elements for the cuts.
- `start::AbstractVector{Integer}`: Integer array containing offsets into the `colind` and `dmtval` arrays indicating the start of each cut.
- `cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}}`: Array of length `ncuts` where the pointers to the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `colind::AbstractVector{Integer}`: Integer array of length `start[ncuts]` containing the column indices in the cuts.
- `cutcoef::AbstractVector{Number}`: Double array of length `start[ncuts]` containing the matrix values for the cuts.
# Return value
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` where the pointers to the cuts will be returned.

See also the documentation of the correponding function [XPRSstorecuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSstorecuts.html) in the C API.
"""
function XPRSstorecuts(prob::XPRSprob, ncuts, nodups, cuttype, rowtype, rhs, start, cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}}, colind, cutcoef)::AbstractVector{Ptr{Cvoid}}
  ncutsxx = Int32(ncuts)
  nodupsxx = Int32(nodups)
  if isnothing(cuttype) || length(cuttype) == 0
    c_cuttype = nothing
  elseif isa(cuttype, AbstractVector{Int32})
    c_cuttype = cuttype
  else
    c_cuttype = convert(Vector{Int32}, cuttype)
  end
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(cutcoef) || length(cutcoef) == 0
    c_cutcoef = nothing
  elseif isa(cutcoef, AbstractVector{Float64})
    c_cutcoef = cutcoef
  else
    c_cutcoef = convert(Vector{Float64}, cutcoef)
  end
  faddr = getFunctionAddress("XPRSstorecuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Cint},Ptr{Ptr{Cvoid}},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncutsxx, nodupsxx, isnothing(c_cuttype) ? C_NULL : c_cuttype, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_start) ? C_NULL : c_start, isnothing(cutind) ? C_NULL : cutind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_cutcoef) ? C_NULL : c_cutcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  cutind
end
export XPRSstorecuts

"""
    XPRSstorecuts64(prob, ncuts, nodups, cuttype, rowtype, rhs, start, cutind, colind, cutcoef)::cutind

Stores cuts into the cut pool, but does not apply them to the current node.

These cuts must be explicitly loaded into the matrix using XPRSloadcuts before they become active.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncuts::Integer`: Number of cuts to add.
- `nodups::Integer`: 0do not exclude duplicates from the cut pool; 1duplicates are to be excluded from the cut pool; 2duplicates are to be excluded from the cut pool, ignoring cut type.
- `cuttype::AbstractVector{Integer}`: Integer array of length `ncuts` containing the cut types.
- `rowtype::AbstractVector{Cchar}`: Character array of length `ncuts` containing the row types: Lindicates a `<=` row; Eindicates an = row; Gindicates a `>=` row.
- `rhs::AbstractVector{Number}`: Double array of length `ncuts` containing the right hand side elements for the cuts.
- `start::AbstractVector{Integer}`: Integer array containing offsets into the `colind` and `dmtval` arrays indicating the start of each cut.
- `cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}}`: Array of length `ncuts` where the pointers to the cuts will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `colind::AbstractVector{Integer}`: Integer array of length `start[ncuts]` containing the column indices in the cuts.
- `cutcoef::AbstractVector{Number}`: Double array of length `start[ncuts]` containing the matrix values for the cuts.
# Return value
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` where the pointers to the cuts will be returned.

See also the documentation of the correponding function [XPRSstorecuts64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSstorecuts64.html) in the C API.
"""
function XPRSstorecuts64(prob::XPRSprob, ncuts, nodups, cuttype, rowtype, rhs, start, cutind::Union{XPRSallocatable,AbstractVector{Ptr{Cvoid}}}, colind, cutcoef)::AbstractVector{Ptr{Cvoid}}
  ncutsxx = Int32(ncuts)
  nodupsxx = Int32(nodups)
  if isnothing(cuttype) || length(cuttype) == 0
    c_cuttype = nothing
  elseif isa(cuttype, AbstractVector{Int32})
    c_cuttype = cuttype
  else
    c_cuttype = convert(Vector{Int32}, cuttype)
  end
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int64})
    c_start = start
  else
    c_start = convert(Vector{Int64}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(cutcoef) || length(cutcoef) == 0
    c_cutcoef = nothing
  elseif isa(cutcoef, AbstractVector{Float64})
    c_cutcoef = cutcoef
  else
    c_cutcoef = convert(Vector{Float64}, cutcoef)
  end
  faddr = getFunctionAddress("XPRSstorecuts64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble},Ptr{Clonglong},Ptr{Ptr{Cvoid}},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncutsxx, nodupsxx, isnothing(c_cuttype) ? C_NULL : c_cuttype, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_start) ? C_NULL : c_start, isnothing(cutind) ? C_NULL : cutind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_cutcoef) ? C_NULL : c_cutcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  cutind
end
export XPRSstorecuts64

"""
    XPRSpresolverow(prob, rowtype, norigcoefs, origcolind, origrowcoef, origrhs, maxcoefs, colind, rowcoef)::ncoefs, colind, rowcoef, rhs, status

Presolves a row formulated in terms of the original variables such that it can be added to a presolved matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowtype::Integer`: The type of the row: Lindicates a `<=` row; Gindicates a `>=` row.
- `norigcoefs::Integer`: Number of elements in the `origcolind` and `origrowcoef` arrays.
- `origcolind::AbstractVector{Integer}`: Integer array of length `norigcoefs` containing the column indices of the row to presolve.
- `origrowcoef::AbstractVector{Number}`: Double array of length `norigcoefs` containing the non-zero coefficients of the row to presolve.
- `origrhs::Float64`: The right-hand side constant of the row to presolve.
- `maxcoefs::Integer`: Maximum number of elements to return in the `colind` and `rowcoef` arrays.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the column indices of the presolved row.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array which will be filled with the coefficients of the presolved row.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ncoefs::Int32`: Pointer to the integer where the number of elements in the `colind` and `rowcoef` arrays will be returned.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array which will be filled with the column indices of the presolved row.
- `rowcoef::Union{Nothing,AbstractVector{Float64}}`: Double array which will be filled with the coefficients of the presolved row.
- `rhs::Float64`: Pointer to the double where the presolved right-hand side will be returned.
- `status::Int32`: Status of the presolved row: -3Failed to presolve the row due to presolve dual reductions; -2Failed to presolve the row due to presolve duplicate column reductions; -1Failed to presolve the row due to an error.

See also the documentation of the correponding function [XPRSpresolverow](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSpresolverow.html) in the C API.
"""
function XPRSpresolverow(prob::XPRSprob, rowtype, norigcoefs, origcolind, origrowcoef, origrhs, maxcoefs, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Float64,Int32}
  rowtypexx = Cchar(rowtype)
  norigcoefsxx = Int32(norigcoefs)
  if isnothing(origcolind) || length(origcolind) == 0
    c_origcolind = nothing
  elseif isa(origcolind, AbstractVector{Int32})
    c_origcolind = origcolind
  else
    c_origcolind = convert(Vector{Int32}, origcolind)
  end
  if isnothing(origrowcoef) || length(origrowcoef) == 0
    c_origrowcoef = nothing
  elseif isa(origrowcoef, AbstractVector{Float64})
    c_origrowcoef = origrowcoef
  else
    c_origrowcoef = convert(Vector{Float64}, origrowcoef)
  end
  maxcoefsxx = Int32(maxcoefs)
  p_ncoefs_dummy = Ref{Int32}(0)
  p_rhs_dummy = Ref{Float64}(0)
  p_status_dummy = Ref{Int32}(0)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, maxcoefs)
  elseif colind != nothing
    if length(colind) < maxcoefs
      throw(XPRSexception("Argument colind is too short, needs " * (maxcoefs) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(rowcoef, XPRSallocatable)
    rowcoef = Vector{Float64}(undef, maxcoefs)
  elseif rowcoef != nothing
    if length(rowcoef) < maxcoefs
      throw(XPRSexception("Argument rowcoef is too short, needs " * (maxcoefs) * " elements but has only " * length(rowcoef), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSpresolverow")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cchar,Cint,Ptr{Cint},Ptr{Cdouble},Cdouble,Cint,Ref{Cint},Ptr{Cint},Ptr{Cdouble},Ref{Cdouble},Ref{Cint}), prob.handle, rowtypexx, norigcoefsxx, isnothing(c_origcolind) ? C_NULL : c_origcolind, isnothing(c_origrowcoef) ? C_NULL : c_origrowcoef, Float64(origrhs), maxcoefsxx, p_ncoefs_dummy, isnothing(colind) ? C_NULL : colind, isnothing(rowcoef) ? C_NULL : rowcoef, p_rhs_dummy, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  p_rhs = p_rhs_dummy[]
  p_status = p_status_dummy[]
  p_ncoefs, colind, rowcoef, p_rhs, p_status
end
export XPRSpresolverow

"""
    XPRSpostsolvesol(prob, prex, origx)::origx

Postsolves a primal solution formulated in the presolved space into the corresponding solution formulated in the original space.

The problem itself is unchanged.

# Arguments
- `prob::XPRSprob`: The current problem.
- `prex::AbstractVector{Number}`: Double array of length COLS with the values of the primal variables in the presolved space.
- `origx::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `origx::AbstractVector{Float64}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.

See also the documentation of the correponding function [XPRSpostsolvesol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSpostsolvesol.html) in the C API.
"""
function XPRSpostsolvesol(prob::XPRSprob, prex, origx::Union{XPRSallocatable,AbstractVector{Float64}})::AbstractVector{Float64}
  if isnothing(prex) || length(prex) == 0
    c_prex = nothing
  elseif isa(prex, AbstractVector{Float64})
    c_prex = prex
  else
    c_prex = convert(Vector{Float64}, prex)
  end
  if isa(origx, XPRSallocatable)
    origx = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif origx != nothing
    if length(origx) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument origx is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(origx), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSpostsolvesol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_prex) ? C_NULL : c_prex, isnothing(origx) ? C_NULL : origx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  origx
end
export XPRSpostsolvesol

"""
    XPRSgetpivots(prob, enter, outlist, x, maxpivots)::outlist, x, objval, npivots

Returns a list of potential leaving variables if a specified variable enters the basis.

# Arguments
- `prob::XPRSprob`: The current problem.
- `enter::Integer`: Index of the specified row or column to enter basis.
- `outlist::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length at least `maxpivots` to hold list of potential leaving variables.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ROWS`+`SPAREROWS`+`COLS to hold the values of all the variables that would result if `enter` entered the basis.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `maxpivots::Integer`: Maximum number of potential leaving variables to return.
# Return values
- `outlist::Union{Nothing,AbstractVector{Int32}}`: Integer array of length at least `maxpivots` to hold list of potential leaving variables.
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length ROWS`+`SPAREROWS`+`COLS to hold the values of all the variables that would result if `enter` entered the basis.
- `objval::Float64`: Pointer to a double where the objective function value that would result if `enter` entered the basis will be returned.
- `npivots::Int32`: Pointer to an integer where the actual number of potential leaving variables will be returned.

See also the documentation of the correponding function [XPRSgetpivots](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpivots.html) in the C API.
"""
function XPRSgetpivots(prob::XPRSprob, enter, outlist::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, maxpivots)::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}},Float64,Int32}
  enterxx = Int32(enter)
  p_objval_dummy = Ref{Float64}(0)
  p_npivots_dummy = Ref{Int32}(0)
  maxpivotsxx = Int32(maxpivots)
  if isa(outlist, XPRSallocatable)
    outlist = Vector{Int32}(undef, maxpivots)
  elseif outlist != nothing
    if length(outlist) < maxpivots
      throw(XPRSexception("Argument outlist is too short, needs " * (maxpivots) * " elements but has only " * length(outlist), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ROWS) + XPRSgetintattrib(prob, XPRS_SPAREROWS) + XPRSgetintattrib(prob, XPRS_COLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_ROWS) + XPRSgetintattrib(prob, XPRS_SPAREROWS) + XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS) + XPRSgetintattrib(prob, XPRS_SPAREROWS) + XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpivots")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Ref{Cdouble},Ref{Cint},Cint), prob.handle, enterxx, isnothing(outlist) ? C_NULL : outlist, isnothing(x) ? C_NULL : x, p_objval_dummy, p_npivots_dummy, maxpivotsxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_objval = p_objval_dummy[]
  p_npivots = p_npivots_dummy[]
  outlist, x, p_objval, p_npivots
end
export XPRSgetpivots

"""
    XPRSwriteprob(prob, filename, flags)::prob

Writes the current problem to an MPS or LP file.

# Arguments
- `prob::XPRSprob`: The current problem.
- `filename::Union{Nothing,AbstractString}`: A string of up to MAXPROBNAMELENGTH characters to contain the file name to which the problem is to be written.
- `flags::Union{Nothing,AbstractString}`: Flags, which can be one or more of the following: output in a format compatible with CPLEX; oone element per line; noutput the scaled problem; sscrambled vector names; loutput in LP format; poutput values in full precision (obsolete as this is now default behavior); tomit the Xpress header in LP format; vuse the provided filename verbatim, without appending the `.mps` or `.lp` extension; zcompress the output file.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSwriteprob](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSwriteprob.html) in the C API.
"""
function XPRSwriteprob(prob::XPRSprob, filename::Union{Nothing,AbstractString}, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(filename)
    filename_pass = C_NULL
  else
    filename_pass = filename
  end
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSwriteprob")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cstring), prob.handle, filename_pass, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSwriteprob

"""
    XPRScalcslacks(prob, solution, slacks)::slacks

Calculates the row slack values for a given solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solution::AbstractVector{Number}`: Double array of length COLS that holds the solution to calculate the slacks for.
- `slacks::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length ROWS in which the calculated row slacks are returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `slacks::AbstractVector{Float64}`: Double array of length ROWS in which the calculated row slacks are returned.

See also the documentation of the correponding function [XPRScalcslacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScalcslacks.html) in the C API.
"""
function XPRScalcslacks(prob::XPRSprob, solution, slacks::Union{XPRSallocatable,AbstractVector{Float64}})::AbstractVector{Float64}
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  if isa(slacks, XPRSallocatable)
    slacks = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif slacks != nothing
    if length(slacks) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument slacks is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(slacks), nothing))
    end
  end
  faddr = getFunctionAddress("XPRScalcslacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_solution) ? C_NULL : c_solution, isnothing(slacks) ? C_NULL : slacks)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  slacks
end
export XPRScalcslacks

"""
    XPRScalcreducedcosts(prob, duals, solution, djs)::djs

Calculates the reduced cost values for a given (row) dual solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `duals::AbstractVector{Number}`: Double array of length ROWS that holds the dual solution to calculate the reduced costs for.
- `solution::AbstractVector{Number}`: Optional double array of length COLS that holds the primal solution.
- `djs::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length COLS in which the calculated reduced costs are returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `djs::AbstractVector{Float64}`: Double array of length COLS in which the calculated reduced costs are returned.

See also the documentation of the correponding function [XPRScalcreducedcosts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScalcreducedcosts.html) in the C API.
"""
function XPRScalcreducedcosts(prob::XPRSprob, duals, solution, djs::Union{XPRSallocatable,AbstractVector{Float64}})::AbstractVector{Float64}
  if isnothing(duals) || length(duals) == 0
    c_duals = nothing
  elseif isa(duals, AbstractVector{Float64})
    c_duals = duals
  else
    c_duals = convert(Vector{Float64}, duals)
  end
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(djs), nothing))
    end
  end
  faddr = getFunctionAddress("XPRScalcreducedcosts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_duals) ? C_NULL : c_duals, isnothing(c_solution) ? C_NULL : c_solution, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  djs
end
export XPRScalcreducedcosts

"""
    XPRScalcobjective(prob, solution)::objval

Calculates the objective value of a given solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solution::AbstractVector{Number}`: Double array of length COLS that holds the solution.
# Return value
- `objval::Float64`: Pointer to a double in which the calculated objective value is returned.

See also the documentation of the correponding function [XPRScalcobjective](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScalcobjective.html) in the C API.
"""
function XPRScalcobjective(prob::XPRSprob, solution)::Float64
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  p_objval_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRScalcobjective")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ref{Cdouble}), prob.handle, isnothing(c_solution) ? C_NULL : c_solution, p_objval_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_objval = p_objval_dummy[]
  p_objval
end
export XPRScalcobjective

"""
    XPRScalcobjn(prob, objidx, solution)::objval

Calculates the objective value of the given objective function in a multi-objective problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objidx::Integer`: Index of the objective function to calculate.
- `solution::AbstractVector{Number}`: Double array of length `COLS` that holds the solution, or `nothing` to use the current solution.
# Return value
- `objval::Float64`: Pointer to a double in which the calculated objective value is returned.

See also the documentation of the correponding function [XPRScalcobjn](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScalcobjn.html) in the C API.
"""
function XPRScalcobjn(prob::XPRSprob, objidx, solution)::Float64
  objidxxx = Int32(objidx)
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  p_objval_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRScalcobjn")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cdouble},Ref{Cdouble}), prob.handle, objidxxx, isnothing(c_solution) ? C_NULL : c_solution, p_objval_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_objval = p_objval_dummy[]
  p_objval
end
export XPRScalcobjn

"""
    XPRScalcsolinfo(prob, solution, duals, property)::value

Calculates the required property of a solution, like maximum infeasibility of a given primal and dual solution.

# Arguments
- `prob::XPRSprob`: The current problem.
- `solution::AbstractVector{Number}`: Double array of length COLS that holds the solution.
- `duals::AbstractVector{Number}`: Double array of length ROWS that holds the dual solution.
- `property::Integer`: Defined the property to be calculated.
# Return value
- `value::Float64`: Pointer to a double where the calculated value is returned.

See also the documentation of the correponding function [XPRScalcsolinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRScalcsolinfo.html) in the C API.
"""
function XPRScalcsolinfo(prob::XPRSprob, solution, duals, property)::Float64
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  if isnothing(duals) || length(duals) == 0
    c_duals = nothing
  elseif isa(duals, AbstractVector{Float64})
    c_duals = duals
  else
    c_duals = convert(Vector{Float64}, duals)
  end
  propertyxx = Int32(property)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRScalcsolinfo")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Cint,Ref{Cdouble}), prob.handle, isnothing(c_solution) ? C_NULL : c_solution, isnothing(c_duals) ? C_NULL : c_duals, propertyxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRScalcsolinfo

"""
    XPRSgetrowtype(prob, rowtype, first, last)::rowtype

Returns the row types for the rows in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowtype::Union{XPRSallocatable,AbstractVector{Cchar}}`: Character array of length `last-first+1` characters where the row types will be returned: Nindicates a free constraint; Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row in the range.
- `last::Integer`: Last row in the range.
# Return value
- `rowtype::AbstractVector{Cchar}`: Character array of length `last-first+1` characters where the row types will be returned: Nindicates a free constraint; Lindicates a `<=` constraint; Eindicates an = constraint; Gindicates a `>=` constraint; Rindicates a range constraint.

See also the documentation of the correponding function [XPRSgetrowtype](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetrowtype.html) in the C API.
"""
function XPRSgetrowtype(prob::XPRSprob, rowtype::Union{XPRSallocatable,AbstractVector{Cchar}}, first, last)::AbstractVector{Cchar}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(rowtype, XPRSallocatable)
    rowtype = Vector{Cchar}(undef, last - first + 1)
  elseif rowtype != nothing
    if length(rowtype) < last - first + 1
      throw(XPRSexception("Argument rowtype is too short, needs " * (last - first + 1) * " elements but has only " * length(rowtype), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetrowtype")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cchar},Cint,Cint), prob.handle, isnothing(rowtype) ? C_NULL : rowtype, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rowtype
end
export XPRSgetrowtype

"""
    XPRSgetpresolvebasis(prob, rowstat, colstat)::rowstat, colstat

Returns the current basis from memory into the user's data areas.

If the problem is presolved, the presolved basis will be returned. Otherwise the original basis will be returned.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length ROWS to the basis status of the stack, surplus or artificial variable associated with each row.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length COLS to hold the basis status of the columns in the constraint matrix.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `rowstat::Union{Nothing,AbstractVector{Int32}}`: Integer array of length ROWS to the basis status of the stack, surplus or artificial variable associated with each row.
- `colstat::Union{Nothing,AbstractVector{Int32}}`: Integer array of length COLS to hold the basis status of the columns in the constraint matrix.

See also the documentation of the correponding function [XPRSgetpresolvebasis](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpresolvebasis.html) in the C API.
"""
function XPRSgetpresolvebasis(prob::XPRSprob, rowstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colstat::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  if isa(colstat, XPRSallocatable)
    colstat = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif colstat != nothing
    if length(colstat) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument colstat is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(colstat), nothing))
    end
  end
  if isa(rowstat, XPRSallocatable)
    rowstat = Vector{Int32}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif rowstat != nothing
    if length(rowstat) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument rowstat is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(rowstat), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpresolvebasis")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cint},Ptr{Cint}), prob.handle, isnothing(rowstat) ? C_NULL : rowstat, isnothing(colstat) ? C_NULL : colstat)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  rowstat, colstat
end
export XPRSgetpresolvebasis

"""
    XPRSgetcoltype(prob, coltype, first, last)::coltype

Returns the column types for the columns in a given range.

# Arguments
- `prob::XPRSprob`: The current problem.
- `coltype::Union{XPRSallocatable,AbstractVector{Cchar}}`: Character array of length `last-first+1` where the column types will be returned: Cindicates a continuous variable; Iindicates an integer variable; Bindicates a binary variable; Sindicates a semi-continuous variable; Rindicates a semi-continuous integer variable; Pindicates a partial integer variable.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return value
- `coltype::AbstractVector{Cchar}`: Character array of length `last-first+1` where the column types will be returned: Cindicates a continuous variable; Iindicates an integer variable; Bindicates a binary variable; Sindicates a semi-continuous variable; Rindicates a semi-continuous integer variable; Pindicates a partial integer variable.

See also the documentation of the correponding function [XPRSgetcoltype](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcoltype.html) in the C API.
"""
function XPRSgetcoltype(prob::XPRSprob, coltype::Union{XPRSallocatable,AbstractVector{Cchar}}, first, last)::AbstractVector{Cchar}
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(coltype, XPRSallocatable)
    coltype = Vector{Cchar}(undef, last - first + 1)
  elseif coltype != nothing
    if length(coltype) < last - first + 1
      throw(XPRSexception("Argument coltype is too short, needs " * (last - first + 1) * " elements but has only " * length(coltype), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcoltype")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cchar},Cint,Cint), prob.handle, isnothing(coltype) ? C_NULL : coltype, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  coltype
end
export XPRSgetcoltype

"""
    XPRSgetqrowcoeff(prob, row, rowqcol1, rowqcol2)::rowqcoef

Returns a single quadratic constraint coefficient corresponding to the variable pair (`rowqcol1`, `rowqcol2`) of the Hessian of a given constraint.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: The quadratic row where the coefficient is to be looked up.
- `rowqcol1::Integer`: Column index for the first variable in the quadratic term.
- `rowqcol2::Integer`: Column index for the second variable in the quadratic term.
# Return value
- `rowqcoef::Float64`: Pointer to a double value where the objective function coefficient is to be placed.

See also the documentation of the correponding function [XPRSgetqrowcoeff](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetqrowcoeff.html) in the C API.
"""
function XPRSgetqrowcoeff(prob::XPRSprob, row, rowqcol1, rowqcol2)::Float64
  rowxx = Int32(row)
  rowqcol1xx = Int32(rowqcol1)
  rowqcol2xx = Int32(rowqcol2)
  p_rowqcoef_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetqrowcoeff")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ref{Cdouble}), prob.handle, rowxx, rowqcol1xx, rowqcol2xx, p_rowqcoef_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_rowqcoef = p_rowqcoef_dummy[]
  p_rowqcoef
end
export XPRSgetqrowcoeff

"""
    XPRSgetqrowqmatrix(prob, row, start, colind, rowqcoef, maxcoefs, first, last)::start, colind, rowqcoef, ncoefs

Returns the nonzeros in a quadratic constraint coefficients matrix for the columns in a given range.

To achieve maximum efficiency, `XPRSgetqrowqmatrix` returns the lower triangular part of this matrix only.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of the row for which the quadratic coefficients are to be returned.
- `start::AbstractVector{Int32}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `rowqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length maxcoefs which will be filled with the column indices of the nonzero elements in the lower triangular part of Q.
- `rowqcoef::AbstractVector{Float64}`: Double array of length maxcoefs which will be filled with the nonzero element values.
- `maxcoefs::Integer`: Number of elements to be saved in colind and rowqcoef.
- `first::Integer`: First column in the range.
- `last::Integer`: Last column in the range.
# Return values
- `start::AbstractVector{Int32}`: Integer array which will be filled with indices indicating the starting offsets in the `colind` and `rowqcoef` arrays for each requested column.
- `colind::AbstractVector{Int32}`: Integer array of length maxcoefs which will be filled with the column indices of the nonzero elements in the lower triangular part of Q.
- `rowqcoef::AbstractVector{Float64}`: Double array of length maxcoefs which will be filled with the nonzero element values.
- `ncoefs::Int32`: Pointer to the integer where the number of nonzero elements in the queried columns will be returned.

See also the documentation of the correponding function [XPRSgetqrowqmatrix](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetqrowqmatrix.html) in the C API.
"""
function XPRSgetqrowqmatrix(prob::XPRSprob, row, start::AbstractVector{Int32}, colind::AbstractVector{Int32}, rowqcoef::AbstractVector{Float64}, maxcoefs, first, last)::Tuple{AbstractVector{Int32},AbstractVector{Int32},AbstractVector{Float64},Int32}
  rowxx = Int32(row)
  maxcoefsxx = Int32(maxcoefs)
  p_ncoefs_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetqrowqmatrix")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Cint,Ref{Cint},Cint,Cint), prob.handle, rowxx, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(rowqcoef) ? C_NULL : rowqcoef, maxcoefsxx, p_ncoefs_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  start, colind, rowqcoef, p_ncoefs
end
export XPRSgetqrowqmatrix

"""
    XPRSgetqrowqmatrixtriplets(prob, row, rowqcol1, rowqcol2, rowqcoef)::ncoefs, rowqcol1, rowqcol2, rowqcoef

Returns the nonzeros in a quadratic constraint coefficients matrix as triplets (index pairs with coefficients).

To achieve maximum efficiency, `XPRSgetqrowqmatrixtriplets` returns the lower triangular part of this matrix only.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of the row for which the quadratic coefficients are to be returned.
- `rowqcol1::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: First index in the triplets.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowqcol2::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Second index in the triplets.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowqcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Coefficients in the triplets.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ncoefs::Int32`: Argument used to return the number of quadratic coefficients in the row.
- `rowqcol1::Union{Nothing,AbstractVector{Int32}}`: First index in the triplets.
- `rowqcol2::Union{Nothing,AbstractVector{Int32}}`: Second index in the triplets.
- `rowqcoef::Union{Nothing,AbstractVector{Float64}}`: Coefficients in the triplets.

See also the documentation of the correponding function [XPRSgetqrowqmatrixtriplets](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetqrowqmatrixtriplets.html) in the C API.
"""
function XPRSgetqrowqmatrixtriplets(prob::XPRSprob, row, rowqcol1::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowqcol2::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowqcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}}}
  rowxx = Int32(row)
  p_ncoefs_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetqrowqmatrixtriplets")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, p_ncoefs_dummy, isnothing(rowqcol1) ? C_NULL : rowqcol1, isnothing(rowqcol2) ? C_NULL : rowqcol2, isnothing(rowqcoef) ? C_NULL : rowqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  p_ncoefs, rowqcol1, rowqcol2, rowqcoef
end
export XPRSgetqrowqmatrixtriplets

"""
    XPRSchgqrowcoeff(prob, row, rowqcol1, rowqcol2, rowqcoef)::prob

Changes a single quadratic coefficient in a row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Index of the row where the quadratic matrix is to be changed.
- `rowqcol1::Integer`: First index of the coefficient to be changed.
- `rowqcol2::Integer`: Second index of the coefficient to be changed.
- `rowqcoef::Float64`: The new coefficient.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgqrowcoeff](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgqrowcoeff.html) in the C API.
"""
function XPRSchgqrowcoeff(prob::XPRSprob, row, rowqcol1, rowqcol2, rowqcoef)::XPRSprob
  rowxx = Int32(row)
  rowqcol1xx = Int32(rowqcol1)
  rowqcol2xx = Int32(rowqcol2)
  faddr = getFunctionAddress("XPRSchgqrowcoeff")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Cdouble), prob.handle, rowxx, rowqcol1xx, rowqcol2xx, Float64(rowqcoef))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgqrowcoeff

"""
    XPRSgetqrows(prob, rowind)::nrows, rowind

Returns the list indices of the rows that have quadratic coefficients.

# Arguments
- `prob::XPRSprob`: The current problem.
- `rowind::Union{XPRSallocatable,AbstractVector{Int32}}`: Array of length `*nrows` used to return the indices of rows with quadratic coefficients in them.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `nrows::Int32`: Used to return the number of quadratic constraints in the matrix.
- `rowind::AbstractVector{Int32}`: Array of length `*nrows` used to return the indices of rows with quadratic coefficients in them.

See also the documentation of the correponding function [XPRSgetqrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetqrows.html) in the C API.
"""
function XPRSgetqrows(prob::XPRSprob, rowind::Union{XPRSallocatable,AbstractVector{Int32}})::Tuple{Int32,AbstractVector{Int32}}
  p_nrows_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSgetqrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cint}), prob.handle, p_nrows_dummy, isnothing(rowind) ? C_NULL : rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nrows = p_nrows_dummy[]
  p_nrows, rowind
end
export XPRSgetqrows

"""
    XPRSchgbounds(prob, nbounds, colind, bndtype, bndval)::prob

Used to change the bounds on columns in the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nbounds::Integer`: Number of bounds to change.
- `colind::AbstractVector{Integer}`: Integer array of size `nbounds` containing the indices of the columns on which the bounds will change.
- `bndtype::AbstractVector{Cchar}`: Character array of length `nbounds` indicating the type of bound to change: Uindicates change the upper bound; Lindicates change the lower bound; Bindicates change both bounds, i.e. fix the column.
- `bndval::AbstractVector{Number}`: Double array of length `nbounds` giving the new bound values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgbounds](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgbounds.html) in the C API.
"""
function XPRSchgbounds(prob::XPRSprob, nbounds, colind, bndtype, bndval)::XPRSprob
  nboundsxx = Int32(nbounds)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(bndtype) || length(bndtype) == 0
    c_bndtype = nothing
  elseif isa(bndtype, AbstractVector{Cchar})
    c_bndtype = bndtype
  else
    c_bndtype = convert(Vector{Cchar}, bndtype)
  end
  if isnothing(bndval) || length(bndval) == 0
    c_bndval = nothing
  elseif isa(bndval, AbstractVector{Float64})
    c_bndval = bndval
  else
    c_bndval = convert(Vector{Float64}, bndval)
  end
  faddr = getFunctionAddress("XPRSchgbounds")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar},Ptr{Cdouble}), prob.handle, nboundsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_bndtype) ? C_NULL : c_bndtype, isnothing(c_bndval) ? C_NULL : c_bndval)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgbounds

"""
    XPRSgetnamelist(prob, type, first, last)::names

Returns the names for the rows, columns, sets, piecewise linear constraints, general constraints or objectives in a given range.

The names will be returned in a character buffer, with no trailing whitespace and with each name being separated by a nothing character.

# Arguments
- `prob::XPRSprob`: The current problem.
- `type::Integer`: XPRS_NAMES_ROW`(=1)` if row names are required; XPRS_NAMES_COLUMN`(=2)` if column names are required; XPRS_NAMES_SET`(=3)` if set names are required; XPRS_NAMES_PWLCONS`(=4)` if piecewise linear constraint names are required; XPRS_NAMES_GENCONS`(=5)` if general constraint names are required; XPRS_NAMES_OBJECTIVE`(=6)` if objective function names are required.
- `first::Integer`: First row, column, set, piecewise linear or general constraint in the range.
- `last::Integer`: Last row, column, set, piecewise linear or general constraint in the range.
# Return value
- `names::AbstractVector{AbstractString}`: A buffer into which the names will be returned as a sequence of null-terminated strings.

See also the documentation of the correponding function [XPRSgetnamelist](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetnamelist.html) in the C API.
"""
function XPRSgetnamelist(prob::XPRSprob, type, first, last)::AbstractVector{AbstractString}
  typexx = Int32(type)
  names_required = Ref{Int32}(0)
  retcode = ccall(getFunctionAddress("XPRSgetnamelist"), Cint, (Ptr{Cvoid}, Cint, Ptr{Cchar}, Cint, Ref{Cint}, Cint, Cint), prob.handle, Int32(type), C_NULL, Int32(0), names_required, Int32(first), Int32(last))
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  names_buffer = Vector{Cchar}(undef, names_required[])
  names_array = Vector{AbstractString}(undef, last-first+1)
  maxbytes = names_required[]
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  faddr = getFunctionAddress("XPRSgetnamelist")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint,Ref{Cint},Cint,Cint), prob.handle, typexx, names_buffer, maxbytesxx, p_nbytes_dummy, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  position = Csize_t(1)
  index = Int32(1)
  for i in 1:last-first+1
    names_array[index] = unsafe_string(pointer(names_buffer, position))
    position += sizeof(names_array[index]) + 1
    index += 1
  end
  names = names_array
  p_nbytes = p_nbytes_dummy[]
  names
end
export XPRSgetnamelist

"""
    XPRSrefinemipsol(prob, options, flags, solution, refined)::refined, status

**Deprecated**Please use REFINEOPS instead.

Executes the MIP solution refiner.

# Arguments
- `prob::XPRSprob`: The current problem.
- `options::Integer`: Refinement options: 0Reducing MIP fractionality is priority (If bit 10 of REFINEOPS is set, will switch to other mode if unsuccessful).
- `flags::Union{Nothing,AbstractString}`: Flags passed to any optimization calls during refinement.
- `solution::AbstractVector{Number}`: The MIP solution to refine.
- `refined::Union{XPRSallocatable,AbstractVector{Float64}}`: The refined MIP solution in case of success
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `refined::AbstractVector{Float64}`: The refined MIP solution in case of success
- `status::Int32`: Refinement results: 0An error has occurred 1The solution has been refined 2Current solution meets target criteria 3Solution cannot be refined 5The solution has been refined, but MIP fractionality could not be reduced.

See also the documentation of the correponding function [XPRSrefinemipsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSrefinemipsol.html) in the C API.
"""
function XPRSrefinemipsol(prob::XPRSprob, options, flags::Union{Nothing,AbstractString}, solution, refined::Union{XPRSallocatable,AbstractVector{Float64}})::Tuple{AbstractVector{Float64},Int32}
  optionsxx = Int32(options)
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  p_status_dummy = Ref{Int32}(0)
  if isa(refined, XPRSallocatable)
    refined = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif refined != nothing
    if length(refined) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument refined is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(refined), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSrefinemipsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring,Ptr{Cdouble},Ptr{Cdouble},Ref{Cint}), prob.handle, optionsxx, flags_pass, isnothing(c_solution) ? C_NULL : c_solution, isnothing(refined) ? C_NULL : refined, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  refined, p_status
end
export XPRSrefinemipsol

"""
    XPRSaddmipsol(prob, len, solval, colind, name)::prob

Adds a new feasible, infeasible or partial MIP solution for the problem to the Optimizer.

# Arguments
- `prob::XPRSprob`: The current problem.
- `len::Integer`: Number of columns for which a value is provided.
- `solval::AbstractVector{Number}`: Double array of length `length` containing solution values.
- `colind::AbstractVector{Integer}`: Optional integer array of length `length` containing the column indices for the solution values provided in `solval`.
- `name::Union{Nothing,AbstractString}`: An optional name to associate with the solution.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSaddmipsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSaddmipsol.html) in the C API.
"""
function XPRSaddmipsol(prob::XPRSprob, len, solval, colind, name::Union{Nothing,AbstractString})::XPRSprob
  lenxx = Int32(len)
  if isnothing(solval) || length(solval) == 0
    c_solval = nothing
  elseif isa(solval, AbstractVector{Float64})
    c_solval = solval
  else
    c_solval = convert(Vector{Float64}, solval)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(name)
    name_pass = C_NULL
  else
    name_pass = name
  end
  faddr = getFunctionAddress("XPRSaddmipsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cdouble},Ptr{Cint},Cstring), prob.handle, lenxx, isnothing(c_solval) ? C_NULL : c_solval, isnothing(c_colind) ? C_NULL : c_colind, name_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSaddmipsol

"""
    XPRSgetcutslack(prob, cutind)::slack

Used to calculate the slack value of a cut with respect to the current LP relaxation solution.

The slack is calculated from the cut itself, and might be requested for any cut (even if it is not currently loaded into the problem).

# Arguments
- `prob::XPRSprob`: The current problem.
- `cutind::Ptr{Cvoid}`: Pointer of the cut for which the slack is to be calculated.
# Return value
- `slack::Float64`: Double pointer where the value of the slack is returned.

See also the documentation of the correponding function [XPRSgetcutslack](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcutslack.html) in the C API.
"""
function XPRSgetcutslack(prob::XPRSprob, cutind)::Float64
  p_slack_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetcutslack")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cvoid},Ref{Cdouble}), prob.handle, Ptr{Cvoid}(cutind), p_slack_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_slack = p_slack_dummy[]
  p_slack
end
export XPRSgetcutslack

"""
    XPRSgetcutmap(prob, ncuts, cutind, cutmap)::cutmap

Used to return in which rows a list of cuts are currently loaded into the Optimizer.

This is useful for example to retrieve the duals associated with active cuts.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncuts::Integer`: Number of cuts in the cutind array.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Pointer array to the cuts for which the row index is requested.
- `cutmap::Union{XPRSallocatable,AbstractVector{Int32}}`: Integer array of length `ncuts`, where the row indices are returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `cutmap::AbstractVector{Int32}`: Integer array of length `ncuts`, where the row indices are returned.

See also the documentation of the correponding function [XPRSgetcutmap](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcutmap.html) in the C API.
"""
function XPRSgetcutmap(prob::XPRSprob, ncuts, cutind, cutmap::Union{XPRSallocatable,AbstractVector{Int32}})::AbstractVector{Int32}
  ncutsxx = Int32(ncuts)
  if isnothing(cutind) || length(cutind) == 0
    c_cutind = nothing
  elseif isa(cutind, AbstractVector{Ptr{Cvoid}})
    c_cutind = cutind
  else
    c_cutind = convert(Vector{Ptr{Cvoid}}, cutind)
  end
  faddr = getFunctionAddress("XPRSgetcutmap")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Ptr{Cvoid}},Ptr{Cint}), prob.handle, ncutsxx, isnothing(c_cutind) ? C_NULL : c_cutind, isnothing(cutmap) ? C_NULL : cutmap)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  cutmap
end
export XPRSgetcutmap

"""
    XPRSgetpresolvesol(prob, x, slack, duals, djs)::x, slack, duals, djs

Returns the solution for the presolved problem from memory.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length COLS where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ROWS where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ROWS` where the values of the dual variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `COLS` where the reduced cost for each variable will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length COLS where the values of the primal variables will be returned.
- `slack::Union{Nothing,AbstractVector{Float64}}`: Double array of length ROWS where the values of the slack variables will be returned.
- `duals::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ROWS` where the values of the dual variables will be returned.
- `djs::Union{Nothing,AbstractVector{Float64}}`: Double array of length `COLS` where the reduced cost for each variable will be returned.

See also the documentation of the correponding function [XPRSgetpresolvesol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetpresolvesol.html) in the C API.
"""
function XPRSgetpresolvesol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif duals != nothing
    if length(duals) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument duals is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ROWS))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, XPRS_ROWS)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, XPRS_ROWS)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_COLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_COLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_COLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetpresolvesol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  x, slack, duals, djs
end
export XPRSgetpresolvesol

"""
    XPRSgetsolution(prob, x, first, last)::status, x

Used to obtain the incumbent solution during or after optimization with XPRSoptimize, XPRSmipoptimize, XPRSlpoptimize or `XPRSnlpoptimize`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,AbstractVector{Float64}}`: Double pointer where the value of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the solution.
- `last::Integer`: Last column in the solution.
# Return values
- `status::Int32`: Information about the solution returned.
- `x::AbstractVector{Float64}`: Double pointer where the value of the primal variables will be returned.

See also the documentation of the correponding function [XPRSgetsolution](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetsolution.html) in the C API.
"""
function XPRSgetsolution(prob::XPRSprob, x::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  status_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, last - first + 1)
  elseif x != nothing
    if length(x) < last - first + 1
      throw(XPRSexception("Argument x is too short, needs " * (last - first + 1) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetsolution")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, status_dummy, isnothing(x) ? C_NULL : x, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  status = status_dummy[]
  status, x
end
export XPRSgetsolution

"""
    XPRSgetslacks(prob, slacks, first, last)::status, slacks

Used to obtain the slack values associated with the incumbent solution during or after optimization with XPRSoptimize, XPRSmipoptimize, XPRSlpoptimize or `XPRSnlpoptimize`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `slacks::Union{XPRSallocatable,AbstractVector{Float64}}`: Double pointer where the value of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row in the slacks.
- `last::Integer`: Last row in the slacks.
# Return values
- `status::Int32`: Information about the slacks returned.
- `slacks::AbstractVector{Float64}`: Double pointer where the value of the slack variables will be returned.

See also the documentation of the correponding function [XPRSgetslacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetslacks.html) in the C API.
"""
function XPRSgetslacks(prob::XPRSprob, slacks::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  status_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(slacks, XPRSallocatable)
    slacks = Vector{Float64}(undef, last - first + 1)
  elseif slacks != nothing
    if length(slacks) < last - first + 1
      throw(XPRSexception("Argument slacks is too short, needs " * (last - first + 1) * " elements but has only " * length(slacks), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetslacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, status_dummy, isnothing(slacks) ? C_NULL : slacks, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  status = status_dummy[]
  status, slacks
end
export XPRSgetslacks

"""
    XPRSgetduals(prob, duals, first, last)::status, duals

Used to obtain the dual values associated with the incumbent solution during or after optimization of a continuous problem with XPRSoptimize, XPRSlpoptimize or `XPRSnlpoptimize`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `duals::Union{XPRSallocatable,AbstractVector{Float64}}`: Double pointer where the value of the dual variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row in the dual solution.
- `last::Integer`: Last row in the dual solution.
# Return values
- `status::Int32`: Information about the dual solution returned.
- `duals::AbstractVector{Float64}`: Double pointer where the value of the dual variables will be returned.

See also the documentation of the correponding function [XPRSgetduals](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetduals.html) in the C API.
"""
function XPRSgetduals(prob::XPRSprob, duals::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  status_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, last - first + 1)
  elseif duals != nothing
    if length(duals) < last - first + 1
      throw(XPRSexception("Argument duals is too short, needs " * (last - first + 1) * " elements but has only " * length(duals), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetduals")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, status_dummy, isnothing(duals) ? C_NULL : duals, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  status = status_dummy[]
  status, duals
end
export XPRSgetduals

"""
    XPRSgetredcosts(prob, djs, first, last)::status, djs

Used to obtain the reduced costs associated with the incumbent solution during or after optimization of a continuous problem with XPRSoptimize, XPRSlpoptimize or `XPRSnlpoptimize`.

# Arguments
- `prob::XPRSprob`: The current problem.
- `djs::Union{XPRSallocatable,AbstractVector{Float64}}`: Double pointer where the reduced costs for the variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the reduced costs.
- `last::Integer`: Last column in the reduced costs.
# Return values
- `status::Int32`: Information about the reduced costs returned.
- `djs::AbstractVector{Float64}`: Double pointer where the reduced costs for the variables will be returned.

See also the documentation of the correponding function [XPRSgetredcosts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetredcosts.html) in the C API.
"""
function XPRSgetredcosts(prob::XPRSprob, djs::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  status_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, last - first + 1)
  elseif djs != nothing
    if length(djs) < last - first + 1
      throw(XPRSexception("Argument djs is too short, needs " * (last - first + 1) * " elements but has only " * length(djs), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetredcosts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, status_dummy, isnothing(djs) ? C_NULL : djs, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  status = status_dummy[]
  status, djs
end
export XPRSgetredcosts

"""
    XPRSgetlpsol(prob, x, slack, duals, djs)::x, slack, duals, djs

Used to obtain the LP solution values following optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALROWS` where the values of the dual variables (cBTB-1) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALCOLS` where the reduced cost for each variable (cT-cBTB-1A) will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
- `slack::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.
- `duals::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALROWS` where the values of the dual variables (cBTB-1) will be returned.
- `djs::Union{Nothing,AbstractVector{Float64}}`: Double array of length `ORIGINALCOLS` where the reduced cost for each variable (cT-cBTB-1A) will be returned.

See also the documentation of the correponding function [XPRSgetlpsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetlpsol.html) in the C API.
"""
function XPRSgetlpsol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif duals != nothing
    if length(duals) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument duals is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetlpsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  x, slack, duals, djs
end
export XPRSgetlpsol

"""
    XPRSgetlpsolval(prob, col, row)::x, slack, dual, dj

**Deprecated**Use XPRSgetsolution or XPRSgetcallbacksolution and related functions instead.

Used to obtain a single LP solution value following optimization.

# Arguments
- `prob::XPRSprob`: The current problem.
- `col::Integer`: Column index of the variable for which to return the solution value.
- `row::Integer`: Row index of the constraint for which to return the solution value.
# Return values
- `x::Float64`: Double pointer where the value of the primal variable will be returned.
- `slack::Float64`: Double pointer where the value of the slack variable will be returned.
- `dual::Float64`: Double pointer where the value of the dual variable (cBTB-1) will be returned.
- `dj::Float64`: Double pointer where the reduced costs for the variable (cT-cBTB-1A) will be returned.

See also the documentation of the correponding function [XPRSgetlpsolval](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetlpsolval.html) in the C API.
"""
function XPRSgetlpsolval(prob::XPRSprob, col, row)::Tuple{Float64,Float64,Float64,Float64}
  colxx = Int32(col)
  rowxx = Int32(row)
  p_x_dummy = Ref{Float64}(0)
  p_slack_dummy = Ref{Float64}(0)
  p_dual_dummy = Ref{Float64}(0)
  p_dj_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetlpsolval")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble},Ref{Cdouble},Ref{Cdouble},Ref{Cdouble}), prob.handle, colxx, rowxx, p_x_dummy, p_slack_dummy, p_dual_dummy, p_dj_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_x = p_x_dummy[]
  p_slack = p_slack_dummy[]
  p_dual = p_dual_dummy[]
  p_dj = p_dj_dummy[]
  p_x, p_slack, p_dual, p_dj
end
export XPRSgetlpsolval

"""
    XPRSgetmipsol(prob, x, slack)::x, slack

**Deprecated**Use XPRSgetsolution and XPRSgetslacks instead.

Used to obtain the solution values of the last MIP solution that was found.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALCOLS where the values of the primal variables will be returned.
- `slack::Union{Nothing,AbstractVector{Float64}}`: Double array of length ORIGINALROWS where the values of the slack variables will be returned.

See also the documentation of the correponding function [XPRSgetmipsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmipsol.html) in the C API.
"""
function XPRSgetmipsol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALROWS))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, XPRS_ORIGINALROWS)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALROWS)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, XPRS_ORIGINALCOLS))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, XPRS_ORIGINALCOLS)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetmipsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  x, slack
end
export XPRSgetmipsol

"""
    XPRSgetmipsolval(prob, col, row)::x, slack

**Deprecated**Use XPRSgetsolution and XPRSgetslacks instead.

Used to obtain a single solution value of the last MIP solution that was found.

# Arguments
- `prob::XPRSprob`: The current problem.
- `col::Integer`: Column index of the variable for which to return the solution value.
- `row::Integer`: Row index of the constraint for which to return the solution value.
# Return values
- `x::Float64`: Double pointer where the value of the primal variable will be returned.
- `slack::Float64`: Double pointer where the value of the slack variable will be returned.

See also the documentation of the correponding function [XPRSgetmipsolval](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetmipsolval.html) in the C API.
"""
function XPRSgetmipsolval(prob::XPRSprob, col, row)::Tuple{Float64,Float64}
  colxx = Int32(col)
  rowxx = Int32(row)
  p_x_dummy = Ref{Float64}(0)
  p_slack_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSgetmipsolval")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble},Ref{Cdouble}), prob.handle, colxx, rowxx, p_x_dummy, p_slack_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_x = p_x_dummy[]
  p_slack = p_slack_dummy[]
  p_x, p_slack
end
export XPRSgetmipsolval

"""
    XPRSgetcallbacksolution(prob, x, first, last)::available, x

Returns the solution associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the solution to return.
- `last::Integer`: Last column in the solution to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a solution is available.
- `x::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the primal variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbacksolution](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbacksolution.html) in the C API.
"""
function XPRSgetcallbacksolution(prob::XPRSprob, x::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, last - first + 1)
  elseif x != nothing
    if length(x) < last - first + 1
      throw(XPRSexception("Argument x is too short, needs " * (last - first + 1) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbacksolution")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(x) ? C_NULL : x, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, x
end
export XPRSgetcallbacksolution

"""
    XPRSgetcallbackslacks(prob, slacks, first, last)::available, slacks

Returns the slack values from the solution associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `slacks::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row whose slack value to return.
- `last::Integer`: Last row whose slack value to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a solution is available.
- `slacks::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the slack variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackslacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackslacks.html) in the C API.
"""
function XPRSgetcallbackslacks(prob::XPRSprob, slacks::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(slacks, XPRSallocatable)
    slacks = Vector{Float64}(undef, last - first + 1)
  elseif slacks != nothing
    if length(slacks) < last - first + 1
      throw(XPRSexception("Argument slacks is too short, needs " * (last - first + 1) * " elements but has only " * length(slacks), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackslacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(slacks) ? C_NULL : slacks, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, slacks
end
export XPRSgetcallbackslacks

"""
    XPRSgetcallbackduals(prob, duals, first, last)::available, duals

Returns the dual values from the solution associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `duals::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the dual variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row whose dual value to return.
- `last::Integer`: Last row whose dual value to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a dual solution is available.
- `duals::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the dual variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackduals](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackduals.html) in the C API.
"""
function XPRSgetcallbackduals(prob::XPRSprob, duals::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, last - first + 1)
  elseif duals != nothing
    if length(duals) < last - first + 1
      throw(XPRSexception("Argument duals is too short, needs " * (last - first + 1) * " elements but has only " * length(duals), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackduals")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(duals) ? C_NULL : duals, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, duals
end
export XPRSgetcallbackduals

"""
    XPRSgetcallbackredcosts(prob, djs, first, last)::available, djs

Returns the reduced costs from the solution associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `djs::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the reduced costs of the variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column whose reduced cost to return.
- `last::Integer`: Last column whose reduced cost to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a dual solution is available.
- `djs::AbstractVector{Float64}`: Double array of length `last-first+1` where the reduced costs of the variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackredcosts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackredcosts.html) in the C API.
"""
function XPRSgetcallbackredcosts(prob::XPRSprob, djs::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, last - first + 1)
  elseif djs != nothing
    if length(djs) < last - first + 1
      throw(XPRSexception("Argument djs is too short, needs " * (last - first + 1) * " elements but has only " * length(djs), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackredcosts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(djs) ? C_NULL : djs, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, djs
end
export XPRSgetcallbackredcosts

"""
    XPRSgetcallbackpresolvesolution(prob, x, first, last)::available, x

Returns the solution to the presolved problem associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `x::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the primal variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column in the solution to return.
- `last::Integer`: Last column in the solution to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a solution is available.
- `x::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the primal variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackpresolvesolution](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackpresolvesolution.html) in the C API.
"""
function XPRSgetcallbackpresolvesolution(prob::XPRSprob, x::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, last - first + 1)
  elseif x != nothing
    if length(x) < last - first + 1
      throw(XPRSexception("Argument x is too short, needs " * (last - first + 1) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackpresolvesolution")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(x) ? C_NULL : x, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, x
end
export XPRSgetcallbackpresolvesolution

"""
    XPRSgetcallbackpresolveslacks(prob, slacks, first, last)::available, slacks

Returns the slack values from the solution to the presolved problem associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `slacks::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the slack variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row whose slack value to return.
- `last::Integer`: Last row whose slack value to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a solution is available.
- `slacks::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the slack variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackpresolveslacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackpresolveslacks.html) in the C API.
"""
function XPRSgetcallbackpresolveslacks(prob::XPRSprob, slacks::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(slacks, XPRSallocatable)
    slacks = Vector{Float64}(undef, last - first + 1)
  elseif slacks != nothing
    if length(slacks) < last - first + 1
      throw(XPRSexception("Argument slacks is too short, needs " * (last - first + 1) * " elements but has only " * length(slacks), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackpresolveslacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(slacks) ? C_NULL : slacks, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, slacks
end
export XPRSgetcallbackpresolveslacks

"""
    XPRSgetcallbackpresolveduals(prob, duals, first, last)::available, duals

Returns the dual values from the solution to the presolved problem associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `duals::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the values of the dual variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First row whose dual value to return.
- `last::Integer`: Last row whose dual value to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a dual solution is available.
- `duals::AbstractVector{Float64}`: Double array of length `last-first+1` where the values of the dual variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackpresolveduals](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackpresolveduals.html) in the C API.
"""
function XPRSgetcallbackpresolveduals(prob::XPRSprob, duals::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, last - first + 1)
  elseif duals != nothing
    if length(duals) < last - first + 1
      throw(XPRSexception("Argument duals is too short, needs " * (last - first + 1) * " elements but has only " * length(duals), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackpresolveduals")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(duals) ? C_NULL : duals, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, duals
end
export XPRSgetcallbackpresolveduals

"""
    XPRSgetcallbackpresolveredcosts(prob, djs, first, last)::available, djs

Returns the reduced costs from the solution to the presolved problem associated with the current callback.

# Arguments
- `prob::XPRSprob`: The current problem.
- `djs::Union{XPRSallocatable,AbstractVector{Float64}}`: Double array of length `last-first+1` where the reduced costs of the variables will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
- `first::Integer`: First column whose reduced cost to return.
- `last::Integer`: Last column whose reduced cost to return.
# Return values
- `available::Int32`: This variable will be set to 1 if a dual solution is available.
- `djs::AbstractVector{Float64}`: Double array of length `last-first+1` where the reduced costs of the variables will be returned.

See also the documentation of the correponding function [XPRSgetcallbackpresolveredcosts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetcallbackpresolveredcosts.html) in the C API.
"""
function XPRSgetcallbackpresolveredcosts(prob::XPRSprob, djs::Union{XPRSallocatable,AbstractVector{Float64}}, first, last)::Tuple{Int32,AbstractVector{Float64}}
  p_available_dummy = Ref{Int32}(0)
  firstxx = Int32(first)
  lastxx = Int32(last)
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, last - first + 1)
  elseif djs != nothing
    if length(djs) < last - first + 1
      throw(XPRSexception("Argument djs is too short, needs " * (last - first + 1) * " elements but has only " * length(djs), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetcallbackpresolveredcosts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cdouble},Cint,Cint), prob.handle, p_available_dummy, isnothing(djs) ? C_NULL : djs, firstxx, lastxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_available = p_available_dummy[]
  p_available, djs
end
export XPRSgetcallbackpresolveredcosts

"""
    XPRSchgobj(prob, ncols, colind, objcoef)::prob

Used to change the objective function coefficients.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncols::Integer`: Number of objective function coefficient elements to change.
- `colind::AbstractVector{Integer}`: Integer array of length `ncols` containing the indices of the columns whose objective coefficients will change.
- `objcoef::AbstractVector{Number}`: Double array of length `ncols` giving the new objective function coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgobj.html) in the C API.
"""
function XPRSchgobj(prob::XPRSprob, ncols, colind, objcoef)::XPRSprob
  ncolsxx = Int32(ncols)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(objcoef) || length(objcoef) == 0
    c_objcoef = nothing
  elseif isa(objcoef, AbstractVector{Float64})
    c_objcoef = objcoef
  else
    c_objcoef = convert(Vector{Float64}, objcoef)
  end
  faddr = getFunctionAddress("XPRSchgobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, ncolsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_objcoef) ? C_NULL : c_objcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end

"""
    XPRSchgobj(prob, vec)

Implementation of `XPRSchgobj` that combines arguments `ncols`, `colind`, `objcoef`
into a single argument `vec`. Note that the indices in `vec` must be specified
as 0-based indices.
"""
function XPRSchgobj(prob::XPRSprob, vec::AbstractSparseArray{Float64,Int32,1})::Nothing
  XPRSchgobj(prob, vec.n, vec.nzind, vec.nzval)
end

export XPRSchgobj

"""
    XPRSchgcoef(prob, row, col, coef)::prob

Used to change a single coefficient in the matrix.

If the coefficient does not already exist, a new coefficient will be added to the matrix. If many coefficients are being added to a row of the matrix, it may be more efficient to delete the old row of the matrix and add a new row.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: Row index for the coefficient.
- `col::Integer`: Column index for the coefficient.
- `coef::Float64`: New value for the coefficient.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgcoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgcoef.html) in the C API.
"""
function XPRSchgcoef(prob::XPRSprob, row, col, coef)::XPRSprob
  rowxx = Int32(row)
  colxx = Int32(col)
  faddr = getFunctionAddress("XPRSchgcoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cdouble), prob.handle, rowxx, colxx, Float64(coef))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgcoef

"""
    XPRSchgmcoef(prob, ncoefs, rowind, colind, rowcoef)::prob

Used to change multiple coefficients in the matrix.

If any coefficient does not already exist, it will be added to the matrix. If many coefficients are being added to a row of the matrix, it may be more efficient to delete the old row of the matrix and add a new one.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncoefs::Integer`: Number of new coefficients.
- `rowind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the row indices of the coefficients to be changed.
- `colind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the column indices of the coefficients to be changed.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the new coefficient values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgmcoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgmcoef.html) in the C API.
"""
function XPRSchgmcoef(prob::XPRSprob, ncoefs, rowind, colind, rowcoef)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  faddr = getFunctionAddress("XPRSchgmcoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgmcoef

"""
    XPRSchgmcoef64(prob, ncoefs, rowind, colind, rowcoef)::prob

Used to change multiple coefficients in the matrix.

If any coefficient does not already exist, it will be added to the matrix. If many coefficients are being added to a row of the matrix, it may be more efficient to delete the old row of the matrix and add a new one.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncoefs::Integer`: Number of new coefficients.
- `rowind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the row indices of the coefficients to be changed.
- `colind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the column indices of the coefficients to be changed.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the new coefficient values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgmcoef64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgmcoef64.html) in the C API.
"""
function XPRSchgmcoef64(prob::XPRSprob, ncoefs, rowind, colind, rowcoef)::XPRSprob
  ncoefsxx = Int64(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  faddr = getFunctionAddress("XPRSchgmcoef64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgmcoef64

"""
    XPRSchgmqobj(prob, ncoefs, objqcol1, objqcol2, objqcoef)::prob

Used to change multiple quadratic coefficients in the objective function.

If any of the coefficients does not exist already, new coefficients will be added to the objective function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncoefs::Integer`: The number of coefficients to change.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `ncol` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `ncol` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: New values for the coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgmqobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgmqobj.html) in the C API.
"""
function XPRSchgmqobj(prob::XPRSprob, ncoefs, objqcol1, objqcol2, objqcoef)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  faddr = getFunctionAddress("XPRSchgmqobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgmqobj

"""
    XPRSchgmqobj64(prob, ncoefs, objqcol1, objqcol2, objqcoef)::prob

Used to change multiple quadratic coefficients in the objective function.

If any of the coefficients does not exist already, new coefficients will be added to the objective function.

# Arguments
- `prob::XPRSprob`: The current problem.
- `ncoefs::Integer`: The number of coefficients to change.
- `objqcol1::AbstractVector{Integer}`: Integer array of size `ncol` containing the column index of the first variable in each quadratic term.
- `objqcol2::AbstractVector{Integer}`: Integer array of size `ncol` containing the column index of the second variable in each quadratic term.
- `objqcoef::AbstractVector{Number}`: New values for the coefficients.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgmqobj64](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgmqobj64.html) in the C API.
"""
function XPRSchgmqobj64(prob::XPRSprob, ncoefs, objqcol1, objqcol2, objqcoef)::XPRSprob
  ncoefsxx = Int64(ncoefs)
  if isnothing(objqcol1) || length(objqcol1) == 0
    c_objqcol1 = nothing
  elseif isa(objqcol1, AbstractVector{Int32})
    c_objqcol1 = objqcol1
  else
    c_objqcol1 = convert(Vector{Int32}, objqcol1)
  end
  if isnothing(objqcol2) || length(objqcol2) == 0
    c_objqcol2 = nothing
  elseif isa(objqcol2, AbstractVector{Int32})
    c_objqcol2 = objqcol2
  else
    c_objqcol2 = convert(Vector{Int32}, objqcol2)
  end
  if isnothing(objqcoef) || length(objqcoef) == 0
    c_objqcoef = nothing
  elseif isa(objqcoef, AbstractVector{Float64})
    c_objqcoef = objqcoef
  else
    c_objqcoef = convert(Vector{Float64}, objqcoef)
  end
  faddr = getFunctionAddress("XPRSchgmqobj64")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Clonglong,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_objqcol1) ? C_NULL : c_objqcol1, isnothing(c_objqcol2) ? C_NULL : c_objqcol2, isnothing(c_objqcoef) ? C_NULL : c_objqcoef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgmqobj64

"""
    XPRSchgqobj(prob, objqcol1, objqcol2, objqcoef)::prob

Used to change a single quadratic coefficient in the objective function corresponding to the variable pair `(objqcol1,objqcol2)` of the Hessian matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `objqcol1::Integer`: Column index for the first variable in the quadratic term.
- `objqcol2::Integer`: Column index for the second variable in the quadratic term.
- `objqcoef::Float64`: New value for the coefficient in the quadratic Hessian matrix.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgqobj](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgqobj.html) in the C API.
"""
function XPRSchgqobj(prob::XPRSprob, objqcol1, objqcol2, objqcoef)::XPRSprob
  objqcol1xx = Int32(objqcol1)
  objqcol2xx = Int32(objqcol2)
  faddr = getFunctionAddress("XPRSchgqobj")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cdouble), prob.handle, objqcol1xx, objqcol2xx, Float64(objqcoef))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgqobj

"""
    XPRSchgrhs(prob, nrows, rowind, rhs)::prob

Used to change righthand side values of the problem.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of right hand side values to change.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the indices of the rows on which the right hand side values will change.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` giving the right hand side values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgrhs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgrhs.html) in the C API.
"""
function XPRSchgrhs(prob::XPRSprob, nrows, rowind, rhs)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  faddr = getFunctionAddress("XPRSchgrhs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rhs) ? C_NULL : c_rhs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end

"""
    XPRSchgrhs(prob, vec)

Implementation of `XPRSchgrhs` that combines arguments `nrows`, `rowind`, `rhs`
into a single argument `vec`. Note that the indices in `vec` must be specified
as 0-based indices.
"""
function XPRSchgrhs(prob::XPRSprob, vec::AbstractSparseArray{Float64,Int32,1})::Nothing
  XPRSchgrhs(prob, vec.n, vec.nzind, vec.nzval)
end

export XPRSchgrhs

"""
    XPRSchgrhsrange(prob, nrows, rowind, rng)::prob

Used to change the range for a row of the problem matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of range elements to change.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the indices of the rows on which the range elements will change.
- `rng::AbstractVector{Number}`: Double array of length `nrows` giving the range values.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgrhsrange](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgrhsrange.html) in the C API.
"""
function XPRSchgrhsrange(prob::XPRSprob, nrows, rowind, rng)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rng) || length(rng) == 0
    c_rng = nothing
  elseif isa(rng, AbstractVector{Float64})
    c_rng = rng
  else
    c_rng = convert(Vector{Float64}, rng)
  end
  faddr = getFunctionAddress("XPRSchgrhsrange")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rng) ? C_NULL : c_rng)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end

"""
    XPRSchgrhsrange(prob, vec)

Implementation of `XPRSchgrhsrange` that combines arguments `nrows`, `rowind`, `rng`
into a single argument `vec`. Note that the indices in `vec` must be specified
as 0-based indices.
"""
function XPRSchgrhsrange(prob::XPRSprob, vec::AbstractSparseArray{Float64,Int32,1})::Nothing
  XPRSchgrhsrange(prob, vec.n, vec.nzind, vec.nzval)
end

export XPRSchgrhsrange

"""
    XPRSchgrowtype(prob, nrows, rowind, rowtype)::prob

Used to change the type of a row in the matrix.

# Arguments
- `prob::XPRSprob`: The current problem.
- `nrows::Integer`: Number of rows to change.
- `rowind::AbstractVector{Integer}`: Integer array of length `nrows` containing the indices of the rows.
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` giving the new row types: Lindicates a `<=` row; Eindicates an = row; Gindicates a `>=` row; Rindicates a range row; Nindicates a free row.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSchgrowtype](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSchgrowtype.html) in the C API.
"""
function XPRSchgrowtype(prob::XPRSprob, nrows, rowind, rowtype)::XPRSprob
  nrowsxx = Int32(nrows)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  faddr = getFunctionAddress("XPRSchgrowtype")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cchar}), prob.handle, nrowsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_rowtype) ? C_NULL : c_rowtype)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSchgrowtype

"""
    XPRSmsaddjob(prob, description, ninitial, colind, initial, nintcontrols, intcontrolid, intcontrolval, ndblcontrols, dblcontrolid, dblcontrolval, data)::prob

Adds a multistart job to the multistart pool

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `description::Union{Nothing,AbstractString}`: Text description of the job.
- `ninitial::Integer`: Number of initial values to set.
- `colind::AbstractVector{Integer}`: Indices of the variables for which to set an initial value.
- `initial::AbstractVector{Number}`: Initial values for the variables for which to set an initial value.
- `nintcontrols::Integer`: Number of integer controls to set.
- `intcontrolid::AbstractVector{Integer}`: The indices of the integer controls to be set.
- `intcontrolval::AbstractVector{Integer}`: The values of the integer controls to be set.
- `ndblcontrols::Integer`: Number of double controls to set.
- `dblcontrolid::AbstractVector{Integer}`: The indices of the double controls to be set.
- `dblcontrolval::AbstractVector{Number}`: The values of the double controls to be set.
- `data::Any`: Job specific user context pointer to be passed to the multistart callbacks.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSmsaddjob](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmsaddjob.html) in the C API.
"""
function XPRSmsaddjob(prob::XPRSprob, description::Union{Nothing,AbstractString}, ninitial, colind, initial, nintcontrols, intcontrolid, intcontrolval, ndblcontrols, dblcontrolid, dblcontrolval, data::Any)::XPRSprob
  if isnothing(description)
    description_pass = C_NULL
  else
    description_pass = description
  end
  ninitialxx = Int32(ninitial)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(initial) || length(initial) == 0
    c_initial = nothing
  elseif isa(initial, AbstractVector{Float64})
    c_initial = initial
  else
    c_initial = convert(Vector{Float64}, initial)
  end
  nintcontrolsxx = Int32(nintcontrols)
  if isnothing(intcontrolid) || length(intcontrolid) == 0
    c_intcontrolid = nothing
  elseif isa(intcontrolid, AbstractVector{Int32})
    c_intcontrolid = intcontrolid
  else
    c_intcontrolid = convert(Vector{Int32}, intcontrolid)
  end
  if isnothing(intcontrolval) || length(intcontrolval) == 0
    c_intcontrolval = nothing
  elseif isa(intcontrolval, AbstractVector{Int32})
    c_intcontrolval = intcontrolval
  else
    c_intcontrolval = convert(Vector{Int32}, intcontrolval)
  end
  ndblcontrolsxx = Int32(ndblcontrols)
  if isnothing(dblcontrolid) || length(dblcontrolid) == 0
    c_dblcontrolid = nothing
  elseif isa(dblcontrolid, AbstractVector{Int32})
    c_dblcontrolid = dblcontrolid
  else
    c_dblcontrolid = convert(Vector{Int32}, dblcontrolid)
  end
  if isnothing(dblcontrolval) || length(dblcontrolval) == 0
    c_dblcontrolval = nothing
  elseif isa(dblcontrolval, AbstractVector{Float64})
    c_dblcontrolval = dblcontrolval
  else
    c_dblcontrolval = convert(Vector{Float64}, dblcontrolval)
  end
  data_node = CallbackNode()
  faddr = getFunctionAddress("XPRSmsaddjob")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cvoid}), prob.handle, description_pass, ninitialxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_initial) ? C_NULL : c_initial, nintcontrolsxx, isnothing(c_intcontrolid) ? C_NULL : c_intcontrolid, isnothing(c_intcontrolval) ? C_NULL : c_intcontrolval, ndblcontrolsxx, isnothing(c_dblcontrolid) ? C_NULL : c_dblcontrolid, isnothing(c_dblcontrolval) ? C_NULL : c_dblcontrolval, data_node)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  if data != nothing
    data_node.closure = data
    data_node.nin = ninxx
    data_node.nout = noutxx
    data_node.callback = Int32(1)
    linkMultistart(prob, data_node)
  end
  prob
end
export XPRSmsaddjob

"""
    XPRSmsaddpreset(prob, description, preset, maxjobs, data)::prob

Loads a preset of jobs into the multistart job pool.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `description::Union{Nothing,AbstractString}`: Text description of the preset.
- `preset::Integer`: Which preset to load.
- `maxjobs::Integer`: Maximum number of jobs to be added to the multistart pool.
- `data::Any`: Job specific user context pointer to be passed to the multistart callbacks.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSmsaddpreset](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmsaddpreset.html) in the C API.
"""
function XPRSmsaddpreset(prob::XPRSprob, description::Union{Nothing,AbstractString}, preset, maxjobs, data::Any)::XPRSprob
  if isnothing(description)
    description_pass = C_NULL
  else
    description_pass = description
  end
  presetxx = Int32(preset)
  maxjobsxx = Int32(maxjobs)
  data_node = CallbackNode()
  faddr = getFunctionAddress("XPRSmsaddpreset")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Ptr{Cvoid}), prob.handle, description_pass, presetxx, maxjobsxx, data_node)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  if data != nothing
    data_node.closure = data
    data_node.nin = ninxx
    data_node.nout = noutxx
    data_node.callback = Int32(1)
    linkMultistart(prob, data_node)
  end
  prob
end
export XPRSmsaddpreset

"""
    XPRSmsaddcustompreset(prob, description, preset, maxjobs, ninitial, colind, initial, nintcontrols, intcontrolid, intcontrolval, ndblcontrols, dblcontrolid, dblcontrolval, data)::prob

A combined version of XSLPmsaddjob and XSLPmsaddpreset.

The preset described is loaded, topped up with the specific settings supplied

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `description::Union{Nothing,AbstractString}`: Text description of the job.
- `preset::Integer`: Which preset to load.
- `maxjobs::Integer`: Maximum number of jobs to be added to the multistart pool.
- `ninitial::Integer`: Number of initial values to set.
- `colind::AbstractVector{Integer}`: Indices of the variables for which to set an initial value.
- `initial::AbstractVector{Number}`: Initial values for the variables for which to set an initial value.
- `nintcontrols::Integer`: Number of integer controls to set.
- `intcontrolid::AbstractVector{Integer}`: The indices of the integer controls to be set.
- `intcontrolval::AbstractVector{Integer}`: The values of the integer controls to be set.
- `ndblcontrols::Integer`: Number of double controls to set.
- `dblcontrolid::AbstractVector{Integer}`: The indices of the double controls to be set.
- `dblcontrolval::AbstractVector{Number}`: The values of the double controls to be set.
- `data::Any`: Job specific user context pointer to be passed to the multistart callbacks.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSmsaddcustompreset](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmsaddcustompreset.html) in the C API.
"""
function XPRSmsaddcustompreset(prob::XPRSprob, description::Union{Nothing,AbstractString}, preset, maxjobs, ninitial, colind, initial, nintcontrols, intcontrolid, intcontrolval, ndblcontrols, dblcontrolid, dblcontrolval, data::Any)::XPRSprob
  if isnothing(description)
    description_pass = C_NULL
  else
    description_pass = description
  end
  presetxx = Int32(preset)
  maxjobsxx = Int32(maxjobs)
  ninitialxx = Int32(ninitial)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(initial) || length(initial) == 0
    c_initial = nothing
  elseif isa(initial, AbstractVector{Float64})
    c_initial = initial
  else
    c_initial = convert(Vector{Float64}, initial)
  end
  nintcontrolsxx = Int32(nintcontrols)
  if isnothing(intcontrolid) || length(intcontrolid) == 0
    c_intcontrolid = nothing
  elseif isa(intcontrolid, AbstractVector{Int32})
    c_intcontrolid = intcontrolid
  else
    c_intcontrolid = convert(Vector{Int32}, intcontrolid)
  end
  if isnothing(intcontrolval) || length(intcontrolval) == 0
    c_intcontrolval = nothing
  elseif isa(intcontrolval, AbstractVector{Int32})
    c_intcontrolval = intcontrolval
  else
    c_intcontrolval = convert(Vector{Int32}, intcontrolval)
  end
  ndblcontrolsxx = Int32(ndblcontrols)
  if isnothing(dblcontrolid) || length(dblcontrolid) == 0
    c_dblcontrolid = nothing
  elseif isa(dblcontrolid, AbstractVector{Int32})
    c_dblcontrolid = dblcontrolid
  else
    c_dblcontrolid = convert(Vector{Int32}, dblcontrolid)
  end
  if isnothing(dblcontrolval) || length(dblcontrolval) == 0
    c_dblcontrolval = nothing
  elseif isa(dblcontrolval, AbstractVector{Float64})
    c_dblcontrolval = dblcontrolval
  else
    c_dblcontrolval = convert(Vector{Float64}, dblcontrolval)
  end
  data_node = CallbackNode()
  faddr = getFunctionAddress("XPRSmsaddcustompreset")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Ptr{Cint},Ptr{Cdouble},Cint,Ptr{Cint},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cvoid}), prob.handle, description_pass, presetxx, maxjobsxx, ninitialxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_initial) ? C_NULL : c_initial, nintcontrolsxx, isnothing(c_intcontrolid) ? C_NULL : c_intcontrolid, isnothing(c_intcontrolval) ? C_NULL : c_intcontrolval, ndblcontrolsxx, isnothing(c_dblcontrolid) ? C_NULL : c_dblcontrolid, isnothing(c_dblcontrolval) ? C_NULL : c_dblcontrolval, data_node)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  if data != nothing
    data_node.closure = data
    data_node.nin = ninxx
    data_node.nout = noutxx
    data_node.callback = Int32(1)
    linkMultistart(prob, data_node)
  end
  prob
end
export XPRSmsaddcustompreset

"""
    XPRSnlpsetfunctionerror(prob)::prob

Set the function error flag for the problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpsetfunctionerror](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpsetfunctionerror.html) in the C API.
"""
function XPRSnlpsetfunctionerror(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSnlpsetfunctionerror")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpsetfunctionerror

"""
    XPRSnlpprintevalinfo(prob)::prob

Print a summary of any evaluation errors that may have occurred during solving a problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpprintevalinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpprintevalinfo.html) in the C API.
"""
function XPRSnlpprintevalinfo(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSnlpprintevalinfo")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpprintevalinfo

"""
    XPRSnlpvalidate(prob)::prob

Validate the feasibility of constraints in a converged solution

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpvalidate](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpvalidate.html) in the C API.
"""
function XPRSnlpvalidate(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSnlpvalidate")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpvalidate

"""
    XPRSnlpoptimize(prob, flags)::prob

Maximize or minimize an SLP problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `flags::Union{Nothing,AbstractString}`: These have the same meaning as for `XPRSmaxim` and `XPRSminim`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpoptimize](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpoptimize.html) in the C API.
"""
function XPRSnlpoptimize(prob::XPRSprob, flags::Union{Nothing,AbstractString})::XPRSprob
  if isnothing(flags)
    flags_pass = C_NULL
  else
    flags_pass = flags
  end
  faddr = getFunctionAddress("XPRSnlpoptimize")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring), prob.handle, flags_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpoptimize

"""
    XPRSgetnlpsol(prob, x, slack, duals, djs)::x, slack, duals, djs

**Deprecated**Use XPRSgetsolution and related functions instead.

Obtain the current SLP solution values

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALCOLS` to hold the values of the primal variables.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALROWS` to hold the values of the slack variables.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALROWS` to hold the values of the dual variables.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALCOLS` to hold the reduced costs of the primal variables.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `x::Union{Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALCOLS` to hold the values of the primal variables.
- `slack::Union{Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALROWS` to hold the values of the slack variables.
- `duals::Union{Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALROWS` to hold the values of the dual variables.
- `djs::Union{Nothing,AbstractVector{Float64}}`: Double array of length `XSLP_ORIGINALCOLS` to hold the reduced costs of the primal variables.

See also the documentation of the correponding function [XPRSgetnlpsol](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSgetnlpsol.html) in the C API.
"""
function XPRSgetnlpsol(prob::XPRSprob, x::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, slack::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, duals::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, djs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Float64}}}
  if isa(djs, XPRSallocatable)
    djs = Vector{Float64}(undef, XPRSgetintattrib(prob, 1142))
  elseif djs != nothing
    if length(djs) < XPRSgetintattrib(prob, 1142)
      throw(XPRSexception("Argument djs is too short, needs " * (XPRSgetintattrib(prob, 1142)) * " elements but has only " * length(djs), nothing))
    end
  end
  if isa(duals, XPRSallocatable)
    duals = Vector{Float64}(undef, XPRSgetintattrib(prob, 1141))
  elseif duals != nothing
    if length(duals) < XPRSgetintattrib(prob, 1141)
      throw(XPRSexception("Argument duals is too short, needs " * (XPRSgetintattrib(prob, 1141)) * " elements but has only " * length(duals), nothing))
    end
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, 1141))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, 1141)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, 1141)) * " elements but has only " * length(slack), nothing))
    end
  end
  if isa(x, XPRSallocatable)
    x = Vector{Float64}(undef, XPRSgetintattrib(prob, 1142))
  elseif x != nothing
    if length(x) < XPRSgetintattrib(prob, 1142)
      throw(XPRSexception("Argument x is too short, needs " * (XPRSgetintattrib(prob, 1142)) * " elements but has only " * length(x), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSgetnlpsol")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(x) ? C_NULL : x, isnothing(slack) ? C_NULL : slack, isnothing(duals) ? C_NULL : duals, isnothing(djs) ? C_NULL : djs)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  x, slack, duals, djs
end
export XPRSgetnlpsol

"""
    XPRSnlpsetcurrentiv(prob)::prob

Transfer the current solution to initial values

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpsetcurrentiv](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpsetcurrentiv.html) in the C API.
"""
function XPRSnlpsetcurrentiv(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSnlpsetcurrentiv")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpsetcurrentiv

"""
    XPRSnlpvalidaterow(prob, row)::prob

Prints an extensive analysis on a given constraint of the SLP problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the row to be analyzed
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpvalidaterow](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpvalidaterow.html) in the C API.
"""
function XPRSnlpvalidaterow(prob::XPRSprob, row)::XPRSprob
  rowxx = Int32(row)
  faddr = getFunctionAddress("XPRSnlpvalidaterow")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, rowxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpvalidaterow

"""
    XPRSnlpvalidatekkt(prob, mode, respectbasis, updatemult, violtarget)::prob

Validates the first order optimality conditions also known as the Karush-Kuhn-Tucker (KKT) conditions versus the currect solution

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `mode::Integer`: The calculation mode can be: 0recalculate the reduced costs at the current solution using the current dual solution.
- `respectbasis::Integer`: The following ways are defined to assess if a constraint is active: 0evaluate the recalculated slack activity versus XSLP_ECFTOL_R.
- `updatemult::Integer`: The calculated values can be: 0only used to calculate the XSLP_VALIDATIONINDEX_K measure.
- `violtarget::Float64`: When calculating the best KKT multipliers, it is possible to enforce an even distribution of reduced costs violations by enforcing a bound on them.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpvalidatekkt](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpvalidatekkt.html) in the C API.
"""
function XPRSnlpvalidatekkt(prob::XPRSprob, mode, respectbasis, updatemult, violtarget)::XPRSprob
  modexx = Int32(mode)
  respectbasisxx = Int32(respectbasis)
  updatemultxx = Int32(updatemult)
  faddr = getFunctionAddress("XPRSnlpvalidatekkt")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Cdouble), prob.handle, modexx, respectbasisxx, updatemultxx, Float64(violtarget))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpvalidatekkt

"""
    XPRSmsclear(prob)::prob

Removes all scheduled jobs from the multistart job pool

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSmsclear](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSmsclear.html) in the C API.
"""
function XPRSmsclear(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSmsclear")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob.multistartsHead.next = prob.multistartsTail
  prob.multistartsTail.prev = prob.multistartsHead
  prob
end
export XPRSmsclear

"""
    XPRSnlpevaluateformula(prob, parsed, type, values)::value

Evaluate a formula using the current values of the variables

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `parsed::Integer`: integer indicating whether the formula of the item is in internal unparsed format (`parsed`=0) or parsed (reverse Polish) format (`parsed`=1).
- `type::AbstractVector{Integer}`: Integer array of token types for the formula.
- `values::AbstractVector{Number}`: Double array of values corresponding to `type`.
# Return value
- `value::Float64`: Address of a double precision value to receive the result of the calculation.

See also the documentation of the correponding function [XPRSnlpevaluateformula](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpevaluateformula.html) in the C API.
"""
function XPRSnlpevaluateformula(prob::XPRSprob, parsed, type, values)::Float64
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(values) || length(values) == 0
    c_values = nothing
  elseif isa(values, AbstractVector{Float64})
    c_values = values
  else
    c_values = convert(Vector{Float64}, values)
  end
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSnlpevaluateformula")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble},Ref{Cdouble}), prob.handle, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_values) ? C_NULL : c_values, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSnlpevaluateformula

"""
    XPRSnlpvalidatevector(prob, solution)::suminf, sumscaledinf, objval

Validate the feasibility of constraints for a given solution

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `solution::AbstractVector{Number}`: A vector of length `XPRS_COLS` containing the solution vector to be checked.
# Return values
- `suminf::Float64`: Pointer to double in which the sum of infeasibility will be returned.
- `sumscaledinf::Float64`: Pointer to double in which the sum of scaled (relative) infeasibility will be returned.
- `objval::Float64`: Pointer to double in which the net objective will be returned.

See also the documentation of the correponding function [XPRSnlpvalidatevector](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpvalidatevector.html) in the C API.
"""
function XPRSnlpvalidatevector(prob::XPRSprob, solution)::Tuple{Float64,Float64,Float64}
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  p_suminf_dummy = Ref{Float64}(0)
  p_sumscaledinf_dummy = Ref{Float64}(0)
  p_objval_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSnlpvalidatevector")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ref{Cdouble},Ref{Cdouble},Ref{Cdouble}), prob.handle, isnothing(c_solution) ? C_NULL : c_solution, p_suminf_dummy, p_sumscaledinf_dummy, p_objval_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_suminf = p_suminf_dummy[]
  p_sumscaledinf = p_sumscaledinf_dummy[]
  p_objval = p_objval_dummy[]
  p_suminf, p_sumscaledinf, p_objval
end
export XPRSnlpvalidatevector

"""
    XPRSnlpadduserfunctionmap(prob, funcname, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(value::Cdouble)::Cdouble
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionmap(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(1)
  nin = Int32(1)
  nout = Int32(1)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufmap, Cdouble, (Cdouble, Ptr{Cvoid}))
  data = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionmap")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, nin, nout, optionsxx, wrapper, data, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionmap

"""
    XPRSnlpadduserfunctionmapdelta(prob, funcname, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(value::Cdouble, delta::Cdouble)::Tuple{error::Cint,evaluation::Cdouble,partial::Cdouble}
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionmapdelta(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(4)
  nin = Int32(1)
  nout = Int32(1)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufmapdelta, Cint, (Cdouble, Cdouble, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cvoid}))
  func = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionmapdelta")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, nin, nout, optionsxx, wrapper, func, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionmapdelta

"""
    XPRSnlpadduserfunctionmultimap(prob, funcname, nin, nout, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(values::AbstractVector{Cdouble},out::AbstractVector{Cdouble})::Cint
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `nin::Integer`: Number of arguments the user function takes.
- `nout::Integer`: Number of return arguments for the function.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionmultimap(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, nin, nout, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(3)
  ninxx = Int32(nin)
  noutxx = Int32(nout)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufmultimap, Cint, (Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cvoid}))
  func = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionmultimap")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, ninxx, noutxx, optionsxx, wrapper, func, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionmultimap

"""
    XPRSnlpadduserfunctionmultimapdelta(prob, funcname, nin, nout, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(values::AbstractVector{Cdouble}, deltas::AbstractVector{Cdouble}, out::AbstractVector{Cdouble})::Tuple{Cint}
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `nin::Integer`: Number of arguments the user function takes.
- `nout::Integer`: Number of return arguments for the function.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionmultimapdelta(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, nin, nout, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(6)
  ninxx = Int32(nin)
  noutxx = Int32(nout)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufmultimapdelta, Cint, (Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cvoid}))
  func = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionmultimapdelta")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, ninxx, noutxx, optionsxx, wrapper, func, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionmultimapdelta

"""
    XPRSnlpadduserfunctionvecmap(prob, funcname, nin, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(values::AbstractVector{Cdouble})::Cdouble
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `nin::Integer`: Number of arguments the user function takes.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionvecmap(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, nin, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(2)
  ninxx = Int32(nin)
  nout = Int32(1)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufvecmap, Cdouble, (Ptr{Cdouble}, Ptr{Cvoid}))
  func = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionvecmap")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, ninxx, nout, optionsxx, wrapper, func, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionvecmap

"""
    XPRSnlpadduserfunctionvecmapdelta(prob, funcname, nin, options, func)::type

Add user function definitions to an SLP problem.

`func` is invoked with this signature
```
function(values::AbstractVector{Cdouble}, deltas::AbstractVector{Cdouble}, partials::AbstractVector{Cdouble})::Tuple{error::Cint,evaluation::Cdouble}
```
                

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `funcname::Union{Nothing,AbstractString}`: The name of the function as it appears in text formula expressions.
- `nin::Integer`: Number of arguments the user function takes.
- `options::Integer`: options as a bitmap to the user function XSLP_INSTANCEFUNCTIONalways instantiate the function.
- `func::Function`: Pointer of the user function to call.
# Return value
- `type::Int32`: The token id of the user function added, to be used in the Value array when defining formulas and using with `XSLP_FUN`.

See also the documentation of the correponding function [XPRSnlpadduserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpadduserfunction.html) in the C API.
"""
function XPRSnlpadduserfunctionvecmapdelta(prob::XPRSprob, funcname::Union{Nothing,AbstractString}, nin, options, func::Function)::Int32
  if isnothing(funcname)
    funcname_pass = C_NULL
  else
    funcname_pass = funcname
  end
  functype = Int32(5)
  ninxx = Int32(nin)
  nout = Int32(1)
  optionsxx = Int32(options)
  jcbnode = CallbackNode()
  wrapper = @cfunction(cbufvecmapdelta, Cint, (Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cvoid}))
  func = node
  p_type_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpadduserfunctionvecmapdelta")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cstring,Cint,Cint,Cint,Cint,Ptr{Cvoid},Ptr{Cvoid},Ref{Cint}), prob.handle, funcname_pass, functype, ninxx, nout, optionsxx, wrapper, func, p_type_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  jcbnode.closure = func
  jcbnode.callback = Int32(2)
  linkCallback(prob, jcbnode)
  p_type = p_type_dummy[]
  p_type
end
export XPRSnlpadduserfunctionvecmapdelta

"""
    XPRSnlpdeluserfunction(prob, type)::prob

Delete a user function from the current problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `type::Integer`: The identifier of the user function as returned by `XSLPadduserfunction`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpdeluserfunction](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpdeluserfunction.html) in the C API.
"""
function XPRSnlpdeluserfunction(prob::XPRSprob, type)::XPRSprob
  typexx = Int32(type)
  faddr = getFunctionAddress("XPRSnlpdeluserfunction")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), prob.handle, typexx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpdeluserfunction

"""
    XPRSnlpaddformulas(prob, ncoefs, rowind, formulastart, parsed, type, value)::prob

Add non-linear formulas to the SLP problem.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `ncoefs::Integer`: Number of non-linear coefficients to be added.
- `rowind::AbstractVector{Integer}`: Integer array holding index of row for the coefficient.
- `formulastart::AbstractVector{Integer}`: Integer array of length `ncoefs+1` holding the start position in the arrays `type` and `value` of the formula for the coefficients.
- `parsed::Integer`: Integer indicating whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the formula for each coefficient.
- `value::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpaddformulas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpaddformulas.html) in the C API.
"""
function XPRSnlpaddformulas(prob::XPRSprob, ncoefs, rowind, formulastart, parsed, type, value)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(formulastart) || length(formulastart) == 0
    c_formulastart = nothing
  elseif isa(formulastart, AbstractVector{Int32})
    c_formulastart = formulastart
  else
    c_formulastart = convert(Vector{Int32}, formulastart)
  end
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(value) || length(value) == 0
    c_value = nothing
  elseif isa(value, AbstractVector{Float64})
    c_value = value
  else
    c_value = convert(Vector{Float64}, value)
  end
  faddr = getFunctionAddress("XPRSnlpaddformulas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_formulastart) ? C_NULL : c_formulastart, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_value) ? C_NULL : c_value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpaddformulas

"""
    XPRSnlpchgformulastring(prob, row, formula)::prob

**Deprecated**Use XPRSnlpchgformulastr instead.

Add or replace a single matrix formula using a character string for the formula.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `formula::Union{Nothing,AbstractString}`: Character string holding the formula with the tokens separated by spaces.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpchgformulastring](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpchgformulastring.html) in the C API.
"""
function XPRSnlpchgformulastring(prob::XPRSprob, row, formula::Union{Nothing,AbstractString})::XPRSprob
  rowxx = Int32(row)
  if isnothing(formula)
    formula_pass = C_NULL
  else
    formula_pass = formula
  end
  faddr = getFunctionAddress("XPRSnlpchgformulastring")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring), prob.handle, rowxx, formula_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpchgformulastring

"""
    XPRSnlpchgformulastr(prob, row, formula)::prob

Add or replace a single matrix formula using a character string for the formula.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `formula::Union{Nothing,AbstractString}`: Character string holding the formula with the tokens separated by spaces.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSnlpchgformulastr](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpchgformulastr.html) in the C API.
"""
function XPRSnlpchgformulastr(prob::XPRSprob, row, formula::Union{Nothing,AbstractString})::XPRSprob
  rowxx = Int32(row)
  if isnothing(formula)
    formula_pass = C_NULL
  else
    formula_pass = formula
  end
  faddr = getFunctionAddress("XPRSnlpchgformulastr")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cstring), prob.handle, rowxx, formula_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpchgformulastr

"""
    XPRSnlpchgformula(prob, row, parsed, type, value)::prob

Add or replace a single matrix formula using a parsed or unparsed formula

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `parsed::Integer`: Integer indicating the whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the description and formula for each item.
- `value::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpchgformula](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpchgformula.html) in the C API.
"""
function XPRSnlpchgformula(prob::XPRSprob, row, parsed, type, value)::XPRSprob
  rowxx = Int32(row)
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(value) || length(value) == 0
    c_value = nothing
  elseif isa(value, AbstractVector{Float64})
    c_value = value
  else
    c_value = convert(Vector{Float64}, value)
  end
  faddr = getFunctionAddress("XPRSnlpchgformula")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_value) ? C_NULL : c_value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpchgformula

"""
    XPRSnlpgetformula(prob, row, parsed, maxtypes, type, value)::ntypes, type, value

Retrieve a single matrix formula as a formula split into tokens.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the formula.
- `parsed::Integer`: Integer indicating whether the formula of the row is to be returned in internal unparsed format (`parsed`=0) or parsed (reverse Polish) format (`parsed`=1).
- `maxtypes::Integer`: Maximum number of tokens to return, i.e., the length of the type and value arrays.
- `type::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array to hold the token types for the formula.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `value::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of values corresponding to `type`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ntypes::Int32`: Will be set to the length of the formula, including the `XSLP_EOF` token.
- `type::Union{Nothing,AbstractVector{Int32}}`: Integer array to hold the token types for the formula.
- `value::Union{Nothing,AbstractVector{Float64}}`: Double array of values corresponding to `type`.

See also the documentation of the correponding function [XPRSnlpgetformula](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpgetformula.html) in the C API.
"""
function XPRSnlpgetformula(prob::XPRSprob, row, parsed, maxtypes, type::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, value::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}}}
  rowxx = Int32(row)
  parsedxx = Int32(parsed)
  maxtypesxx = Int32(maxtypes)
  p_ntypes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpgetformula")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ref{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, parsedxx, maxtypesxx, p_ntypes_dummy, isnothing(type) ? C_NULL : type, isnothing(value) ? C_NULL : value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ntypes = p_ntypes_dummy[]
  p_ntypes, type, value
end
export XPRSnlpgetformula

"""
    XPRSnlpgetformularows(prob, rowind)::nformulas, rowind

Retrieve the list of positions of the nonlinear formulas in the problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `rowind::AbstractVector{Int32}`: Integer array used for returning the row positions of the nonlinear formulas.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return values
- `nformulas::Int32`: Integer used to return the total number of nonlinear formulas in the problem.
- `rowind::AbstractVector{Int32}`: Integer array used for returning the row positions of the nonlinear formulas.

See also the documentation of the correponding function [XPRSnlpgetformularows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpgetformularows.html) in the C API.
"""
function XPRSnlpgetformularows(prob::XPRSprob, rowind::AbstractVector{Int32})::Tuple{Int32,AbstractVector{Int32}}
  p_nformulas_dummy = Ref{Int32}(0)
  if isa(rowind, XPRSallocatable)
    rowind = Vector{Int32}(undef, 0)
  elseif rowind != nothing
    if length(rowind) < 0
      throw(XPRSexception("Argument rowind is too short, needs " * (0) * " elements but has only " * length(rowind), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSnlpgetformularows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cint}), prob.handle, p_nformulas_dummy, isnothing(rowind) ? C_NULL : rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_nformulas = p_nformulas_dummy[]
  p_nformulas, rowind
end
export XPRSnlpgetformularows

"""
    XPRSnlploadformulas(prob, nnlpcoefs, rowind, formulastart, parsed, type, value)::prob

Load non-linear formulas into the SLP problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `nnlpcoefs::Integer`: Number of non-linear coefficients to be loaded.
- `rowind::AbstractVector{Integer}`: Integer array holding index of row for the coefficient.
- `formulastart::AbstractVector{Integer}`: Integer array of length `nnlpcoefs+1` holding the start position in the arrays `type` and `value` of the formula for the coefficients.
- `parsed::Integer`: Integer indicating whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the formula for each coefficient.
- `value::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlploadformulas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlploadformulas.html) in the C API.
"""
function XPRSnlploadformulas(prob::XPRSprob, nnlpcoefs, rowind, formulastart, parsed, type, value)::XPRSprob
  nnlpcoefsxx = Int32(nnlpcoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(formulastart) || length(formulastart) == 0
    c_formulastart = nothing
  elseif isa(formulastart, AbstractVector{Int32})
    c_formulastart = formulastart
  else
    c_formulastart = convert(Vector{Int32}, formulastart)
  end
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(value) || length(value) == 0
    c_value = nothing
  elseif isa(value, AbstractVector{Float64})
    c_value = value
  else
    c_value = convert(Vector{Float64}, value)
  end
  faddr = getFunctionAddress("XPRSnlploadformulas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, nnlpcoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_formulastart) ? C_NULL : c_formulastart, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_value) ? C_NULL : c_value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlploadformulas

"""
    XPRSnlpdelformulas(prob, nformulas, rowind)::prob

Delete nonlinear formulas from the current problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `nformulas::Integer`: Number of SLP nonlinear formulas to delete.
- `rowind::AbstractVector{Integer}`: Row indices of the SLP nonlinear formulas to delete.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpdelformulas](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpdelformulas.html) in the C API.
"""
function XPRSnlpdelformulas(prob::XPRSprob, nformulas, rowind)::XPRSprob
  nformulasxx = Int32(nformulas)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSnlpdelformulas")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint}), prob.handle, nformulasxx, isnothing(c_rowind) ? C_NULL : c_rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlpdelformulas

"""
    XPRSnlpgetformulastring(prob, row, maxbytes)::formula

**Deprecated**Use XPRSnlpgetformulastr instead.

Retrieve a single matrix formula in a character string.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the formula.
- `maxbytes::Integer`: Maximum length of returned formula.
# Return value
- `formula::AbstractString`: Character buffer in which the formula will be placed in the same format as used for input from a file.

See also the documentation of the correponding function [XPRSnlpgetformulastring](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpgetformulastring.html) in the C API.
"""
function XPRSnlpgetformulastring(prob::XPRSprob, row, maxbytes)::AbstractString
  rowxx = Int32(row)
  formula_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  faddr = getFunctionAddress("XPRSnlpgetformulastring")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint), prob.handle, rowxx, formula_buffer, maxbytesxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  formula = unsafe_string(pointer(formula_buffer))
  formula
end
export XPRSnlpgetformulastring

"""
    XPRSnlpgetformulastr(prob, row, maxbytes)::formula, nbytes

Retrieve a single matrix formula in a character string.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the formula.
- `maxbytes::Integer`: Length of the `formula` buffer.
# Return values
- `formula::AbstractString`: Character buffer in which the formula will be placed in the same format as used for input from a file.
- `nbytes::Int32`: Will be set to the length of the formula, not including the null terminator.

See also the documentation of the correponding function [XPRSnlpgetformulastr](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpgetformulastr.html) in the C API.
"""
function XPRSnlpgetformulastr(prob::XPRSprob, row, maxbytes)::Tuple{AbstractString,Int32}
  rowxx = Int32(row)
  formula_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSnlpgetformulastr")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cchar},Cint,Ref{Cint}), prob.handle, rowxx, formula_buffer, maxbytesxx, p_nbytes_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  formula = unsafe_string(pointer(formula_buffer))
  p_nbytes = p_nbytes_dummy[]
  formula, p_nbytes
end
export XPRSnlpgetformulastr

"""
    XPRSnlpsetinitval(prob, nvars, colind, initial)::prob

Set the initial value of a variable

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `nvars::Integer`: Number of variables for which the initial value is to be set.
- `colind::AbstractVector{Integer}`: Array of length `nvars` with index of the column for which the initial value is provided.
- `initial::AbstractVector{Number}`: Array of length `nvars` with the initial value.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlpsetinitval](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpsetinitval.html) in the C API.
"""
function XPRSnlpsetinitval(prob::XPRSprob, nvars, colind, initial)::XPRSprob
  nvarsxx = Int32(nvars)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(initial) || length(initial) == 0
    c_initial = nothing
  elseif isa(initial, AbstractVector{Float64})
    c_initial = initial
  else
    c_initial = convert(Vector{Float64}, initial)
  end
  faddr = getFunctionAddress("XPRSnlpsetinitval")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, nvarsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_initial) ? C_NULL : c_initial)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end

"""
    XPRSnlpsetinitval(prob, vec)

Implementation of `XPRSnlpsetinitval` that combines arguments `nvars`, `colind`, `initial`
into a single argument `vec`. Note that the indices in `vec` must be specified
as 0-based indices.
"""
function XPRSnlpsetinitval(prob::XPRSprob, vec::AbstractSparseArray{Float64,Int32,1})::Nothing
  XPRSnlpsetinitval(prob, vec.n, vec.nzind, vec.nzval)
end

export XPRSnlpsetinitval

"""
    XPRSslpgetcoefformula(prob, row, col, parsed, maxtypes, type, value)::factor, ntypes, type, value

Retrieve a single matrix coefficient as a formula split into tokens.

For a simpler version of this function see XSLPchgformula.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the coefficient.
- `col::Integer`: Integer holding the column index for the coefficient.
- `parsed::Integer`: Integer indicating whether the formula of the item is to be returned in internal unparsed format (`parsed`=0) or parsed (reverse Polish) format (`parsed`=1).
- `maxtypes::Integer`: Maximum number of tokens to return, i.e. length of the `type` and `value` arrays.
- `type::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array to hold the token types for the formula.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `value::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of values corresponding to `type`.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `factor::Float64`: Address of a double precision variable to receive the value of the constant factor multiplying the formula in the coefficient.
- `ntypes::Int32`: Number of tokens returned in type and value.
- `type::Union{Nothing,AbstractVector{Int32}}`: Integer array to hold the token types for the formula.
- `value::Union{Nothing,AbstractVector{Float64}}`: Double array of values corresponding to `type`.

See also the documentation of the correponding function [XPRSslpgetcoefformula](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetcoefformula.html) in the C API.
"""
function XPRSslpgetcoefformula(prob::XPRSprob, row, col, parsed, maxtypes, type::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, value::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Float64,Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}}}
  rowxx = Int32(row)
  colxx = Int32(col)
  p_factor_dummy = Ref{Float64}(0)
  parsedxx = Int32(parsed)
  maxtypesxx = Int32(maxtypes)
  p_ntypes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpgetcoefformula")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble},Cint,Cint,Ref{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, colxx, p_factor_dummy, parsedxx, maxtypesxx, p_ntypes_dummy, isnothing(type) ? C_NULL : type, isnothing(value) ? C_NULL : value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_factor = p_factor_dummy[]
  p_ntypes = p_ntypes_dummy[]
  p_factor, p_ntypes, type, value
end
export XPRSslpgetcoefformula

"""
    XPRSslpgetcoefs(prob, rowind, colind)::ncoefs, rowind, colind

Retrieve the list of positions of the nonlinear coefficients in the problem.

For a simpler version of this function see XSLPgetformularows.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `rowind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array used for returning the row positions of the coefficients.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array used for returning the column positions of the coefficients.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `ncoefs::Int32`: Integer used to return the total number of nonlinear coefficients in the problem.
- `rowind::Union{Nothing,AbstractVector{Int32}}`: Integer array used for returning the row positions of the coefficients.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array used for returning the column positions of the coefficients.

See also the documentation of the correponding function [XPRSslpgetcoefs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetcoefs.html) in the C API.
"""
function XPRSslpgetcoefs(prob::XPRSprob, rowind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}})::Tuple{Int32,Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}}}
  p_ncoefs_dummy = Ref{Int32}(0)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, 0)
  elseif colind != nothing
    if length(colind) < 0
      throw(XPRSexception("Argument colind is too short, needs " * (0) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(rowind, XPRSallocatable)
    rowind = Vector{Int32}(undef, 0)
  elseif rowind != nothing
    if length(rowind) < 0
      throw(XPRSexception("Argument rowind is too short, needs " * (0) * " elements but has only " * length(rowind), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSslpgetcoefs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cint},Ptr{Cint}), prob.handle, p_ncoefs_dummy, isnothing(rowind) ? C_NULL : rowind, isnothing(colind) ? C_NULL : colind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_ncoefs = p_ncoefs_dummy[]
  p_ncoefs, rowind, colind
end
export XPRSslpgetcoefs

"""
    XPRSslploadcoefs(prob, ncoefs, rowind, colind, factor, formulastart, parsed, type, coef)::prob

Load non-linear coefficients into the SLP problem.

For a simpler version of this function see XSLPloadformulas.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `ncoefs::Integer`: Number of non-linear coefficients to be loaded.
- `rowind::AbstractVector{Integer}`: Integer array holding index of row for the coefficient.
- `colind::AbstractVector{Integer}`: Integer array holding index of column for the coefficient.
- `factor::AbstractVector{Number}`: Double array holding factor by which formula is scaled.
- `formulastart::AbstractVector{Integer}`: Integer array of length `ncoefs+1` holding the start position in the arrays `type` and `coef` of the formula for the coefficients.
- `parsed::Integer`: Integer indicating whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the formula for each coefficient.
- `coef::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslploadcoefs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslploadcoefs.html) in the C API.
"""
function XPRSslploadcoefs(prob::XPRSprob, ncoefs, rowind, colind, factor, formulastart, parsed, type, coef)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(factor) || length(factor) == 0
    c_factor = nothing
  elseif isa(factor, AbstractVector{Float64})
    c_factor = factor
  else
    c_factor = convert(Vector{Float64}, factor)
  end
  if isnothing(formulastart) || length(formulastart) == 0
    c_formulastart = nothing
  elseif isa(formulastart, AbstractVector{Int32})
    c_formulastart = formulastart
  else
    c_formulastart = convert(Vector{Int32}, formulastart)
  end
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(coef) || length(coef) == 0
    c_coef = nothing
  elseif isa(coef, AbstractVector{Float64})
    c_coef = coef
  else
    c_coef = convert(Vector{Float64}, coef)
  end
  faddr = getFunctionAddress("XPRSslploadcoefs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_factor) ? C_NULL : c_factor, isnothing(c_formulastart) ? C_NULL : c_formulastart, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_coef) ? C_NULL : c_coef)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslploadcoefs

"""
    XPRSslpdelcoefs(prob, ncoefs, rowind, colind)::prob

Delete coefficients from the current problem.

For a simpler version of this function see XSLPdelformulas.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `ncoefs::Integer`: Number of SLP coefficients to delete.
- `rowind::AbstractVector{Integer}`: Row indices of the SLP coefficients to delete.
- `colind::AbstractVector{Integer}`: Column indices of the SLP coefficients to delete.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpdelcoefs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpdelcoefs.html) in the C API.
"""
function XPRSslpdelcoefs(prob::XPRSprob, ncoefs, rowind, colind)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  faddr = getFunctionAddress("XPRSslpdelcoefs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpdelcoefs

"""
    XPRSslpgetccoef(prob, row, col, maxbytes)::factor, formula

**Deprecated**Use XPRSslpgetcoefstr instead.

Retrieve a single matrix coefficient as a formula in a character string. For a simpler version of this function see XPRSnlpgetformulastr.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the coefficient.
- `col::Integer`: Integer holding the column index for the coefficient.
- `maxbytes::Integer`: Maximum length of returned formula.
# Return values
- `factor::Float64`: Address of a double precision variable to receive the value of the constant factor multiplying the formula in the coefficient.
- `formula::AbstractString`: Character buffer in which the formula will be placed in the same format as used for input from a file.

See also the documentation of the correponding function [XPRSslpgetccoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetccoef.html) in the C API.
"""
function XPRSslpgetccoef(prob::XPRSprob, row, col, maxbytes)::Tuple{Float64,AbstractString}
  rowxx = Int32(row)
  colxx = Int32(col)
  p_factor_dummy = Ref{Float64}(0)
  formula_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  faddr = getFunctionAddress("XPRSslpgetccoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble},Ptr{Cchar},Cint), prob.handle, rowxx, colxx, p_factor_dummy, formula_buffer, maxbytesxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_factor = p_factor_dummy[]
  formula = unsafe_string(pointer(formula_buffer))
  p_factor, formula
end
export XPRSslpgetccoef

"""
    XPRSslpgetcoefstr(prob, row, col, maxbytes)::factor, formula, nbytes

Retrieve a single matrix coefficient as a formula in a character string.

For a simpler version of this function see XPRSnlpgetformulastr.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer holding the row index for the coefficient.
- `col::Integer`: Integer holding the column index for the coefficient.
- `maxbytes::Integer`: Length of the `formula` buffer.
# Return values
- `factor::Float64`: Address of a double precision variable to receive the value of the constant factor multiplying the formula in the coefficient.
- `formula::AbstractString`: Character buffer in which the formula will be placed in the same format as used for input from a file.
- `nbytes::Int32`: Will be set to the length of the formula, not including the null terminator.

See also the documentation of the correponding function [XPRSslpgetcoefstr](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetcoefstr.html) in the C API.
"""
function XPRSslpgetcoefstr(prob::XPRSprob, row, col, maxbytes)::Tuple{Float64,AbstractString,Int32}
  rowxx = Int32(row)
  colxx = Int32(col)
  p_factor_dummy = Ref{Float64}(0)
  formula_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpgetcoefstr")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble},Ptr{Cchar},Cint,Ref{Cint}), prob.handle, rowxx, colxx, p_factor_dummy, formula_buffer, maxbytesxx, p_nbytes_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_factor = p_factor_dummy[]
  formula = unsafe_string(pointer(formula_buffer))
  p_nbytes = p_nbytes_dummy[]
  p_factor, formula, p_nbytes
end
export XPRSslpgetcoefstr

"""
    XPRSslpsetdetrow(prob, nvars, colind, rowind)::prob

Set the determining row of a variable

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `nvars::Integer`: The number of variables for which determining rows are set.
- `colind::AbstractVector{Integer}`: Array of length `nvars` with the index of the column for which the determining row is set.
- `rowind::AbstractVector{Integer}`: Array of length `nvars` with the index of the determining row.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpsetdetrow](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpsetdetrow.html) in the C API.
"""
function XPRSslpsetdetrow(prob::XPRSprob, nvars, colind, rowind)::XPRSprob
  nvarsxx = Int32(nvars)
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  faddr = getFunctionAddress("XPRSslpsetdetrow")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint}), prob.handle, nvarsxx, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowind) ? C_NULL : c_rowind)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpsetdetrow

"""
    XPRSslpaddcoefs(prob, ncoefs, rowind, colind, factor, formulastart, parsed, type, value)::prob

Add non-linear coefficients to the SLP problem.

For a simpler version of this function see XSLPaddformulas.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `ncoefs::Integer`: Number of non-linear coefficients to be added.
- `rowind::AbstractVector{Integer}`: Integer array holding index of row for the coefficient.
- `colind::AbstractVector{Integer}`: Integer array holding index of column for the coefficient.
- `factor::AbstractVector{Number}`: Double array holding factor by which formula is scaled.
- `formulastart::AbstractVector{Integer}`: Integer array of length `ncoefs+1` holding the start position in the arrays `type` and `value` of the formula for the coefficients.
- `parsed::Integer`: Integer indicating whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the formula for each coefficient.
- `value::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpaddcoefs](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpaddcoefs.html) in the C API.
"""
function XPRSslpaddcoefs(prob::XPRSprob, ncoefs, rowind, colind, factor, formulastart, parsed, type, value)::XPRSprob
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowind) || length(rowind) == 0
    c_rowind = nothing
  elseif isa(rowind, AbstractVector{Int32})
    c_rowind = rowind
  else
    c_rowind = convert(Vector{Int32}, rowind)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(factor) || length(factor) == 0
    c_factor = nothing
  elseif isa(factor, AbstractVector{Float64})
    c_factor = factor
  else
    c_factor = convert(Vector{Float64}, factor)
  end
  if isnothing(formulastart) || length(formulastart) == 0
    c_formulastart = nothing
  elseif isa(formulastart, AbstractVector{Int32})
    c_formulastart = formulastart
  else
    c_formulastart = convert(Vector{Int32}, formulastart)
  end
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(value) || length(value) == 0
    c_value = nothing
  elseif isa(value, AbstractVector{Float64})
    c_value = value
  else
    c_value = convert(Vector{Float64}, value)
  end
  faddr = getFunctionAddress("XPRSslpaddcoefs")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble},Ptr{Cint},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, ncoefsxx, isnothing(c_rowind) ? C_NULL : c_rowind, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_factor) ? C_NULL : c_factor, isnothing(c_formulastart) ? C_NULL : c_formulastart, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_value) ? C_NULL : c_value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpaddcoefs

"""
    XPRSslpchgccoef(prob, row, col, factor, formula)::prob

**Deprecated**Use XPRSslpchgcoefstr instead.

Add or change a single matrix coefficient using a character string for the formula. For a simpler version of this function see XPRSnlpchgformulastr.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `col::Integer`: The index of the matrix column for the coefficient.
- `factor::Union{Nothing,Float64}`: Address of a double precision variable holding the constant multiplier for the formula.
- `formula::Union{Nothing,AbstractString}`: Character string holding the formula with the tokens separated by spaces.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpchgccoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgccoef.html) in the C API.
"""
function XPRSslpchgccoef(prob::XPRSprob, row, col, factor::Union{Nothing,Float64}, formula::Union{Nothing,AbstractString})::XPRSprob
  rowxx = Int32(row)
  colxx = Int32(col)
  if factor != nothing
    factor_arg = Ref{Float64}(factor)
  else
    factor_arg = nothing
  end
  if isnothing(formula)
    formula_pass = C_NULL
  else
    formula_pass = formula
  end
  faddr = getFunctionAddress("XPRSslpchgccoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cvoid},Cstring), prob.handle, rowxx, colxx, factor_arg, formula_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgccoef

"""
    XPRSslpchgcoefstr(prob, row, col, factor, formula)::prob

Add or change a single matrix coefficient using a character string for the formula.

For a simpler version of this function see XPRSnlpchgformulastr.

# Arguments
- `prob::XPRSprob`: The current problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `col::Integer`: The index of the matrix column for the coefficient.
- `factor::Union{Nothing,Float64}`: Address of a double precision variable holding the constant multiplier for the formula.
- `formula::Union{Nothing,AbstractString}`: Character string holding the formula with the tokens separated by spaces.
# Return value
- `prob::XPRSprob`: The current problem.

See also the documentation of the correponding function [XPRSslpchgcoefstr](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgcoefstr.html) in the C API.
"""
function XPRSslpchgcoefstr(prob::XPRSprob, row, col, factor::Union{Nothing,Float64}, formula::Union{Nothing,AbstractString})::XPRSprob
  rowxx = Int32(row)
  colxx = Int32(col)
  if factor != nothing
    factor_arg = Ref{Float64}(factor)
  else
    factor_arg = nothing
  end
  if isnothing(formula)
    formula_pass = C_NULL
  else
    formula_pass = formula
  end
  faddr = getFunctionAddress("XPRSslpchgcoefstr")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cvoid},Cstring), prob.handle, rowxx, colxx, factor_arg, formula_pass)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgcoefstr

"""
    XPRSslpchgcoef(prob, row, col, factor, parsed, type, value)::prob

Add or change a single matrix coefficient using a parsed or unparsed formula.

For a simpler version of this function see XSLPchgformula.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row for the coefficient.
- `col::Integer`: The index of the matrix column for the coefficient.
- `factor::Union{Nothing,Float64}`: Address of a double precision variable holding the constant multiplier for the formula.
- `parsed::Integer`: Integer indicating the whether the token arrays are formatted as internal unparsed (`parsed`=0) or internal parsed reverse Polish (`parsed`=1).
- `type::AbstractVector{Integer}`: Array of token types providing the description and formula for each item.
- `value::AbstractVector{Number}`: Array of values corresponding to the types in `type`.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpchgcoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgcoef.html) in the C API.
"""
function XPRSslpchgcoef(prob::XPRSprob, row, col, factor::Union{Nothing,Float64}, parsed, type, value)::XPRSprob
  rowxx = Int32(row)
  colxx = Int32(col)
  if factor != nothing
    factor_arg = Ref{Float64}(factor)
  else
    factor_arg = nothing
  end
  parsedxx = Int32(parsed)
  if isnothing(type) || length(type) == 0
    c_type = nothing
  elseif isa(type, AbstractVector{Int32})
    c_type = type
  else
    c_type = convert(Vector{Int32}, type)
  end
  if isnothing(value) || length(value) == 0
    c_value = nothing
  elseif isa(value, AbstractVector{Float64})
    c_value = value
  else
    c_value = convert(Vector{Float64}, value)
  end
  faddr = getFunctionAddress("XPRSslpchgcoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cdouble}), prob.handle, rowxx, colxx, factor_arg, parsedxx, isnothing(c_type) ? C_NULL : c_type, isnothing(c_value) ? C_NULL : c_value)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgcoef

"""
    XPRSslpgetcolinfoint(prob, type, col)::info

Get current column information.

# Arguments
- `prob::XPRSprob`: The current SLP problem
- `type::Integer`: Type of information (see below)
- `col::Integer`: Index of the column whose information is to be handled
# Return value
- `info::Int32`: Address of information to be set or retrieved

See also the documentation of the correponding function [XPRSslpgetcolinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetcolinfo.html) in the C API.
"""
function XPRSslpgetcolinfoint(prob::XPRSprob, type, col)::Int32
  typexx = Int32(type)
  colxx = Int32(col)
  p_info_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpgetcolinfoint")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint}), prob.handle, typexx, colxx, p_info_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_info = p_info_dummy[]
  p_info
end
export XPRSslpgetcolinfoint

"""
    XPRSslpgetcolinfodouble(prob, type, col)::info

Get current column information.

# Arguments
- `prob::XPRSprob`: The current SLP problem
- `type::Integer`: Type of information (see below)
- `col::Integer`: Index of the column whose information is to be handled
# Return value
- `info::Float64`: Address of information to be set or retrieved

See also the documentation of the correponding function [XPRSslpgetcolinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetcolinfo.html) in the C API.
"""
function XPRSslpgetcolinfodouble(prob::XPRSprob, type, col)::Float64
  typexx = Int32(type)
  colxx = Int32(col)
  p_info_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSslpgetcolinfodouble")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, typexx, colxx, p_info_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_info = p_info_dummy[]
  p_info
end
export XPRSslpgetcolinfodouble

"""
    XPRSslpgetrowinfoint(prob, type, row)::info

Get current row information.

# Arguments
- `prob::XPRSprob`: The current SLP problem
- `type::Integer`: Type of information (see below)
- `row::Integer`: Index of the row whose information is to be handled
# Return value
- `info::Int32`: Address of information to be set or retrieved

See also the documentation of the correponding function [XPRSslpgetrowinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetrowinfo.html) in the C API.
"""
function XPRSslpgetrowinfoint(prob::XPRSprob, type, row)::Int32
  typexx = Int32(type)
  rowxx = Int32(row)
  p_info_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpgetrowinfoint")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cint}), prob.handle, typexx, rowxx, p_info_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_info = p_info_dummy[]
  p_info
end
export XPRSslpgetrowinfoint

"""
    XPRSslpgetrowinfodouble(prob, type, row)::info

Get current row information.

# Arguments
- `prob::XPRSprob`: The current SLP problem
- `type::Integer`: Type of information (see below)
- `row::Integer`: Index of the row whose information is to be handled
# Return value
- `info::Float64`: Address of information to be set or retrieved

See also the documentation of the correponding function [XPRSslpgetrowinfo](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetrowinfo.html) in the C API.
"""
function XPRSslpgetrowinfodouble(prob::XPRSprob, type, row)::Float64
  typexx = Int32(type)
  rowxx = Int32(row)
  p_info_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSslpgetrowinfodouble")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, typexx, rowxx, p_info_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_info = p_info_dummy[]
  p_info
end
export XPRSslpgetrowinfodouble

"""
    XPRSslpcascade(prob)::prob

Re-calculate consistent values for SLP variables based on the current values of the remaining variables.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpcascade](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpcascade.html) in the C API.
"""
function XPRSslpcascade(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpcascade")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpcascade

"""
    XPRSslpcascadeorder(prob)::prob

Establish a re-calculation sequence for SLP variables with determining rows.

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpcascadeorder](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpcascadeorder.html) in the C API.
"""
function XPRSslpcascadeorder(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpcascadeorder")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpcascadeorder

"""
    XPRSslpchgrowstatus(prob, row)::status

Change the status setting of a constraint

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row to be changed.
# Return value
- `status::Int32`: Address of an integer holding a bitmap with the new status settings.

See also the documentation of the correponding function [XPRSslpchgrowstatus](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgrowstatus.html) in the C API.
"""
function XPRSslpchgrowstatus(prob::XPRSprob, row)::Int32
  rowxx = Int32(row)
  status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpchgrowstatus")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, rowxx, status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  status = status_dummy[]
  status
end
export XPRSslpchgrowstatus

"""
    XPRSslpchgrowwt(prob, row, weight)::prob

Set or change the initial penalty error weight for a row

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the row whose weight is to be set or changed.
- `weight::Union{Nothing,Float64}`: Address of a double precision variable holding the new value of the weight.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpchgrowwt](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgrowwt.html) in the C API.
"""
function XPRSslpchgrowwt(prob::XPRSprob, row, weight::Union{Nothing,Float64})::XPRSprob
  rowxx = Int32(row)
  if weight != nothing
    weight_arg = Ref{Float64}(weight)
  else
    weight_arg = nothing
  end
  faddr = getFunctionAddress("XPRSslpchgrowwt")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cvoid}), prob.handle, rowxx, weight_arg)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgrowwt

"""
    XPRSslpchgdeltatype(prob, nvars, varind, deltatypes, values)::prob

Changes the type of the delta assigned to a nonlinear variable

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `nvars::Integer`: The number of SLP variables to change the delta type for.
- `varind::AbstractVector{Integer}`: Indices of the variables to change the deltas for.
- `deltatypes::AbstractVector{Integer}`: Type if the delta variable: 0Differentiable variable, default.
- `values::AbstractVector{Number}`: Grid or minimum step sizes for the variables.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpchgdeltatype](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgdeltatype.html) in the C API.
"""
function XPRSslpchgdeltatype(prob::XPRSprob, nvars, varind, deltatypes, values)::XPRSprob
  nvarsxx = Int32(nvars)
  if isnothing(varind) || length(varind) == 0
    c_varind = nothing
  elseif isa(varind, AbstractVector{Int32})
    c_varind = varind
  else
    c_varind = convert(Vector{Int32}, varind)
  end
  if isnothing(deltatypes) || length(deltatypes) == 0
    c_deltatypes = nothing
  elseif isa(deltatypes, AbstractVector{Int32})
    c_deltatypes = deltatypes
  else
    c_deltatypes = convert(Vector{Int32}, deltatypes)
  end
  if isnothing(values) || length(values) == 0
    c_values = nothing
  elseif isa(values, AbstractVector{Float64})
    c_values = values
  else
    c_values = convert(Vector{Float64}, values)
  end
  faddr = getFunctionAddress("XPRSslpchgdeltatype")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), prob.handle, nvarsxx, isnothing(c_varind) ? C_NULL : c_varind, isnothing(c_deltatypes) ? C_NULL : c_deltatypes, isnothing(c_values) ? C_NULL : c_values)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgdeltatype

"""
    XPRSslpchgcascadenlimit(prob, col, limit)::prob

Set a variable specific cascade iteration limit

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `col::Integer`: The index of the column corresponding to the SLP variable for which the cascading limit is to be imposed.
- `limit::Integer`: The new cascading iteration limit.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpchgcascadenlimit](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpchgcascadenlimit.html) in the C API.
"""
function XPRSslpchgcascadenlimit(prob::XPRSprob, col, limit)::XPRSprob
  colxx = Int32(col)
  limitxx = Int32(limit)
  faddr = getFunctionAddress("XPRSslpchgcascadenlimit")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint), prob.handle, colxx, limitxx)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpchgcascadenlimit

"""
    XPRSslpconstruct(prob)::prob

Create the full augmented SLP matrix and data structures, ready for optimization

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpconstruct](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpconstruct.html) in the C API.
"""
function XPRSslpconstruct(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpconstruct")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpconstruct

"""
    XPRSslpgetrowstatus(prob, row)::status

Retrieve the status setting of a constraint

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the matrix row whose data is to be obtained.
# Return value
- `status::Int32`: Address of an integer holding a bitmap to receive the status settings.

See also the documentation of the correponding function [XPRSslpgetrowstatus](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetrowstatus.html) in the C API.
"""
function XPRSslpgetrowstatus(prob::XPRSprob, row)::Int32
  rowxx = Int32(row)
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpgetrowstatus")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint}), prob.handle, rowxx, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSslpgetrowstatus

"""
    XPRSslpgetrowwt(prob, row)::weight

Get the initial penalty error weight for a row

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: The index of the row whose weight is to be retrieved.
# Return value
- `weight::Float64`: Address of a double precision variable to receive the value of the weight.

See also the documentation of the correponding function [XPRSslpgetrowwt](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpgetrowwt.html) in the C API.
"""
function XPRSslpgetrowwt(prob::XPRSprob, row)::Float64
  rowxx = Int32(row)
  p_weight_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSslpgetrowwt")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cdouble}), prob.handle, rowxx, p_weight_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_weight = p_weight_dummy[]
  p_weight
end
export XPRSslpgetrowwt

"""
    XPRSslpevaluatecoef(prob, row, col)::value

Evaluate a coefficient using the current values of the variables

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `row::Integer`: Integer index of the row.
- `col::Integer`: Integer index of the column.
# Return value
- `value::Float64`: Address of a double precision value to receive the result of the calculation.

See also the documentation of the correponding function [XPRSslpevaluatecoef](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpevaluatecoef.html) in the C API.
"""
function XPRSslpevaluatecoef(prob::XPRSprob, row, col)::Float64
  rowxx = Int32(row)
  colxx = Int32(col)
  p_value_dummy = Ref{Float64}(0)
  faddr = getFunctionAddress("XPRSslpevaluatecoef")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ref{Cdouble}), prob.handle, rowxx, colxx, p_value_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_value = p_value_dummy[]
  p_value
end
export XPRSslpevaluatecoef

"""
    XPRSslpreinitialize(prob)::prob

Reset the SLP problem to match a just augmented system

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpreinitialize](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpreinitialize.html) in the C API.
"""
function XPRSslpreinitialize(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpreinitialize")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpreinitialize

"""
    XPRSslpunconstruct(prob)::prob

Removes the augmentation and returns the problem to its pre-linearization state

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpunconstruct](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpunconstruct.html) in the C API.
"""
function XPRSslpunconstruct(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpunconstruct")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpunconstruct

"""
    XPRSslpupdatelinearization(prob)::prob

Updates the current linearization

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSslpupdatelinearization](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpupdatelinearization.html) in the C API.
"""
function XPRSslpupdatelinearization(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSslpupdatelinearization")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSslpupdatelinearization

"""
    XPRSslpfixpenalties(prob)::status

Fixe the values of the error vectors

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `status::Int32`: Return status after fixing the penalty variables: 0 is successful, nonzero otherwise.

See also the documentation of the correponding function [XPRSslpfixpenalties](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSslpfixpenalties.html) in the C API.
"""
function XPRSslpfixpenalties(prob::XPRSprob)::Int32
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRSslpfixpenalties")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), prob.handle, p_status_dummy)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRSslpfixpenalties

"""
    XPRSnlppostsolve(prob)::prob

Restores the problem to its pre-solve state

# Arguments
- `prob::XPRSprob`: The current SLP problem.
# Return value
- `prob::XPRSprob`: The current SLP problem.

See also the documentation of the correponding function [XPRSnlppostsolve](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlppostsolve.html) in the C API.
"""
function XPRSnlppostsolve(prob::XPRSprob)::XPRSprob
  faddr = getFunctionAddress("XPRSnlppostsolve")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},), prob.handle)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  prob
end
export XPRSnlppostsolve

"""
    XPRSnlpcalcslacks(prob, solution, slack)::slack

Calculate the slack values for the provided solution in the non-linear problem

# Arguments
- `prob::XPRSprob`: The current SLP problem.
- `solution::AbstractVector{Number}`: The solution for which the slacks are requested for.
- `slack::Union{XPRSallocatable,AbstractVector{Float64}}`: Vector of length NROWS to return the slack in.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
# Return value
- `slack::AbstractVector{Float64}`: Vector of length NROWS to return the slack in.

See also the documentation of the correponding function [XPRSnlpcalcslacks](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRSnlpcalcslacks.html) in the C API.
"""
function XPRSnlpcalcslacks(prob::XPRSprob, solution, slack::Union{XPRSallocatable,AbstractVector{Float64}})::AbstractVector{Float64}
  if isnothing(solution) || length(solution) == 0
    c_solution = nothing
  elseif isa(solution, AbstractVector{Float64})
    c_solution = solution
  else
    c_solution = convert(Vector{Float64}, solution)
  end
  if isa(slack, XPRSallocatable)
    slack = Vector{Float64}(undef, XPRSgetintattrib(prob, 1141))
  elseif slack != nothing
    if length(slack) < XPRSgetintattrib(prob, 1141)
      throw(XPRSexception("Argument slack is too short, needs " * (XPRSgetintattrib(prob, 1141)) * " elements but has only " * length(slack), nothing))
    end
  end
  faddr = getFunctionAddress("XPRSnlpcalcslacks")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ptr{Cdouble},Ptr{Cdouble}), prob.handle, isnothing(c_solution) ? C_NULL : c_solution, isnothing(slack) ? C_NULL : slack)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob), nothing))
  end
  slack
end
export XPRSnlpcalcslacks

"""
    XPRS_bo_store(bo)::status

Adds a new user branching object to the Optimizer's list of candidates for branching.

This function is available only through the callback function set by XPRSaddcboptnode.

# Arguments
- `bo::XPRSbranchobject`: The new user branching object to store.
# Return value
- `status::Int32`: The returned status from checking the provided branching object: 0The object was accepted successfully.

See also the documentation of the correponding function [XPRS_bo_store](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_store.html) in the C API.
"""
function XPRS_bo_store(bo::XPRSbranchobject)::Int32
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_bo_store")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), bo.handle, p_status_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRS_bo_store

"""
    XPRS_bo_addbranches(bo, nbranches)::Nothing

Adds new, empty branches to a user defined branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to modify.
- `nbranches::Integer`: Number of new branches to create.

See also the documentation of the correponding function [XPRS_bo_addbranches](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_addbranches.html) in the C API.
"""
function XPRS_bo_addbranches(bo::XPRSbranchobject, nbranches)::Nothing
  nbranchesxx = Int32(nbranches)
  faddr = getFunctionAddress("XPRS_bo_addbranches")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), bo.handle, nbranchesxx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_addbranches

"""
    XPRS_bo_getbranches(bo)::nbranches

Returns the number of branches of a branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to inspect.
# Return value
- `nbranches::Int32`: Memory where the number of branches should be returned.

See also the documentation of the correponding function [XPRS_bo_getbranches](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_getbranches.html) in the C API.
"""
function XPRS_bo_getbranches(bo::XPRSbranchobject)::Int32
  p_nbranches_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_bo_getbranches")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), bo.handle, p_nbranches_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_nbranches = p_nbranches_dummy[]
  p_nbranches
end
export XPRS_bo_getbranches

"""
    XPRS_bo_setpriority(bo, priority)::Nothing

Sets the priority value of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object.
- `priority::Integer`: The new priority value to assign to the branching object, which must be a number from 0 to 1000.

See also the documentation of the correponding function [XPRS_bo_setpriority](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_setpriority.html) in the C API.
"""
function XPRS_bo_setpriority(bo::XPRSbranchobject, priority)::Nothing
  priorityxx = Int32(priority)
  faddr = getFunctionAddress("XPRS_bo_setpriority")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), bo.handle, priorityxx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_setpriority

"""
    XPRS_bo_setpreferredbranch(bo, branch)::Nothing

Specifies which of the child nodes corresponding to the branches of the object should be explored first.

# Arguments
- `bo::XPRSbranchobject`: The user branching object.
- `branch::Integer`: The number of the branch to mark as preferred.

See also the documentation of the correponding function [XPRS_bo_setpreferredbranch](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_setpreferredbranch.html) in the C API.
"""
function XPRS_bo_setpreferredbranch(bo::XPRSbranchobject, branch)::Nothing
  branchxx = Int32(branch)
  faddr = getFunctionAddress("XPRS_bo_setpreferredbranch")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint), bo.handle, branchxx)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_setpreferredbranch

"""
    XPRS_bo_addbounds(bo, branch, nbounds, bndtype, colind, bndval)::Nothing

Adds new bounds to a branch of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to modify.
- `branch::Integer`: The number of the branch to add the new bounds for.
- `nbounds::Integer`: Number of new bounds to add.
- `bndtype::AbstractVector{Cchar}`: Character array of length `nbounds` indicating the type of bounds to add: LLower bound.
- `colind::AbstractVector{Integer}`: Integer array of length `nbounds` containing the column indices for the new bounds.
- `bndval::AbstractVector{Number}`: Double array of length `nbounds` giving the bound values.

See also the documentation of the correponding function [XPRS_bo_addbounds](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_addbounds.html) in the C API.
"""
function XPRS_bo_addbounds(bo::XPRSbranchobject, branch, nbounds, bndtype, colind, bndval)::Nothing
  branchxx = Int32(branch)
  nboundsxx = Int32(nbounds)
  if isnothing(bndtype) || length(bndtype) == 0
    c_bndtype = nothing
  elseif isa(bndtype, AbstractVector{Cchar})
    c_bndtype = bndtype
  else
    c_bndtype = convert(Vector{Cchar}, bndtype)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(bndval) || length(bndval) == 0
    c_bndval = nothing
  elseif isa(bndval, AbstractVector{Float64})
    c_bndval = bndval
  else
    c_bndval = convert(Vector{Float64}, bndval)
  end
  faddr = getFunctionAddress("XPRS_bo_addbounds")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble}), bo.handle, branchxx, nboundsxx, isnothing(c_bndtype) ? C_NULL : c_bndtype, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_bndval) ? C_NULL : c_bndval)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_addbounds

"""
    XPRS_bo_getbounds(bo, branch, maxbounds, bndtype, colind, bndval)::nbounds, bndtype, colind, bndval

Returns the bounds for a branch of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The branching object to inspect.
- `branch::Integer`: The number of the branch to get the bounds for.
- `maxbounds::Integer`: Maximum number of bounds to return.
- `bndtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `maxbounds` where the types of bounds will be returned: LLower bound.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `maxbounds` where the column indices will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `bndval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxbounds` where the bound values will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `nbounds::Int32`: Location where the number of bounds for the given branch should be returned.
- `bndtype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `maxbounds` where the types of bounds will be returned: LLower bound.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `maxbounds` where the column indices will be returned.
- `bndval::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxbounds` where the bound values will be returned.

See also the documentation of the correponding function [XPRS_bo_getbounds](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_getbounds.html) in the C API.
"""
function XPRS_bo_getbounds(bo::XPRSbranchobject, branch, maxbounds, bndtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, bndval::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}}}
  branchxx = Int32(branch)
  p_nbounds_dummy = Ref{Int32}(0)
  maxboundsxx = Int32(maxbounds)
  if isa(bndtype, XPRSallocatable)
    bndtype = Vector{Cchar}(undef, maxbounds)
  elseif bndtype != nothing
    if length(bndtype) < maxbounds
      throw(XPRSexception("Argument bndtype is too short, needs " * (maxbounds) * " elements but has only " * length(bndtype), nothing))
    end
  end
  if isa(bndval, XPRSallocatable)
    bndval = Vector{Float64}(undef, maxbounds)
  elseif bndval != nothing
    if length(bndval) < maxbounds
      throw(XPRSexception("Argument bndval is too short, needs " * (maxbounds) * " elements but has only " * length(bndval), nothing))
    end
  end
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, maxbounds)
  elseif colind != nothing
    if length(colind) < maxbounds
      throw(XPRSexception("Argument colind is too short, needs " * (maxbounds) * " elements but has only " * length(colind), nothing))
    end
  end
  faddr = getFunctionAddress("XPRS_bo_getbounds")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint},Cint,Ptr{Cchar},Ptr{Cint},Ptr{Cdouble}), bo.handle, branchxx, p_nbounds_dummy, maxboundsxx, isnothing(bndtype) ? C_NULL : bndtype, isnothing(colind) ? C_NULL : colind, isnothing(bndval) ? C_NULL : bndval)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_nbounds = p_nbounds_dummy[]
  p_nbounds, bndtype, colind, bndval
end
export XPRS_bo_getbounds

"""
    XPRS_bo_addrows(bo, branch, nrows, ncoefs, rowtype, rhs, start, colind, rowcoef)::Nothing

Adds new constraints to a branch of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to modify.
- `branch::Integer`: The number of the branch to add the new constraints for.
- `nrows::Integer`: Number of new constraints to add.
- `ncoefs::Integer`: Number of non-zero coefficients in all new constraints.
- `rowtype::AbstractVector{Cchar}`: Character array of length `nrows` indicating the type of constraints to add: LLess than type.
- `rhs::AbstractVector{Number}`: Double array of length `nrows` containing the right hand side values.
- `start::AbstractVector{Integer}`: Integer array of length `nrows` containing the offsets of the `colind` and `rowcoef` arrays of the start of the non zero coefficients in the new constraints.
- `colind::AbstractVector{Integer}`: Integer array of length `ncoefs` containing the column indices for the non zero coefficients.
- `rowcoef::AbstractVector{Number}`: Double array of length `ncoefs` containing the non zero coefficient values.

See also the documentation of the correponding function [XPRS_bo_addrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_addrows.html) in the C API.
"""
function XPRS_bo_addrows(bo::XPRSbranchobject, branch, nrows, ncoefs, rowtype, rhs, start, colind, rowcoef)::Nothing
  branchxx = Int32(branch)
  nrowsxx = Int32(nrows)
  ncoefsxx = Int32(ncoefs)
  if isnothing(rowtype) || length(rowtype) == 0
    c_rowtype = nothing
  elseif isa(rowtype, AbstractVector{Cchar})
    c_rowtype = rowtype
  else
    c_rowtype = convert(Vector{Cchar}, rowtype)
  end
  if isnothing(rhs) || length(rhs) == 0
    c_rhs = nothing
  elseif isa(rhs, AbstractVector{Float64})
    c_rhs = rhs
  else
    c_rhs = convert(Vector{Float64}, rhs)
  end
  if isnothing(start) || length(start) == 0
    c_start = nothing
  elseif isa(start, AbstractVector{Int32})
    c_start = start
  else
    c_start = convert(Vector{Int32}, start)
  end
  if isnothing(colind) || length(colind) == 0
    c_colind = nothing
  elseif isa(colind, AbstractVector{Int32})
    c_colind = colind
  else
    c_colind = convert(Vector{Int32}, colind)
  end
  if isnothing(rowcoef) || length(rowcoef) == 0
    c_rowcoef = nothing
  elseif isa(rowcoef, AbstractVector{Float64})
    c_rowcoef = rowcoef
  else
    c_rowcoef = convert(Vector{Float64}, rowcoef)
  end
  faddr = getFunctionAddress("XPRS_bo_addrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), bo.handle, branchxx, nrowsxx, ncoefsxx, isnothing(c_rowtype) ? C_NULL : c_rowtype, isnothing(c_rhs) ? C_NULL : c_rhs, isnothing(c_start) ? C_NULL : c_start, isnothing(c_colind) ? C_NULL : c_colind, isnothing(c_rowcoef) ? C_NULL : c_rowcoef)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_addrows

"""
    XPRS_bo_getrows(bo, branch, maxrows, maxcoefs, rowtype, rhs, start, colind, rowcoef)::nrows, ncoefs, rowtype, rhs, start, colind, rowcoef

Returns the constraints for a branch of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to inspect.
- `branch::Integer`: The number of the branch to get the constraints from.
- `maxrows::Integer`: Maximum number of rows to return.
- `maxcoefs::Integer`: Maximum number of non zero coefficients to return.
- `rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}`: Character array of length `maxrows` where the types of the rows will be returned: LLess than type.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxrows` where the right hand side values will be returned.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `start::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `maxrows` which will be filled with the offsets of the `colind` and `rowcoef` arrays of the start of the non zero coefficients in the returned constraints.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}`: Integer array of length `maxcoefs` which will be filled with the column indices for the non zero coefficients.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
- `rowcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}`: Double array of length `maxcoefs` which will be filled with the non zero coefficient values.
  You may pass `XPRS_ALLOC` for this argument to have the function allocate an array of appropriate size for you.
  You may pass `nothing` for this argument to not query that information.
# Return values
- `nrows::Int32`: Memory location where the number of rows should be returned.
- `ncoefs::Int32`: Memory location where the number of non zero coefficients in the constraints should be returned.
- `rowtype::Union{Nothing,AbstractVector{Cchar}}`: Character array of length `maxrows` where the types of the rows will be returned: LLess than type.
- `rhs::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxrows` where the right hand side values will be returned.
- `start::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `maxrows` which will be filled with the offsets of the `colind` and `rowcoef` arrays of the start of the non zero coefficients in the returned constraints.
- `colind::Union{Nothing,AbstractVector{Int32}}`: Integer array of length `maxcoefs` which will be filled with the column indices for the non zero coefficients.
- `rowcoef::Union{Nothing,AbstractVector{Float64}}`: Double array of length `maxcoefs` which will be filled with the non zero coefficient values.

See also the documentation of the correponding function [XPRS_bo_getrows](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_getrows.html) in the C API.
"""
function XPRS_bo_getrows(bo::XPRSbranchobject, branch, maxrows, maxcoefs, rowtype::Union{XPRSallocatable,Nothing,AbstractVector{Cchar}}, rhs::Union{XPRSallocatable,Nothing,AbstractVector{Float64}}, start::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, colind::Union{XPRSallocatable,Nothing,AbstractVector{Int32}}, rowcoef::Union{XPRSallocatable,Nothing,AbstractVector{Float64}})::Tuple{Int32,Int32,Union{Nothing,AbstractVector{Cchar}},Union{Nothing,AbstractVector{Float64}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Int32}},Union{Nothing,AbstractVector{Float64}}}
  branchxx = Int32(branch)
  p_nrows_dummy = Ref{Int32}(0)
  maxrowsxx = Int32(maxrows)
  p_ncoefs_dummy = Ref{Int32}(0)
  maxcoefsxx = Int32(maxcoefs)
  if isa(colind, XPRSallocatable)
    colind = Vector{Int32}(undef, maxcoefs)
  elseif colind != nothing
    if length(colind) < maxcoefs
      throw(XPRSexception("Argument colind is too short, needs " * (maxcoefs) * " elements but has only " * length(colind), nothing))
    end
  end
  if isa(rhs, XPRSallocatable)
    rhs = Vector{Float64}(undef, maxrows)
  elseif rhs != nothing
    if length(rhs) < maxrows
      throw(XPRSexception("Argument rhs is too short, needs " * (maxrows) * " elements but has only " * length(rhs), nothing))
    end
  end
  if isa(rowcoef, XPRSallocatable)
    rowcoef = Vector{Float64}(undef, maxcoefs)
  elseif rowcoef != nothing
    if length(rowcoef) < maxcoefs
      throw(XPRSexception("Argument rowcoef is too short, needs " * (maxcoefs) * " elements but has only " * length(rowcoef), nothing))
    end
  end
  if isa(rowtype, XPRSallocatable)
    rowtype = Vector{Cchar}(undef, maxrows)
  elseif rowtype != nothing
    if length(rowtype) < maxrows
      throw(XPRSexception("Argument rowtype is too short, needs " * (maxrows) * " elements but has only " * length(rowtype), nothing))
    end
  end
  if isa(start, XPRSallocatable)
    start = Vector{Int32}(undef, maxrows)
  elseif start != nothing
    if length(start) < maxrows
      throw(XPRSexception("Argument start is too short, needs " * (maxrows) * " elements but has only " * length(start), nothing))
    end
  end
  faddr = getFunctionAddress("XPRS_bo_getrows")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Ref{Cint},Cint,Ref{Cint},Cint,Ptr{Cchar},Ptr{Cdouble},Ptr{Cint},Ptr{Cint},Ptr{Cdouble}), bo.handle, branchxx, p_nrows_dummy, maxrowsxx, p_ncoefs_dummy, maxcoefsxx, isnothing(rowtype) ? C_NULL : rowtype, isnothing(rhs) ? C_NULL : rhs, isnothing(start) ? C_NULL : start, isnothing(colind) ? C_NULL : colind, isnothing(rowcoef) ? C_NULL : rowcoef)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_nrows = p_nrows_dummy[]
  p_ncoefs = p_ncoefs_dummy[]
  p_nrows, p_ncoefs, rowtype, rhs, start, colind, rowcoef
end
export XPRS_bo_getrows

"""
    XPRS_bo_addcuts(bo, branch, ncuts, cutind)::Nothing

Adds stored user cuts as new constraints to a branch of a user branching object.

# Arguments
- `bo::XPRSbranchobject`: The user branching object to modify.
- `branch::Integer`: The number of the branch to add the cuts for.
- `ncuts::Integer`: Number of cuts to add.
- `cutind::AbstractVector{Ptr{Cvoid}}`: Array of length `ncuts` containing the pointers to user cuts that should be added to the branch.

See also the documentation of the correponding function [XPRS_bo_addcuts](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_addcuts.html) in the C API.
"""
function XPRS_bo_addcuts(bo::XPRSbranchobject, branch, ncuts, cutind)::Nothing
  branchxx = Int32(branch)
  ncutsxx = Int32(ncuts)
  if isnothing(cutind) || length(cutind) == 0
    c_cutind = nothing
  elseif isa(cutind, AbstractVector{Ptr{Cvoid}})
    c_cutind = cutind
  else
    c_cutind = convert(Vector{Ptr{Cvoid}}, cutind)
  end
  faddr = getFunctionAddress("XPRS_bo_addcuts")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Cint,Cint,Ptr{Ptr{Cvoid}}), bo.handle, branchxx, ncutsxx, isnothing(c_cutind) ? C_NULL : c_cutind)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  nothing
end
export XPRS_bo_addcuts

"""
    XPRS_bo_getid(bo)::id

Returns the unique identifier assigned to a branching object.

# Arguments
- `bo::XPRSbranchobject`: A branching object.
# Return value
- `id::Int32`: Pointer to an integer where the identifier should be returned.

See also the documentation of the correponding function [XPRS_bo_getid](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_getid.html) in the C API.
"""
function XPRS_bo_getid(bo::XPRSbranchobject)::Int32
  p_id_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_bo_getid")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), bo.handle, p_id_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_id = p_id_dummy[]
  p_id
end
export XPRS_bo_getid

"""
    XPRS_bo_getlasterror(bo, maxbytes)::msgcode, msg, nbytes

Returns the last error encountered during a call to the given branch object.

# Arguments
- `bo::XPRSbranchobject`: The branch object.
- `maxbytes::Integer`: The size of the character buffer `msg`.
# Return values
- `msgcode::Int32`: Location where the error code will be returned.
- `msg::AbstractString`: A character buffer of size `maxbytes` in which the last error message relating to the given branching object will be returned.
- `nbytes::Int32`: The size of the required character buffer to fully return the error string.

See also the documentation of the correponding function [XPRS_bo_getlasterror](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_getlasterror.html) in the C API.
"""
function XPRS_bo_getlasterror(bo::XPRSbranchobject, maxbytes)::Tuple{Int32,AbstractString,Int32}
  p_msgcode_dummy = Ref{Int32}(0)
  msg_buffer = Vector{Cchar}(undef, maxbytes)
  maxbytesxx = Int32(maxbytes)
  p_nbytes_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_bo_getlasterror")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint},Ptr{Cchar},Cint,Ref{Cint}), bo.handle, p_msgcode_dummy, msg_buffer, maxbytesxx, p_nbytes_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_msgcode = p_msgcode_dummy[]
  msg = unsafe_string(pointer(msg_buffer))
  p_nbytes = p_nbytes_dummy[]
  p_msgcode, msg, p_nbytes
end
export XPRS_bo_getlasterror

"""
    XPRS_bo_validate(bo)::status

Verifies that a given branching object is valid for branching on the current branch-and-bound node of a MIP solve.

The function will check that all branches are non-empty, and if required, verify that the branching object can be presolved.

# Arguments
- `bo::XPRSbranchobject`: A branching object.
# Return value
- `status::Int32`: The returned status from checking the provided branching object: 0The object is acceptable.

See also the documentation of the correponding function [XPRS_bo_validate](https://www.fico.com/fico-xpress-optimization/docs/latest/solver/optimizer/HTML/XPRS_bo_validate.html) in the C API.
"""
function XPRS_bo_validate(bo::XPRSbranchobject)::Int32
  p_status_dummy = Ref{Int32}(0)
  faddr = getFunctionAddress("XPRS_bo_validate")
  retcode = ccall(faddr, Cint, (Ptr{Cvoid},Ref{Cint}), bo.handle, p_status_dummy)
  if retcode != 0
    throw(XPRSexception("Xpress error " * retcode, nothing))
  end
  p_status = p_status_dummy[]
  p_status
end
export XPRS_bo_validate

function cblplog(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcblplog(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `lplog`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcblplog(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcblplog")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cblplog, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(3)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcblplog

function XPRSremovecbslplog(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecblplog")
  unlinkCallbacks(Int32(3))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbslplog

function cbmiplog(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbmiplog(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `miplog`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbmiplog(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmiplog")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmiplog, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(4)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmiplog

function XPRSremovecbsmiplog(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmiplog")
  unlinkCallbacks(Int32(4))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmiplog

function cbcutlog(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbcutlog(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `cutlog`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbcutlog(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbcutlog")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbcutlog, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(5)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbcutlog

function XPRSremovecbscutlog(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbcutlog")
  unlinkCallbacks(Int32(5))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbscutlog

function cbbarlog(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbbarlog(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `barlog`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbbarlog(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbbarlog")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbbarlog, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(6)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbbarlog

function XPRSremovecbsbarlog(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbbarlog")
  unlinkCallbacks(Int32(6))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsbarlog

function cbcutmgr(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbcutmgr(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `cutmgr`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbcutmgr(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbcutmgr")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbcutmgr, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(7)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbcutmgr

function XPRSremovecbscutmgr(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbcutmgr")
  unlinkCallbacks(Int32(7))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbscutmgr

function cbchgnode(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_node::Ptr{Cint})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_node_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_node_in = unsafe_load(p_node)
    p_node_out = jcbnode.closure(prob_for_cb)
    end
    if p_node_out != nothing unsafe_store!(p_node, p_node_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbchgnode(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `chgnode`.
- `node`: A pointer to the number of the node selected by the Optimizer. This value cannot be changed.

`cb` will be invoked with this signature:
```
cb(cbprob)::node
```

"""
function XPRSaddcbchgnode(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbchgnode")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbchgnode, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(8)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbchgnode

function XPRSremovecbschgnode(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbchgnode")
  unlinkCallbacks(Int32(8))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbschgnode

function cboptnode(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_infeasible::Ptr{Cint})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_infeasible_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_infeasible_in = unsafe_load(p_infeasible)
    p_infeasible_out = jcbnode.closure(prob_for_cb)
    end
    if p_infeasible_out != nothing unsafe_store!(p_infeasible, p_infeasible_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcboptnode(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `optnode`.
- `infeasible`: The feasibility status. If set to a nonzero value by the user, the current node will be declared infeasible.

`cb` will be invoked with this signature:
```
cb(cbprob)::infeasible
```

"""
function XPRSaddcboptnode(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcboptnode")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cboptnode, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(9)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcboptnode

function XPRSremovecbsoptnode(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecboptnode")
  unlinkCallbacks(Int32(9))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsoptnode

function cbprenode(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_infeasible::Ptr{Cint})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_infeasible_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_infeasible_in = unsafe_load(p_infeasible)
    p_infeasible_out = jcbnode.closure(prob_for_cb)
    end
    if p_infeasible_out != nothing unsafe_store!(p_infeasible, p_infeasible_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbprenode(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `prenode`.
- `infeasible`: The feasibility status. If set to a nonzero value by the user, the current node will be declared infeasible by the Optimizer.

`cb` will be invoked with this signature:
```
cb(cbprob)::infeasible
```

"""
function XPRSaddcbprenode(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbprenode")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbprenode, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(10)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbprenode

function XPRSremovecbsprenode(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbprenode")
  unlinkCallbacks(Int32(10))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsprenode

function cbinfnode(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbinfnode(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `infnode`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbinfnode(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbinfnode")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbinfnode, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(11)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbinfnode

function XPRSremovecbsinfnode(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbinfnode")
  unlinkCallbacks(Int32(11))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsinfnode

function cbnodecutoff(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, node::Cint)::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb, node)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbnodecutoff(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `nodecutoff`.
- `node`: The node id of the node that is cut off. This id cannot be queried from the CURRENTNODE attribute as for other callbacks since this callback is not invoked in the context of the node being cutoff.

`cb` will be invoked with this signature:
```
cb(cbprob, node)::Nothing
```

"""
function XPRSaddcbnodecutoff(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbnodecutoff")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbnodecutoff, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(12)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbnodecutoff

function XPRSremovecbsnodecutoff(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbnodecutoff")
  unlinkCallbacks(Int32(12))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsnodecutoff

function cbintsol(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbintsol(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `intsol`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbintsol(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbintsol")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbintsol, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(13)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbintsol

function XPRSremovecbsintsol(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbintsol")
  unlinkCallbacks(Int32(13))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsintsol

function cbpreintsol(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, soltype::Cint, p_reject::Ptr{Cint}, p_cutoff::Ptr{Cdouble})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_reject_out = nothing
    p_cutoff_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_reject_in = unsafe_load(p_reject)
    p_cutoff_in = unsafe_load(p_cutoff)
    p_reject_out, p_cutoff_out = jcbnode.closure(prob_for_cb, soltype, p_cutoff_in)
    end
    if p_reject_out != nothing unsafe_store!(p_reject, p_reject_out); end
    if p_cutoff_out != nothing unsafe_store!(p_cutoff, p_cutoff_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbpreintsol(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `preintsol`.
- `soltype`: The type of MIP solution that has been found: 0The continuous relaxation solution to the current node of the tree search, which has been found to be integer feasible. 1A MIP solution found by a heuristic. 2A MIP solution provided by the user.
- `reject`: Set this to 1 if the solution should be rejected. When `soltype` is zero, this will also drop the node problem.
- `cutoff`: The new cutoff value that the Optimizer will use if the solution is accepted. If the user changes `p_cutoff`, the new value will be used instead. The cutoff value will not be updated if the solution is rejected.

`cb` will be invoked with this signature:
```
cb(cbprob, soltype, cutoff)::reject, cutoff
```

"""
function XPRSaddcbpreintsol(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbpreintsol")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbpreintsol, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Ptr{Cint}, Ptr{Cdouble}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(14)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbpreintsol

function XPRSremovecbspreintsol(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbpreintsol")
  unlinkCallbacks(Int32(14))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbspreintsol

function cbchgbranch(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_entity::Ptr{Cint}, p_up::Ptr{Cint}, p_estdeg::Ptr{Cdouble})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_entity_out = nothing
    p_up_out = nothing
    p_estdeg_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_entity_in = unsafe_load(p_entity)
    p_up_in = unsafe_load(p_up)
    p_estdeg_in = unsafe_load(p_estdeg)
    p_entity_out, p_up_out, p_estdeg_out = jcbnode.closure(prob_for_cb, p_estdeg_in)
    end
    if p_entity_out != nothing unsafe_store!(p_entity, p_entity_out); end
    if p_up_out != nothing unsafe_store!(p_up, p_up_out); end
    if p_estdeg_out != nothing unsafe_store!(p_estdeg, p_estdeg_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbchgbranch(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `chgbranch`.
- `entity`: A pointer to the variable or set on which to branch. Integer variables are identified by their column index, i.e. `0`, `1`,...(COLS`- 1`) and sets by their set index, i.e. `0`, `1`,...,(SETS`- 1`).
- `up`: If `p_entity` is a variable, this is `1` if the upward branch is to be made first, or `0` otherwise. If `p_entity` is a set, this is `3` if the upward branch is to be made first, or `2` otherwise.
- `estdeg`: This value is obsolete. It will be set to zero and any returned value is ignored.

`cb` will be invoked with this signature:
```
cb(cbprob, estdeg)::entity, up, estdeg
```

"""
function XPRSaddcbchgbranch(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbchgbranch")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbchgbranch, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}, Ptr{Cint}, Ptr{Cdouble}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(15)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbchgbranch

function XPRSremovecbschgbranch(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbchgbranch")
  unlinkCallbacks(Int32(15))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbschgbranch

function cbmessage(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, msg::Ptr{Cchar}, msglen::Cint, msgtype::Cint)::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    msg_for_cb = msg != C_NULL ? unsafe_string(msg) : ""
    jcbnode.closure(prob_for_cb, msg_for_cb, msglen, msgtype)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbmessage(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function.
- `msg`: A null terminated character array (string) containing the message, which may simply be a new line. The total number of bytes (including `NUL` terminator) will not exceed `XPRS_MAXMESSAGELENGTH`. If a message needs to be truncated to meet this limit, the last four bytes in `msg` are set to "...0".
- `msglen`: The length of the message string, excluding the null terminator.
- `msgtype`: Indicates the type of output message: 1information messages; 2(not used); 3warning messages; 4error messages.A negative value indicates that the Optimizer is about to finish and the buffers should be flushed at this time if the output is being redirected to a file.

`cb` will be invoked with this signature:
```
cb(cbprob, msg, msglen, msgtype)::Nothing
```

"""
function XPRSaddcbmessage(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmessage")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmessage, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cchar}, Cint, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(16)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmessage

function XPRSremovecbsmessage(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmessage")
  unlinkCallbacks(Int32(16))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmessage

function cbmipthread(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, threadprob::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    callbackProb(threadprob) do prob_for_cb
    jcbnode.closure(prob_for_cb, prob_for_cb)
    end
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbmipthread(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function.
- `threadprob`: The problem pointer for the MIP thread

`cb` will be invoked with this signature:
```
cb(cbprob, threadprob)::Nothing
```

"""
function XPRSaddcbmipthread(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmipthread")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmipthread, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(17)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmipthread

function XPRSremovecbsmipthread(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmipthread")
  unlinkCallbacks(Int32(17))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmipthread

function cbdestroymt(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbdestroymt(prob, cb, priority)


# Arguments
- `cbprob`: The thread problem passed to the callback function.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbdestroymt(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbdestroymt")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbdestroymt, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(18)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbdestroymt

function XPRSremovecbsdestroymt(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbdestroymt")
  unlinkCallbacks(Int32(18))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsdestroymt

function cbbariteration(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_action::Ptr{Cint})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_action_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_action_in = unsafe_load(p_action)
    p_action_out = jcbnode.closure(prob_for_cb)
    end
    if p_action_out != nothing unsafe_store!(p_action, p_action_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbbariteration(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `bariteration`.
- `action`: Defines a return value controlling barrier: <0continue with the next iteration; =0let barrier decide (use default stopping criteria); 1barrier stops with status not defined; 2barrier stops with optimal status; 3barrier stops with dual infeasible status; 4barrier stops wih primal infeasible status.

`cb` will be invoked with this signature:
```
cb(cbprob)::action
```

"""
function XPRSaddcbbariteration(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbbariteration")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbbariteration, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(19)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbbariteration

function XPRSremovecbsbariteration(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbbariteration")
  unlinkCallbacks(Int32(19))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsbariteration

function cbpresolve(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbpresolve(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbpresolve(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbpresolve")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbpresolve, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(20)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbpresolve

function XPRSremovecbspresolve(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbpresolve")
  unlinkCallbacks(Int32(20))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbspresolve

function cbnewnode(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, parentnode::Cint, node::Cint, branch::Cint)::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb, parentnode, node, branch)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbnewnode(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `newnode`.
- `parentnode`: Unique identifier for the parent of the new node.
- `node`: Unique identifier assigned to the new node.
- `branch`: The sequence number of the new node amongst the child nodes of `parentnode`. For regular branches on a MIP entity this will be either `0` or `1`.

`cb` will be invoked with this signature:
```
cb(cbprob, parentnode, node, branch)::Nothing
```

"""
function XPRSaddcbnewnode(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbnewnode")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbnewnode, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Cint, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(21)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbnewnode

function XPRSremovecbsnewnode(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbnewnode")
  unlinkCallbacks(Int32(21))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsnewnode

function cbchgbranchobject(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, branch::Ptr{Cvoid}, p_newbranch::Ptr{Ptr{Cvoid}})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_newbranch_out = nothing
    callbackProb(cbprob) do prob_for_cb
    branch_in = XPRSbranchobject(branch, false)
    p_newbranch_in = Ref{Ptr{Cvoid}}(C_NULL)
    p_newbranch_out = jcbnode.closure(prob_for_cb, branch_in)
    end
    if p_newbranch_out != nothing
      unsafe_store!(p_newbranch, p_newbranch_out.handle)
      p_newbranch_out.delOnClose = false
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbchgbranchobject(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `chgbranchobject`.
- `branch`: The candidate branching data selected by the Optimizer. Will be `nothing` if no candidates exist.
- `newbranch`: Optional new branching data to replace the Optimizer's selection. If `branch` or `nothing` is passed back, no change will be applied.

`cb` will be invoked with this signature:
```
cb(cbprob, branch)::newbranch
```

"""
function XPRSaddcbchgbranchobject(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbchgbranchobject")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbchgbranchobject, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Ptr{Cvoid}}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(22)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbchgbranchobject

function XPRSremovecbschgbranchobject(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbchgbranchobject")
  unlinkCallbacks(Int32(22))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbschgbranchobject

function cbgapnotify(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, p_relgapnotifytarget::Ptr{Cdouble}, p_absgapnotifytarget::Ptr{Cdouble}, p_absgapnotifyobjtarget::Ptr{Cdouble}, p_absgapnotifyboundtarget::Ptr{Cdouble})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    p_relgapnotifytarget_out = nothing
    p_absgapnotifytarget_out = nothing
    p_absgapnotifyobjtarget_out = nothing
    p_absgapnotifyboundtarget_out = nothing
    callbackProb(cbprob) do prob_for_cb
    p_relgapnotifytarget_in = unsafe_load(p_relgapnotifytarget)
    p_absgapnotifytarget_in = unsafe_load(p_absgapnotifytarget)
    p_absgapnotifyobjtarget_in = unsafe_load(p_absgapnotifyobjtarget)
    p_absgapnotifyboundtarget_in = unsafe_load(p_absgapnotifyboundtarget)
    p_relgapnotifytarget_out, p_absgapnotifytarget_out, p_absgapnotifyobjtarget_out, p_absgapnotifyboundtarget_out = jcbnode.closure(prob_for_cb, p_relgapnotifytarget_in, p_absgapnotifytarget_in, p_absgapnotifyobjtarget_in, p_absgapnotifyboundtarget_in)
    end
    if p_relgapnotifytarget_out != nothing unsafe_store!(p_relgapnotifytarget, p_relgapnotifytarget_out); end
    if p_absgapnotifytarget_out != nothing unsafe_store!(p_absgapnotifytarget, p_absgapnotifytarget_out); end
    if p_absgapnotifyobjtarget_out != nothing unsafe_store!(p_absgapnotifyobjtarget, p_absgapnotifyobjtarget_out); end
    if p_absgapnotifyboundtarget_out != nothing unsafe_store!(p_absgapnotifyboundtarget, p_absgapnotifyboundtarget_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbgapnotify(prob, cb, priority)


# Arguments
- `cbprob`: The current problem.
- `relgapnotifytarget`: The value the MIPRELGAPNOTIFY control will be set to after this callback. May be modified within the callback in order to set a new notification target.
- `absgapnotifytarget`: The value the MIPABSGAPNOTIFY control will be set to after this callback. May be modified within the callback in order to set a new notification target.
- `absgapnotifyobjtarget`: The value the MIPABSGAPNOTIFYOBJ control will be set to after this callback. May be modified within the callback in order to set a new notification target.
- `absgapnotifyboundtarget`: The value the MIPABSGAPNOTIFYBOUND control will be set to after this callback. May be modified within the callback in order to set a new notification target.

`cb` will be invoked with this signature:
```
cb(cbprob, relgapnotifytarget, absgapnotifytarget, absgapnotifyobjtarget, absgapnotifyboundtarget)::relgapnotifytarget, absgapnotifytarget, absgapnotifyobjtarget, absgapnotifyboundtarget
```

"""
function XPRSaddcbgapnotify(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbgapnotify")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbgapnotify, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(23)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbgapnotify

function XPRSremovecbsgapnotify(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbgapnotify")
  unlinkCallbacks(Int32(23))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsgapnotify

function cbusersolnotify(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, solname::Ptr{Cchar}, status::Cint)::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    solname_for_cb = solname != C_NULL ? unsafe_string(solname) : ""
    jcbnode.closure(prob_for_cb, solname_for_cb, status)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbusersolnotify(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `usersolnotify`.
- `solname`: The string name assigned to the solution when it was loaded into the Optimizer using XPRSaddmipsol.
- `status`: One of the following status values: 0An error occurred while processing the solution. (`XPRS_USERSOLSTATUS_ERROR`) 1Solution is feasible. (`XPRS_USERSOLSTATUS_ACCEPTED_FEASIBLE`) 2Solution is feasible after reoptimizing with fixed MIP entities. (`XPRS_USERSOLSTATUS_ACCEPTED_OPTIMIZED`) 3A local search heuristic was applied and a feasible solution discovered. (`XPRS_USERSOLSTATUS_SEARCHED_SOL`) 4A local search heuristic was applied but a feasible solution was not found. (`XPRS_USERSOLSTATUS_SEARCHED_NOSOL`) 5Solution is infeasible and a local search could not be applied. (`XPRS_USERSOLSTATUS_REJECTED_INFEAS_NOSEARCH`) 6Solution is partial and a local search could not be applied. (`XPRS_USERSOLSTATUS_REJECTED_PARTIAL_NOSEARCH`) 7Failed to reoptimize the problem with MIP entities fixed to the provided solution. Likely because a time or iteration limit was reached. (`XPRS_USERSOLSTATUS_REJECTED_FAILED_OPTIMIZE`) 8Solution is dropped. This can happen if the MIP problem is changed or solved to completion before the solution could be processed. (`XPRS_USERSOLSTATUS_DROPPED`) 9The solution is worse than the current MIP cutoff value. (`XPRS_USERSOLSTATUS_REJECTED_CUTOFF`)

`cb` will be invoked with this signature:
```
cb(cbprob, solname, status)::Nothing
```

"""
function XPRSaddcbusersolnotify(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbusersolnotify")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbusersolnotify, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cchar}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(24)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbusersolnotify

function XPRSremovecbsusersolnotify(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbusersolnotify")
  unlinkCallbacks(Int32(24))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsusersolnotify

function cbnodelpsolved(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbnodelpsolved(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `nodelpsolved`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbnodelpsolved(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbnodelpsolved")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbnodelpsolved, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(25)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbnodelpsolved

function XPRSremovecbsnodelpsolved(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbnodelpsolved")
  unlinkCallbacks(Int32(25))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsnodelpsolved

function cbcomputerestart(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbcomputerestart(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `computerestart`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbcomputerestart(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbcomputerestart")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbcomputerestart, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(26)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbcomputerestart

function XPRSremovecbscomputerestart(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbcomputerestart")
  unlinkCallbacks(Int32(26))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbscomputerestart

function cbstrongbranchsolve(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, bndidx::Cint)::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb, bndidx)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbstrongbranchsolve(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, bndidx)::Nothing
```

"""
function XPRSaddcbstrongbranchsolve(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbstrongbranchsolve")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbstrongbranchsolve, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(27)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbstrongbranchsolve

function XPRSremovecbsstrongbranchsolve(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbstrongbranchsolve")
  unlinkCallbacks(Int32(27))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsstrongbranchsolve

function cbbeforesolve(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbbeforesolve(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbbeforesolve(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbbeforesolve")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbbeforesolve, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(28)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbbeforesolve

function XPRSremovecbsbeforesolve(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbbeforesolve")
  unlinkCallbacks(Int32(28))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsbeforesolve

function cbbeforeobjective(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbbeforeobjective(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `beforeobjective`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbbeforeobjective(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbbeforeobjective")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbbeforeobjective, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(29)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbbeforeobjective

function XPRSremovecbsbeforeobjective(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbbeforeobjective")
  unlinkCallbacks(Int32(29))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsbeforeobjective

function cbafterobjective(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Nothing
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    callbackProb(cbprob) do prob_for_cb
    jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  nothing
end

"""

    XPRSaddcbafterobjective(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `afterobjective`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbafterobjective(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbafterobjective")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbafterobjective, Nothing, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(30)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbafterobjective

function XPRSremovecbsafterobjective(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbafterobjective")
  unlinkCallbacks(Int32(30))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsafterobjective

function cbchecktime(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbchecktime(prob, cb, priority)


# Arguments
- `cbprob`: The problem passed to the callback function, `checktime`.

`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbchecktime(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbchecktime")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbchecktime, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(31)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbchecktime

function XPRSremovecbschecktime(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbchecktime")
  unlinkCallbacks(Int32(31))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbschecktime

function cbslpcascadeend(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpcascadeend(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpcascadeend(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpcascadeend")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpcascadeend, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(32)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpcascadeend

function XPRSremovecbsslpcascadeend(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpcascadeend")
  unlinkCallbacks(Int32(32))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpcascadeend

function cbslpcascadestart(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpcascadestart(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpcascadestart(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpcascadestart")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpcascadestart, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(33)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpcascadestart

function XPRSremovecbsslpcascadestart(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpcascadestart")
  unlinkCallbacks(Int32(33))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpcascadestart

function cbslpcascadevar(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, col::Cint)::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb, col)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpcascadevar(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, col)::Nothing
```

"""
function XPRSaddcbslpcascadevar(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpcascadevar")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpcascadevar, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(34)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpcascadevar

function XPRSremovecbsslpcascadevar(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpcascadevar")
  unlinkCallbacks(Int32(34))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpcascadevar

function cbslpcascadevarfail(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, col::Cint)::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb, col)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpcascadevarfail(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, col)::Nothing
```

"""
function XPRSaddcbslpcascadevarfail(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpcascadevarfail")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpcascadevarfail, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(35)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpcascadevarfail

function XPRSremovecbsslpcascadevarfail(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpcascadevarfail")
  unlinkCallbacks(Int32(35))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpcascadevarfail

function cbslpconstruct(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpconstruct(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpconstruct(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpconstruct")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpconstruct, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(36)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpconstruct

function XPRSremovecbsslpconstruct(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpconstruct")
  unlinkCallbacks(Int32(36))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpconstruct

function cbslpintsol(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpintsol(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpintsol(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpintsol")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpintsol, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(37)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpintsol

function XPRSremovecbsslpintsol(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpintsol")
  unlinkCallbacks(Int32(37))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpintsol

function cbslpiterend(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpiterend(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpiterend(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpiterend")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpiterend, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(38)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpiterend

function XPRSremovecbsslpiterend(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpiterend")
  unlinkCallbacks(Int32(38))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpiterend

function cbslpiterstart(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpiterstart(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::Nothing
```

"""
function XPRSaddcbslpiterstart(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpiterstart")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpiterstart, Cint, (Ptr{Cvoid}, Ptr{Cvoid}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(39)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpiterstart

function XPRSremovecbsslpiterstart(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpiterstart")
  unlinkCallbacks(Int32(39))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpiterstart

function cbslpitervar(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, col::Cint)::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb, col)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpitervar(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, col)::Nothing
```

"""
function XPRSaddcbslpitervar(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpitervar")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpitervar, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(40)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpitervar

function XPRSremovecbsslpitervar(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpitervar")
  unlinkCallbacks(Int32(40))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpitervar

function cbslpdrcol(prob::Ptr{Cvoid}, data::Ptr{Cvoid}, col::Cint, detcol::Cint, detval::Cdouble, p_value::Ptr{Cdouble}, lb::Cdouble, ub::Cdouble)::Cint
  jcbnode = unsafe_pointer_to_objref(data)::CallbackNode
  try
    ret = nothing
    p_value_out = nothing
    callbackProb(prob) do prob_for_cb
    p_value_in = unsafe_load(p_value)
    ret, p_value_out = jcbnode.closure(prob_for_cb, col, detcol, detval, lb, ub)
    end
    if p_value_out != nothing unsafe_store!(p_value, p_value_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslpdrcol(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(prob, col, detcol, detval, lb, ub)::value
```

"""
function XPRSaddcbslpdrcol(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslpdrcol")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslpdrcol, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Cint, Cdouble, Ptr{Cdouble}, Cdouble, Cdouble))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(41)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslpdrcol

function XPRSremovecbsslpdrcol(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslpdrcol")
  unlinkCallbacks(Int32(41))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslpdrcol

function cbmsjobstart(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, jobdata::Ptr{Cvoid}, jobdesc::Ptr{Cchar}, p_status::Ptr{Cint})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    p_status_out = nothing
    callbackProb(cbprob) do prob_for_cb
    jobdata_node = unsafe_pointer_to_objref(jobdata)::CallbackNode
    jobdesc_for_cb = jobdesc != C_NULL ? unsafe_string(jobdesc) : ""
    p_status_in = unsafe_load(p_status)
    ret, p_status_out = jcbnode.closure(prob_for_cb, jobdata_node.closure, jobdesc_for_cb)
    end
    if p_status_out != nothing unsafe_store!(p_status, p_status_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbmsjobstart(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, jobdata, jobdesc)::status
```

"""
function XPRSaddcbmsjobstart(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmsjobstart")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmsjobstart, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cchar}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(42)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmsjobstart

function XPRSremovecbsmsjobstart(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmsjobstart")
  unlinkCallbacks(Int32(42))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmsjobstart

function cbmsjobend(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, jobdata::Ptr{Cvoid}, jobdesc::Ptr{Cchar}, p_status::Ptr{Cint})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    p_status_out = nothing
    callbackProb(cbprob) do prob_for_cb
    jobdata_node = unsafe_pointer_to_objref(jobdata)::CallbackNode
    jobdesc_for_cb = jobdesc != C_NULL ? unsafe_string(jobdesc) : ""
    p_status_in = unsafe_load(p_status)
    ret, p_status_out = jcbnode.closure(prob_for_cb, jobdata_node.closure, jobdesc_for_cb)
    end
    if p_status_out != nothing unsafe_store!(p_status, p_status_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbmsjobend(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, jobdata, jobdesc)::status
```

"""
function XPRSaddcbmsjobend(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmsjobend")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmsjobend, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cchar}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(43)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmsjobend

function XPRSremovecbsmsjobend(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmsjobend")
  unlinkCallbacks(Int32(43))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmsjobend

function cbmswinner(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, jobdata::Ptr{Cvoid}, jobdesc::Ptr{Cchar})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    jobdata_node = unsafe_pointer_to_objref(jobdata)::CallbackNode
    jobdesc_for_cb = jobdesc != C_NULL ? unsafe_string(jobdesc) : ""
    ret = jcbnode.closure(prob_for_cb, jobdata_node.closure, jobdesc_for_cb)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbmswinner(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, jobdata, jobdesc)::Nothing
```

"""
function XPRSaddcbmswinner(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbmswinner")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbmswinner, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cchar}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(44)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbmswinner

function XPRSremovecbsmswinner(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbmswinner")
  unlinkCallbacks(Int32(44))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsmswinner

function cbnlpcoefevalerror(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, col::Cint, row::Cint)::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    callbackProb(cbprob) do prob_for_cb
    ret = jcbnode.closure(prob_for_cb, col, row)
    end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbnlpcoefevalerror(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob, col, row)::Nothing
```

"""
function XPRSaddcbnlpcoefevalerror(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbnlpcoefevalerror")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbnlpcoefevalerror, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Cint))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(45)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbnlpcoefevalerror

function XPRSremovecbsnlpcoefevalerror(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbnlpcoefevalerror")
  unlinkCallbacks(Int32(45))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsnlpcoefevalerror

function cbslppreupdatelinearization(cbprob::Ptr{Cvoid}, cbdata::Ptr{Cvoid}, ifRepeat::Ptr{Cint})::Cint
  jcbnode = unsafe_pointer_to_objref(cbdata)::CallbackNode
  try
    ret = nothing
    ifRepeat_out = nothing
    callbackProb(cbprob) do prob_for_cb
    ifRepeat_in = unsafe_load(ifRepeat)
    ret, ifRepeat_out = jcbnode.closure(prob_for_cb)
    end
    if ifRepeat_out != nothing unsafe_store!(ifRepeat, ifRepeat_out); end
  catch ex
    setCallbackException(jcbnode.prob, ex)
    try
      XPRSinterrupt(jcbnode.prob, XPRS_STOP_GENERICERROR)
    catch ignored
    end
  end
  ret
end

"""

    XPRSaddcbslppreupdatelinearization(prob, cb, priority)



`cb` will be invoked with this signature:
```
cb(cbprob)::ifRepeat
```

"""
function XPRSaddcbslppreupdatelinearization(prob::XPRSprob, cb::Function, priority::Number)::Nothing
  f = getFunctionAddress("XPRSaddcbslppreupdatelinearization")
  jcbnode = CallbackNode()

  wrapper = @cfunction(cbslppreupdatelinearization, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Any, Cint), prob.handle, wrapper, jcbnode, Int32(priority))
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  jcbnode.closure = cb
  jcbnode.callback = Int32(46)
  linkCallback(prob, jcbnode)
  nothing
end
export XPRSaddcbslppreupdatelinearization

function XPRSremovecbsslppreupdatelinearization(prob::XPRSprob)::Nothing
  f = getFunctionAddress("XPRSremovecbslppreupdatelinearization")
  unlinkCallbacks(Int32(46))
  retcode = ccall(f, Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), prob.handle, C_NULL, C_NULL)
  consumeCallbackException(prob)
  if retcode != 0
    throw(XPRSexception(XPRSgetlasterror(prob)), nothing)
  end
  nothing
end
export XPRSremovecbsslppreupdatelinearization


"""
    XPRSaddcols(prob, objcoef, mat, lb, ub)

Implementation of `XPRSaddcols` that combines arguments `ncols`, `ncoefs`,
`start`, `rowind`, `rowcoef` into a single argument `mat`.

Note that the values in `mat.colptr` and `mat.rowval` are assumed to be 1 based
indices (the function will implicitly convert them to 0 based indices for
calling the C library.
"""
function XPRSaddcols(prob::XPRSprob, objcoef::AbstractVector{Float64}, mat::SparseMatrixCSC{Float64,Int32}, lb::AbstractVector{Float64}, ub::AbstractVector{Float64})
  XPRSaddcols(prob, mat.n, nnz(mat), objcoef, map(index1to0, mat.colptr), map(index1to0, mat.rowval), map.nzval, lb, ub)
end

end
